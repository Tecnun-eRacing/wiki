{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#bienvenido-a-la-wiki-de-tecnun-eracing","title":"Bienvenido a la wiki de Tecnun-eRacing","text":"<p>Aqui encontrar\u00e1s todos los Recursos y tutoriales necesarios para entender y mejorar el veh\u00edculo del equipo. </p>"},{"location":"#contribuir","title":"Contribuir","text":"<p>Esta documentaci\u00f3n est\u00e1 escrita mediante Material for Mkdocs, un generador de sitios est\u00e1tico donde se escriben documentos markdown que acaban  representados en las paginas que aqu\u00ed ves. En si misma esta documentaci\u00f3n es un  repositorio por lo que puedes descargarla y modificarla a tu gusto.</p>"},{"location":"Driverless/driverless/","title":"Driverless","text":"<p>Bienvenido a la secci\u00f3n de veh\u00edculo aut\u00f3nomo de Tecnun eRacing, donde se  trabaja para la implantaci\u00f3n de un sistema de conducci\u00f3n sin piloto.</p> <p>Aqui aprender\u00e1s a programar sistemas complejos basados en inteligencia artificial,  visi\u00f3n de maquina, programaci\u00f3n orientada a objetos, rob\u00f3tica y algoritmia.</p>"},{"location":"Driverless/MirenaSim/MirenaSim/","title":"MirenaSim","text":"<p>MirenaSim es el simulador desarrollado In-Haus para desarrollar y testear el sistema aut\u00f3nomo por completo, para ello implementa todos los sensores que uno esperar\u00eda tener en un veh\u00edculo real.</p>"},{"location":"Driverless/MirenaSim/MirenaSim/#instalacion","title":"Instalaci\u00f3n","text":"<p>MirenaSim es un paquete m\u00e1s de ROS2, viene incluido por defecto mirena_ws, el entorno de trabajo del proyecto. Puede obtenerse por separado en mirena_sim para su uso y compilaci\u00f3n es necesario tener instalado godot en el $PATH (Hay que pushear godot a rosdep), una vez descargado ejecutamos:</p> <pre><code>git submodule init\ngit submodule update\ncolcon --build --packages-select mirena_sim\n</code></pre>"},{"location":"Driverless/MirenaSim/MirenaSim/#current-features","title":"Current Features","text":"<ul> <li>Sensores<ul> <li>IMU</li> <li>LIDAR</li> <li>GPS</li> <li>C\u00e1mara</li> </ul> </li> <li>Carga de Pistas en formato MirenaTrack</li> <li>Tiempo simulado</li> <li>Generaci\u00f3n de Datasets para reconocimiento de Conos</li> </ul>"},{"location":"Driverless/MirenaSim/MirenaSim/#overview","title":"Overview","text":"<p>MirenaSim es simplemente una integraci\u00f3n del motor de videojuegos godot en el entorno de rob\u00f3tica ROS2, por medio de la interf\u00e1z de extensi\u00f3n GDEXTENSION que proporciona godot. </p> <p>La ventaja de usar Godot radica en la precisi\u00f3n de la simulaci\u00f3n comparado a la vida real, comparado con Sistemas como Gazebo, Godot permite una mayor extensibilidad y  customizaci\u00f3n para nuestro caso de uso.</p>"},{"location":"Driverless/MirenaSim/MirenaSim/#uso","title":"Uso","text":"<p>Para arrancar el simulador desde el entorno de trabajo hay que tener previamente sourceado ros2 y el entorno de trabajo.</p> <pre><code>source install/setup.sh\nros2 launch mirena_sim mirena_sim_launch.py\n</code></pre> <p>Esto deber\u00eda arrancar una ventana con el entorno de simulaci\u00f3n </p>"},{"location":"Driverless/MirenaSim/MirenaSim/#controles","title":"Controles","text":"Tecla Funci\u00f3n TAB Toggle Freecam m Carga del mapa l Cambio entre control manual y ROS p Dump YOLOV8 para la carpeta configurada"},{"location":"Driverless/MirenaSim/MirenaSim/#customizacion-y-modificacion","title":"Customizaci\u00f3n y modificaci\u00f3n","text":"<p>Si sourceas el entorno y ejecutas godot podr\u00e1s editar el proyecto de Godot  localizado en la carpeta MirenaSim del paquete all\u00ed puedes cambiar cosas como el posici\u00f3namiento de los sensores o el comportamiento del veh\u00edculo. </p>"},{"location":"Driverless/MirenaSim/YoloTraining/","title":"Tutorial: Training YOLOV8 para reconocer Conos de un feed de video","text":"<p>Para Implementar el pipeline de percepci\u00f3n es necesario el uso  de una red neuronal que localice y clasifique los obstaculos que el  coche enfrenta por pantalla, creemos que es algo clave en el desarrollo del proyecto dado que las c\u00e1maras son sensores baratos, r\u00e1pidos y que aportan muchisima informaci\u00f3n semantica de la situaci\u00f3n de la pista.</p>"},{"location":"Driverless/MirenaSim/YoloTraining/#prerequisitos","title":"Prerequisitos","text":"<p>Un entorno con:</p> <ul> <li>ROS2 Instalado</li> <li>mirena_ws instalado</li> <li>un entorno virtual python con ultralytics</li> <li>Un sistema acelerado por gr\u00e1fica como google colab/DIPC  para entrenar</li> </ul>"},{"location":"Driverless/MirenaSim/YoloTraining/#generacion-del-dataset","title":"Generaci\u00f3n del dataset","text":"<p>Necesitaremos Generar 2 conjuntos de datos: - Un set de entrenamiento - Un set de validaci\u00f3n</p> <p>Para elegir donde gener\u00e1 el simulador cada set de datos entraremos al editor y cambiaremos la opci\u00f3n Dataset Path del objeto MirenaCam correspondiente. </p> <p>Podemos elegirlo solo una vez y despues separar manualmente las imagenes que queramos para los distintos sets, si queremos podemos darle al play para  arrancar el simulador o compilarlo con colcon y lanzarlo a trav\u00e9s de <code>ros2 launch</code></p>"},{"location":"Driverless/MirenaSim/YoloTraining/#generar-datos","title":"Generar Datos","text":"<p>Cargamos una pista con la tecla m (Hay una pista por defecto en el folder MirenaSim) Conducimos el veh\u00edculo por medio de un mando, deteniendolo para tomar  capturas de cada frame (Para evitar un bug de desync entre fisicas y frame que desencuadra el dataset) </p>"},{"location":"Driverless/MirenaSim/YoloTraining/#exportar-datos-y-entrenar-la-red","title":"Exportar datos y entrenar la red","text":"<p>Una vez hayamos obtenido la cantidad deseada de datos en distintas posiciones separamos nuestros 2 sets antes mencionados y nos disponemos a entrenar la red.</p> <p>Necesitaremos a\u00f1adir un fichero data.yml para coordinar el entrenamiento la documentaci\u00f3n de yolo indica como debe estar estructurado, adjunto el  siguiente ejemplo:</p> <pre><code># Paths\ntrain: ./train  # Path to training images\nval: ./val      # Path to validation images\n\n# Dataset\nnames:\n  0: blue\n  1: yellow\n\n# Model\nmodel: yolov8n.pt  # Pre-trained model checkpoint to start training (e.g., yolov8n, yolov8s, yolov8m)\n\n# Training Parameters\nepochs: 50               # Number of epochs\nbatch: 16                # Batch size\nworkers: 8               # Number of data-loading threads\nproject: runs/train      # Save results to runs/train\nname: yolov8_custom      # Name of the experiment\ndevice: 0                # Device to train on (e.g., 0 for GPU, 'cpu' for CPU, or '0,1' for multi-GPU)\n\n# Optimization\noptimizer: SGD           # Optimizer: SGD, Adam, or AdamW\nlr0: 0.01                # Initial learning rate\nmomentum: 0.937          # Momentum for SGD\nweight_decay: 0.0005     # Weight decay\nwarmup_epochs: 3.0       # Warmup epochs\nwarmup_momentum: 0.8     # Warmup momentum\nwarmup_bias_lr: 0.1      # Warmup initial bias learning rate\n\n# Augmentations\nhsv_h: 0.015             # Image hue augmentation (fraction)\nhsv_s: 0.7               # Image saturation augmentation (fraction)\nhsv_v: 0.4               # Image value augmentation (fraction)\ndegrees: 0.0             # Image rotation (+/- degrees)\ntranslate: 0.1           # Image translation (+/- fraction)\nscale: 0.5               # Image scale (+/- gain)\nshear: 0.0               # Image shear (+/- degrees)\nperspective: 0.0         # Image perspective (+/- fraction), range 0-0.001\nflipud: 0.0              # Vertical flip (probability)\nfliplr: 0.5              # Horizontal flip (probability)\nmosaic: 1.0              # Mosaic augmentation (probability)\nmixup: 0.0               # Mixup augmentation (probability)\n\n# Logging and Saving\nsave: True               # Save the model after every epoch\nexist_ok: False          # Overwrite existing project folder if it exists\n</code></pre> <p>Nos tiene que quedar la siguente configuraci\u00f3n de ficheros</p> <pre><code>\u251c\u2500\u2500 data.yml\n\u251c\u2500\u2500 train\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 images\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 labels\n\u2514\u2500\u2500 val\n    \u251c\u2500\u2500 images\n    \u2514\u2500\u2500 labels\n</code></pre> <p>Adjunto el siguiente Dataset de Ejemplo para facilitar el familizarizarse con el proceso de training:</p> <p>MirenaCones (200 Img Train/25 Img Val) </p>"},{"location":"Driverless/MirenaSim/YoloTraining/#proceso-de-entrenamiento","title":"Proceso de entrenamiento","text":"<p>En este caso trabajaremos con notebooks de python en cualquier entorno con aceleraci\u00f3n hardware para acelerar el proceso. Cargaremos nuestro dataset generado en dicho entorno y los bloques a ejecutar ser\u00e1n los siguientes. </p> <pre><code>!pip install ultralytics #Instala el paquete ultralytics\n</code></pre> <pre><code>!nvidia-smi # Comprueba si tenemos aceleraci\u00f3n grafica nvidia\n</code></pre> <pre><code>!yolo train model=yolov8n.pt data=/content/datasets/MirenaCones/data.yml epochs=50 # Inicia el proceso de entrenamiento\n</code></pre> <p>Terminado el entrenamiento sacamos los mejores pesos y  los guardamos a buen recaudo.</p>"},{"location":"Driverless/MirenaSim/YoloTraining/#test-de-inferencia","title":"Test de inferencia","text":"<p>Podeis probar a ejecutar inferencia contra una imagen de prueba cualquiera mediante:</p> <pre><code>!yolo predict model=best.pt source=\"miImagen.png\"\n</code></pre>"},{"location":"Driverless/MirenaSim/YoloTraining/#inferencia-en-tiempo-real","title":"Inferencia en tiempo real","text":"<p>Dejo el siguiente script para que probeis inferencia en tiempo real  contra el topic de ROS2 de la camara.</p> <pre><code>import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\nimport cv2\nfrom ultralytics import YOLO\nimport numpy as np\n\nclass YoloV8ObjectDetectionNode(Node):\n    def __init__(self):\n        super().__init__('yolov8_object_detection_node')\n\n        # Parameters\n        self.declare_parameter('video_topic', '/MirenaCam/image')\n        self.declare_parameter('yolo_model_path', 'conesNN.pt')\n\n        self.video_topic = self.get_parameter('video_topic').value\n        self.yolo_model_path = self.get_parameter('yolo_model_path').value\n\n        # Load YOLOv8 model\n        self.model = YOLO(self.yolo_model_path)\n        self.bridge = CvBridge()\n\n        # Subscriber\n        self.subscription = self.create_subscription(\n            Image,\n            self.video_topic,\n            self.image_callback,\n            10\n        )\n\n        self.get_logger().info(f\"Subscribed to topic: {self.video_topic}\")\n        self.get_logger().info(f\"Loaded YOLO model: {self.yolo_model_path}\")\n\n    def image_callback(self, msg):\n        try:\n            # Convert ROS Image message to OpenCV image\n            frame = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\n\n            # Perform object detection\n            results = self.model(frame)\n\n            annotated_frame = results[0].plot()\n\n            # Display the annotated frame\n            cv2.imshow('YOLOv8 Object Detection', annotated_frame)\n            cv2.waitKey(1)\n\n        except Exception as e:\n            self.get_logger().error(f\"Error processing image: {e}\")\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = YoloV8ObjectDetectionNode()\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Shutting down YOLOv8 Object Detection Node')\n    finally:\n        cv2.destroyAllWindows()\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>Si lo ejecutais podreis ver la clasificaci\u00f3n en tiempo real de los conos y validar si vuestro modelo funciona a gusto.</p>"},{"location":"Driverless/MirenaSim/YoloTraining/#anexo","title":"Anexo","text":"<p>Script para visualizar los dataset</p> <pre><code>import os\nimport cv2\n\ndef load_yolo_annotations(annotation_path, width, height):\n    \"\"\"Load YOLO annotations and convert them to bounding box coordinates.\"\"\"\n    annotations = []\n    with open(annotation_path, 'r') as f:\n        for annotation in f.readlines():\n            parts = annotation.strip().split()\n            class_id = int(parts[0])\n            x_center = float(parts[1])\n            y_center = float(parts[2])\n            w = float(parts[3])\n            h = float(parts[4])\n\n            # Convert to pixel values\n            x_center = int(x_center * width)\n            y_center = int(y_center * height)\n            w = int(w * width)\n            h = int(h * height)\n\n            # Calculate bounding box corners\n            x1 = x_center - w // 2\n            y1 = y_center - h // 2\n            x2 = x_center + w // 2\n            y2 = y_center + h // 2\n\n            annotations.append((class_id, x1, y1, x2, y2))\n    return annotations\n\ndef visualize_yolo_annotations(image_path, annotation_path, class_names=None):\n    \"\"\" Visualizes images with YOLO annotations with navigation support. \"\"\"\n    # Load the image using OpenCV\n    image = cv2.imread(image_path)\n    height, width, _ = image.shape\n\n    # Read the annotations for the image\n    annotations = load_yolo_annotations(annotation_path, width, height)\n\n    # Draw bounding boxes\n    for class_id, x1, y1, x2, y2 in annotations:\n        # Draw bounding box (green)\n        cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2)\n\n        # Optionally, draw the class label\n        if class_names:\n            label = class_names[class_id] if class_id &lt; len(class_names) else str(class_id)\n            cv2.putText(image, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)\n\n    # Show the image with annotations\n    cv2.imshow('YOLOv8 Annotations', image)\n\ndef navigate_images(img_folder, label_folder, class_names=None):\n    \"\"\" Function to navigate through images and their annotations using left and right arrows. \"\"\"\n    img_files = sorted(os.listdir(img_folder))  # Sort images\n    label_files = sorted(os.listdir(label_folder))  # Sort corresponding label files\n    index = 0  # Start from the first image\n\n    # Create a window for image display\n    cv2.namedWindow('YOLOv8 Annotations', cv2.WINDOW_NORMAL)\n\n    while True:\n        # Get the paths of the current image and annotation\n        img_path = os.path.join(img_folder, img_files[index])\n        label_path = os.path.join(label_folder, label_files[index])\n\n        # Visualize the new image and annotations\n        visualize_yolo_annotations(img_path, label_path, class_names)\n\n        # Wait for key press and handle navigation\n        key = cv2.waitKey(0) &amp; 0xFF  # Get key press event\n\n        if key == ord('q'):  # Press 'q' to quit\n            break\n        elif key == 81:  # Left arrow key (ASCII code 81)\n            index -= 1\n        elif key == 83:  # Right arrow key (ASCII code 83)\n            index += 1\n\n        # Make sure the index stays within valid range\n        index = max(0, min(index, len(img_files) - 1))\n\n        # Clear the previous image and annotations (not needed anymore as OpenCV updates the same window)\n        # cv2.destroyAllWindows()  # Not needed in this case\n\n    cv2.destroyAllWindows()  # Close the window when done\n\n# Example usage:\nimg_folder = '/home/ozuba/Documentos/MirenaCones/train/images'\nlabel_folder = '/home/ozuba/Documentos/MirenaCones/train/labels'\nclass_names = ['blue', 'yellow']  # Replace with your actual class names\n\n# Start navigation through images\nnavigate_images(img_folder, label_folder, class_names)\n</code></pre>"},{"location":"Electronics/electronics/","title":"Electronics","text":"<p>Bienvenido a la secci\u00f3n de electronica, aqui encontraras todo lo necesario para entender todos los sitemas electricos y de software que hacen funcionar el TeR.</p> <p>En electronics nos encargamos de planificar, dise\u00f1ar y fabricar todos los sistemas que hacen que el veh\u00edculo se mueva y sea seguro. Nuestro trabajo abarca multiples disciplinas que van desde: - Dise\u00f1o de circuitos - Programaci\u00f3n en bajo nivel de Microcontroladores (Lenguaje C) - Dise\u00f1o y dimensionamiento del cableado de alto voltaje - Calibraci\u00f3n de sensores - Herramientas de uso interno para multiples lenguajes - Un largo etc...</p>"},{"location":"Electronics/GNUC/gnuc/","title":"GNU C Language Manual","text":""},{"location":"Electronics/GNUC/gnuc/#short-table-of-contents","title":"Short Table of Contents","text":"<ul> <li>1 The     First Example</li> <li>2 A     Complete Program</li> <li>3 Storage and     Data</li> <li>4 Beyond     Integers</li> <li>5 Lexical     Syntax</li> <li>6 Arithmetic</li> <li>7 Assignment Expressions</li> <li>8 Execution Control     Expressions</li> <li>9 Binary Operator Grammar</li> <li>10     Order of Execution</li> <li>11     Primitive Data Types</li> <li>12 Constants</li> <li>13 Type Size</li> <li>14 Pointers</li> <li>15 Structures</li> <li>16 Arrays</li> <li>17     Enumeration Types</li> <li>18 Defining Typedef Names</li> <li>19 Statements</li> <li>20 Variables</li> <li>21 Type     Qualifiers</li> <li>22 Functions</li> <li>23     Compatible Types</li> <li>24 Type     Conversions</li> <li>25 Scope</li> <li>26     Preprocessing</li> <li>27     Integers in Depth</li> <li>28 Floating Point in Depth</li> <li>29 Compilation</li> <li>30 Directing Compilation</li> <li>Appendix A     Type Alignment</li> <li>Appendix B Aliasing</li> <li>Appendix C Digraphs</li> <li>Appendix D Attributes in     Declarations</li> <li>Appendix E Signals</li> <li>Appendix F GNU Free     Documentation License</li> <li>Appendix G GNU General Public     License</li> <li>Index of Symbols and     Keywords</li> <li>Concept Index</li> </ul>"},{"location":"Electronics/GNUC/gnuc/#table-of-contents","title":"Table of Contents","text":"<ul> <li>1 The First     Example<ul> <li>1.1 Example: Recursive     Fibonacci<ul> <li>1.1.1 Function     Header</li> <li>1.1.2 Function     Body</li> </ul> </li> <li>1.2 The     Stack, And Stack Overflow</li> <li>1.3 Example: Iterative     Fibonacci</li> </ul> </li> <li>2 A Complete     Program<ul> <li>2.1     Complete Program Example</li> <li>2.2 Complete Program     Explanation</li> <li>2.3 Complete Program, Line     by Line</li> <li>2.4     Compiling the Example Program</li> </ul> </li> <li>3 Storage and Data</li> <li>4 Beyond     Integers<ul> <li>4.1 An Example with     Non-Integer Numbers</li> <li>4.2 An Example     with Arrays</li> <li>4.3     Calling the Array Example</li> <li>4.4 Variations for Array     Example</li> </ul> </li> <li>5 Lexical Syntax<ul> <li>5.1 Write     Programs in English!</li> <li>5.2 Characters</li> <li>5.3 Whitespace</li> <li>5.4 Comments</li> <li>5.5 Identifiers</li> <li>5.6 Operators and Punctuation</li> <li>5.7 Line     Continuation</li> </ul> </li> <li>6 Arithmetic<ul> <li>6.1 Basic     Arithmetic</li> <li>6.2 Integer     Arithmetic</li> <li>6.3 Integer     Overflow<ul> <li>6.3.1 Overflow with Unsigned     Integers</li> <li>6.3.2     Overflow with Signed Integers</li> </ul> </li> <li>6.4 Mixed-Mode     Arithmetic</li> <li>6.5     Division and Remainder</li> <li>6.6     Numeric Comparisons</li> <li>6.7 Shift     Operations<ul> <li>6.7.1     Shifting Makes New Bits</li> <li>6.7.2     Caveats for Shift Operations</li> <li>6.7.3 Shift Hacks</li> </ul> </li> <li>6.8 Bitwise     Operations</li> </ul> </li> <li>7     Assignment Expressions<ul> <li>7.1 Simple     Assignment</li> <li>7.2 Lvalues</li> <li>7.3     Modifying Assignment</li> <li>7.4 Increment and Decrement     Operators</li> <li>7.5 Postincrement and     Postdecrement</li> <li>7.6 Pitfall:     Assignment in Subexpressions</li> <li>7.7 Write Assignments     in Separate Statements</li> </ul> </li> <li>8 Execution Control     Expressions<ul> <li>8.1 Logical     Operators</li> <li>8.2 Logical Operators and     Comparisons</li> <li>8.3 Logical Operators and     Assignments</li> <li>8.4     Conditional Expression<ul> <li>8.4.1 Rules for the     Conditional Operator</li> <li>8.4.2 Conditional Operator     Branches</li> </ul> </li> <li>8.5 Comma     Operator<ul> <li>8.5.1     The Uses of the Comma Operator</li> <li>8.5.2     Clean Use of the Comma Operator</li> <li>8.5.3     When Not to Use the Comma Operator</li> </ul> </li> </ul> </li> <li>9     Binary Operator Grammar</li> <li>10 Order of     Execution<ul> <li>10.1     Reordering of Operands</li> <li>10.2 Associativity and     Ordering</li> <li>10.3 Sequence     Points</li> <li>10.4 Postincrement and     Ordering</li> <li>10.5     Ordering of Operands</li> <li>10.6 Optimization and Ordering</li> </ul> </li> <li>11 Primitive     Data Types<ul> <li>11.1 Integer Data     Types<ul> <li>11.1.1 Basic     Integers</li> <li>11.1.2 Signed and Unsigned     Types</li> <li>11.1.3 Narrow     Integers</li> <li>11.1.4 Conversion among Integer     Types</li> <li>11.1.5 Boolean Type</li> <li>11.1.6     Integer Variations</li> </ul> </li> <li>11.2 Floating-Point Data     Types</li> <li>11.3 Complex     Data Types</li> <li>11.4 The Void Type</li> <li>11.5 Other Data     Types</li> <li>11.6 Type     Designators</li> </ul> </li> <li>12 Constants<ul> <li>12.1 Integer     Constants</li> <li>12.2     Integer Constant Data Types</li> <li>12.3     Floating-Point Constants</li> <li>12.4     Imaginary Constants</li> <li>12.5 Invalid     Numbers</li> <li>12.6     Character Constants</li> <li>12.7 String     Constants</li> <li>12.8 UTF-8 String Constants</li> <li>12.9 Unicode Character Codes</li> <li>12.10 Wide Character Constants</li> <li>12.11     Wide String Constants</li> </ul> </li> <li>13 Type Size</li> <li>14 Pointers<ul> <li>14.1 Address of     Data</li> <li>14.2 Pointer Types</li> <li>14.3 Pointer-Variable     Declarations</li> <li>14.4 Pointer-Type Designators</li> <li>14.5     Dereferencing Pointers</li> <li>14.6 Null Pointers</li> <li>14.7 Dereferencing Null     or Invalid Pointers</li> <li>14.8 Void Pointers</li> <li>14.9 Pointer     Comparison</li> <li>14.10     Pointer Arithmetic</li> <li>14.11     Pointers and Arrays</li> <li>14.12 Pointer Arithmetic at     Low-Level</li> <li>14.13 Pointer Increment and     Decrement</li> <li>14.14 Drawbacks of Pointer     Arithmetic</li> <li>14.15 Pointer-Integer     Conversion</li> <li>14.16 Printing     Pointers</li> </ul> </li> <li>15 Structures<ul> <li>15.1     Referencing Structure Fields</li> <li>15.2 Arrays as     Fields</li> <li>15.3 Dynamic Memory Allocation</li> <li>15.4 Field Offset</li> <li>15.5 Structure     Layout</li> <li>15.6 Packed     Structures</li> <li>15.7 Bit Fields</li> <li>15.8 Bit Field     Packing</li> <li>15.9 <code>const</code>     Fields</li> <li>15.10 Arrays of     Length Zero</li> <li>15.11     Flexible Array Fields</li> <li>15.12 Overlaying Different     Structures</li> <li>15.13     Structure Assignment</li> <li>15.14 Unions</li> <li>15.15     Packing With Unions</li> <li>15.16 Cast to a     Union Type</li> <li>15.17 Structure Constructors</li> <li>15.18 Unnamed Types as Fields</li> <li>15.19 Incomplete     Types</li> <li>15.20 Intertwined Incomplete     Types</li> <li>15.21 Type Tags</li> </ul> </li> <li>16 Arrays<ul> <li>16.1 Accessing Array Elements</li> <li>16.2     Declaring an Array</li> <li>16.3 Strings</li> <li>16.4     Array Type Designators</li> <li>16.5     Incomplete Array Types</li> <li>16.6 Limitations of C Arrays</li> <li>16.7 Multidimensional Arrays</li> <li>16.8 Constructing Array Values</li> <li>16.9 Arrays of Variable Length</li> </ul> </li> <li>17 Enumeration     Types</li> <li>18     Defining Typedef Names</li> <li>19 Statements<ul> <li>19.1     Expression Statement</li> <li>19.2 <code>if</code>     Statement</li> <li>19.3     <code>if-else</code> Statement</li> <li>19.4 Blocks</li> <li>19.5     <code>return</code> Statement</li> <li>19.6 Loop     Statements<ul> <li>19.6.1     <code>while</code> Statement</li> <li>19.6.2 <code>do-while</code>     Statement</li> <li>19.6.3     <code>break</code> Statement</li> <li>19.6.4     <code>for</code> Statement</li> <li>19.6.5 Example of     <code>for</code></li> <li>19.6.6 Omitted     <code>for</code>-Expressions</li> <li>19.6.7 <code>for</code>-Index     Declarations</li> <li>19.6.8     <code>continue</code> Statement</li> </ul> </li> <li>19.7     <code>switch</code> Statement</li> <li>19.8 Example of     <code>switch</code></li> <li>19.9 Duff\u2019s     Device</li> <li>19.10 Case Ranges</li> <li>19.11 Null     Statement</li> <li>19.12     <code>goto</code> Statement and Labels</li> <li>19.13 Locally     Declared Labels</li> <li>19.14 Labels as     Values<ul> <li>19.14.1 Label     Value Uses</li> <li>19.14.2     Label Value Caveats</li> </ul> </li> <li>19.15 Statements and     Declarations in Expressions</li> </ul> </li> <li>20 Variables<ul> <li>20.1     Variable Declarations<ul> <li>20.1.1 Declaring Arrays and     Pointers</li> <li>20.1.2 Combining Variable     Declarations</li> </ul> </li> <li>20.2 Initializers</li> <li>20.3     Designated Initializers</li> <li>20.4 Referring     to a Type with <code>__auto_type</code></li> <li>20.5 Local     Variables</li> <li>20.6 File-Scope Variables</li> <li>20.7     Static Local Variables</li> <li>20.8     <code>extern</code> Declarations</li> <li>20.9 Allocating File-Scope     Variables</li> <li>20.10     <code>auto</code> and <code>register</code></li> <li>20.11     Omitting Types in Declarations</li> </ul> </li> <li>21 Type     Qualifiers<ul> <li>21.1     <code>const</code> Variables and Fields</li> <li>21.2     <code>volatile</code> Variables and Fields</li> <li>21.3     <code>restrict</code>-Qualified Pointers</li> <li>21.4 <code>restrict</code> Pointer     Example</li> </ul> </li> <li>22 Functions<ul> <li>22.1     Function Definitions<ul> <li>22.1.1 Function Parameter     Variables</li> <li>22.1.2 Forward Function     Declarations</li> <li>22.1.3 Static     Functions</li> <li>22.1.4     Arrays as Parameters<ul> <li>22.1.4.1 Array parameters are     pointers</li> <li>22.1.4.2     Passing array arguments</li> <li>22.1.4.3 Type qualifiers on     array parameters</li> </ul> </li> <li>22.1.5 Functions That     Accept Structure Arguments</li> </ul> </li> <li>22.2     Function Declarations</li> <li>22.3 Function     Calls</li> <li>22.4 Function Call Semantics</li> <li>22.5 Function     Pointers<ul> <li>22.5.1 Declaring Function     Pointers</li> <li>22.5.2 Assigning Function     Pointers</li> <li>22.5.3 Calling Function     Pointers</li> </ul> </li> <li>22.6 The     <code>main</code> Function<ul> <li>22.6.1     Returning Values from <code>main</code></li> <li>22.6.2 Accessing     Command-line Parameters</li> <li>22.6.3 Accessing Environment     Variables</li> </ul> </li> <li>22.7     Advanced Function Features<ul> <li>22.7.1 Variable-Length     Array Parameters</li> <li>22.7.2 Variable-Length     Parameter Lists</li> <li>22.7.3 Nested     Functions</li> <li>22.7.4 Inline Function     Definitions</li> </ul> </li> <li>22.8     Obsolete Function Features<ul> <li>22.8.1 Older     GNU C Inlining</li> <li>22.8.2 Old-Style Function     Definitions</li> </ul> </li> </ul> </li> <li>23 Compatible     Types</li> <li>24 Type     Conversions<ul> <li>24.1 Explicit Type Conversion</li> <li>24.2 Assignment Type     Conversions</li> <li>24.3     Argument Promotions</li> <li>24.4 Operand     Promotions</li> <li>24.5 Common Type</li> </ul> </li> <li>25 Scope</li> <li>26 Preprocessing<ul> <li>26.1     Preprocessing Overview</li> <li>26.2 Directives</li> <li>26.3     Preprocessing Tokens</li> <li>26.4 Header Files<ul> <li>26.4.1     <code>#include</code> Syntax</li> <li>26.4.2     <code>#include</code> Operation</li> <li>26.4.3 Search Path</li> <li>26.4.4     Once-Only Headers</li> <li>26.4.5     Computed Includes</li> </ul> </li> <li>26.5 Macros<ul> <li>26.5.1 Object-like Macros</li> <li>26.5.2 Function-like Macros</li> <li>26.5.3 Macro     Arguments</li> <li>26.5.4     Stringification</li> <li>26.5.5     Concatenation</li> <li>26.5.6 Variadic     Macros</li> <li>26.5.7     Predefined Macros</li> <li>26.5.8 Undefining and     Redefining Macros</li> <li>26.5.9 Directives Within     Macro Arguments</li> <li>26.5.10 Macro     Pitfalls<ul> <li>26.5.10.1 Misnesting</li> <li>26.5.10.2 Operator Precedence     Problems</li> <li>26.5.10.3 Swallowing the     Semicolon</li> <li>26.5.10.4 Duplication of Side     Effects</li> <li>26.5.10.5     Using <code>__auto_type</code> for Local Variables</li> <li>26.5.10.6 Self-Referential     Macros</li> <li>26.5.10.7     Argument Prescan</li> </ul> </li> </ul> </li> <li>26.6 Conditionals<ul> <li>26.6.1 Uses of Conditional     Directives</li> <li>26.6.2 Syntax of     Preprocessing Conditionals<ul> <li>26.6.2.1 The     <code>#ifdef</code> directive</li> <li>26.6.2.2 The     <code>#if</code> directive</li> <li>26.6.2.3 The     <code>defined</code> test</li> <li>26.6.2.4 The     <code>#else</code> directive</li> <li>26.6.2.5 The     <code>#elif</code> directive</li> </ul> </li> <li>26.6.3 Deleted Code</li> </ul> </li> <li>26.7 Diagnostics</li> <li>26.8 Line Control</li> <li>26.9 Null     Directive</li> </ul> </li> <li>27 Integers in     Depth<ul> <li>27.1 Integer Representations</li> <li>27.2 Maximum and Minimum     Values</li> </ul> </li> <li>28     Floating Point in Depth<ul> <li>28.1 Floating-Point     Representations</li> <li>28.2 Floating-Point Type     Specifications</li> <li>28.3 Special Floating-Point     Values</li> <li>28.4     Invalid Optimizations</li> <li>28.5 Floating Arithmetic     Exception Flags</li> <li>28.6 Exact Floating-Point     Arithmetic</li> <li>28.7 Rounding</li> <li>28.8 Rounding     Issues</li> <li>28.9     Significance Loss</li> <li>28.10 Fused Multiply-Add</li> <li>28.11 Error     Recovery</li> <li>28.12 Exact Floating-Point     Constants</li> <li>28.13 Handling     Infinity</li> <li>28.14 Handling NaN</li> <li>28.15 Signed Zeros</li> <li>28.16 Scaling by Powers of the     Base</li> <li>28.17 Rounding     Control</li> <li>28.18 Machine     Epsilon</li> <li>28.19     Complex Arithmetic</li> <li>28.20 Round-Trip Base     Conversion</li> <li>28.21 Further     Reading</li> </ul> </li> <li>29 Compilation</li> <li>30     Directing Compilation<ul> <li>30.1 Pragmas<ul> <li>30.1.1 Pragma     Basics</li> <li>30.1.2 Severity     Pragmas</li> <li>30.1.3     Optimization Pragmas</li> </ul> </li> <li>30.2 Static     Assertions</li> </ul> </li> <li>Appendix A Type     Alignment</li> <li>Appendix B Aliasing<ul> <li>B.1     Aliasing and Alignment</li> <li>B.2 Aliasing and     Length</li> <li>B.3 Type     Rules for Aliasing</li> </ul> </li> <li>Appendix C Digraphs</li> <li>Appendix D     Attributes in Declarations</li> <li>Appendix E Signals</li> <li>Appendix F GNU Free     Documentation License</li> <li>Appendix G GNU General Public     License</li> <li>Index of Symbols and Keywords</li> <li>Concept     Index</li> </ul> <p>Next: The First Example, Up: (dir) \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#gnu-c-manual","title":"GNU C Manual","text":"<p>This manual explains the C language for use with the GNU Compiler Collection (GCC) on the GNU/Linux operating system and other systems. We refer to this dialect as GNU C. If you already know C, you can use this as a reference manual.</p> <p>If you understand basic concepts of programming but know nothing about C, you can read this manual sequentially from the beginning to learn the C language.</p> <p>If you are a beginner in programming, we recommend you first learn a language with automatic garbage collection and no explicit pointers, rather than starting with C. Good choices include Lisp, Scheme, Python and Java. Because of C\u2019s explicit pointers, programmers must be careful to avoid certain kinds of errors in memory usage.</p> <p>C is a venerable language; it was first used in 1973. The GNU C Compiler, which was subsequently extended into the GNU Compiler Collection, was first released in 1987. Other important languages were designed based on C: once you know C, it gives you a useful base for learning C<code>++</code>, C#, Java, Scala, D, Go, and more.</p> <p>The special advantage of C is that it is fairly simple while allowing close access to the computer\u2019s hardware, which previously required writing in assembler language to describe the individual machine instructions. Some have called C a \u201chigh-level assembler language\u201d because of its explicit pointers and lack of automatic management of storage. As one wag put it, \u201cC combines the power of assembler language with the convenience of assembler language.\u201d However, C is far more portable, and much easier to read and write, than assembler language.</p> <p>This manual describes the GNU C language supported by the GNU Compiler Collection, as of roughly 2017. Please inform us of any changes needed to match the current version of GNU C.</p> <p>When a construct may be absent or work differently in other C compilers, we say so. When it is not part of ISO standard C, we say it is a \u201cGNU C extension,\u201d because it is useful to know that. However, standards and other dialects are secondary topics for this manual. For simplicity\u2019s sake, we keep those notes short, unless it is vital to say more.</p> <p>Some aspects of the meaning of C programs depend on the target platform: which computer, and which operating system, the compiled code will run on. Where this is the case, we say so.</p> <p>We hardly mention C<code>++</code> or other languages that the GNU Compiler Collection supports. We hope this manual will serve as a base for writing manuals for those languages, but languages so different can\u2019t share one common manual.</p> <p>The C language provides no built-in facilities for performing such common operations as input/output, memory management, string manipulation, and the like. Instead, these facilities are provided by functions defined in the standard library, which is automatically available in every C program. See The GNU C Library in The GNU C Library Reference Manual.</p> <p>Most GNU/Linux systems use the GNU C Library to provide those facilities. It is itself written in C, so once you know C you can read its source code and see how its library functions do their jobs. Some fraction of the functions are implemented as system calls, which means they contain a special instruction that asks the system kernel (Linux) to do a specific task. To understand how those are implemented, you\u2019d need to read Linux source code. Whether a library function is a system call is an internal implementation detail that makes no difference for how to call the function.</p> <p>This manual incorporates the former GNU C Preprocessor Manual, which was among the earliest GNU manuals. It also uses some text from the earlier GNU C Manual that was written by Trevis Rothwell and James Youngman.</p> <p>GNU C has many obscure features, each one either for historical compatibility or meant for very special situations. We have left them to a companion manual, the GNU C Obscurities Manual, which will be published digitally later.</p> <p>Please report errors and suggestions to c-manual@gnu.org.</p> \u2022 The First Example Getting started with basic C code. \u2022 Complete Program A whole example program that can be compiled and run. \u2022 Storage Basic layout of storage; bytes. \u2022 Beyond Integers Exploring different numeric types. \u2022 Lexical Syntax The various lexical components of C programs. \u2022 Arithmetic Numeric computations. \u2022 Assignment Expressions Storing values in variables. \u2022 Execution Control Expressions Expressions combining values in various ways. \u2022 Binary Operator Grammar An overview of operator precedence. \u2022 Order of Execution The order of program execution. \u2022 Primitive Types More details about primitive data types. \u2022 Constants Explicit constant values: details and examples. \u2022 Type Size The memory space occupied by a type. \u2022 Pointers Creating and manipulating memory pointers. \u2022 Structures Compound data types built by grouping other types. \u2022 Arrays Creating and manipulating arrays. \u2022 Enumeration Types Sets of integers with named values. \u2022 Defining Typedef Names Using <code>typedef</code> to define type names. \u2022 Statements Controlling program flow. \u2022 Variables Details about declaring, initializing, and using variables. \u2022 Type Qualifiers Mark variables for certain intended uses. \u2022 Functions Declaring, defining, and calling functions. \u2022 Compatible Types How to tell if two types are compatible with each other. \u2022 Type Conversions Converting between types. \u2022 Scope Different categories of identifier scope. \u2022 Preprocessing Using the GNU C preprocessor. \u2022 Integers in Depth How integer numbers are represented. \u2022 Floating Point in Depth How floating-point numbers are represented. \u2022 Compilation How to compile multi-file programs. \u2022 Directing Compilation Operations that affect compilation but don\u2019t change the program. <pre><code>Appendices\n</code></pre> \u2022 Type Alignment Where in memory a type can validly start. \u2022 Aliasing Accessing the same data in two types. \u2022 Digraphs Two-character aliases for some characters. \u2022 Attributes Specifying additional information in a declaration. \u2022 Signals Fatal errors triggered in various scenarios. \u2022 GNU Free Documentation License The license for this manual. \u2022 GNU General Public License \u2022 Symbol Index Keyword and symbol index. \u2022 Concept Index Detailed topical index. <pre><code></code></pre> <pre><code>\u2014 The Detailed Node Listing \u2014\n</code></pre> \u2022 Recursive Fibonacci Writing a simple function recursively. \u2022 Stack Each function call uses space in the stack. \u2022 Iterative Fibonacci Writing the same function iteratively. \u2022 Complete Example Turn the simple function into a full program. \u2022 Complete Explanation Explanation of each part of the example. \u2022 Complete Line-by-Line Explaining each line of the example. \u2022 Compile Example Using GCC to compile the example. \u2022 Float Example A function that uses floating-point numbers. \u2022 Array Example A function that works with arrays. \u2022 Array Example Call How to call that function. \u2022 Array Example Variations Different ways to write the call example. <pre><code>Lexical Syntax\n</code></pre> \u2022 English Write programs in English! \u2022 Characters The characters allowed in C programs. \u2022 Whitespace The particulars of whitespace characters. \u2022 Comments How to include comments in C code. \u2022 Identifiers How to form identifiers (names). \u2022 Operators/Punctuation Characters used as operators or punctuation. \u2022 Line Continuation Splitting one line into multiple lines. \u2022 Digraphs Two-character substitutes for some characters. <pre><code>Arithmetic\n</code></pre> \u2022 Basic Arithmetic Addition, subtraction, multiplication, and division. \u2022 Integer Arithmetic How C performs arithmetic with integer values. \u2022 Integer Overflow When an integer value exceeds the range of its type. \u2022 Mixed Mode Calculating with both integer values and floating-point values. \u2022 Division and Remainder How integer division works. \u2022 Numeric Comparisons Comparing numeric values for equality or order. \u2022 Shift Operations Shift integer bits left or right. \u2022 Bitwise Operations Bitwise conjunction, disjunction, negation. <pre><code>Assignment Expressions\n</code></pre> \u2022 Simple Assignment The basics of storing a value. \u2022 Lvalues Expressions into which a value can be stored. \u2022 Modifying Assignment Shorthand for changing an lvalue\u2019s contents. \u2022 Increment/Decrement Shorthand for incrementing and decrementing an lvalue\u2019s contents. \u2022 Postincrement/Postdecrement Accessing then incrementing or decrementing. \u2022 Assignment in Subexpressions How to avoid ambiguity. \u2022 Write Assignments Separately Write assignments as separate statements. <pre><code>Execution Control Expressions\n</code></pre> \u2022 Logical Operators Logical conjunction, disjunction, negation. \u2022 Logicals and Comparison Logical operators with comparison operators. \u2022 Logicals and Assignments Assignments with logical operators. \u2022 Conditional Expression An if/else construct inside expressions. \u2022 Comma Operator Build a sequence of subexpressions. <pre><code>Order of Execution\n</code></pre> \u2022 Reordering of Operands Operations in C are not necessarily computed in the order they are written. \u2022 Associativity and Ordering Some associative operations are performed in a particular order; others are not. \u2022 Sequence Points Some guarantees about the order of operations. \u2022 Postincrement and Ordering Ambiguous execution order with postincrement. \u2022 Ordering of Operands Evaluation order of operands and function arguments. \u2022 Optimization and Ordering Compiler optimizations can reorder operations only if it has no impact on program results. <pre><code>Primitive Data Types\n</code></pre> \u2022 Integer Types Description of integer types. \u2022 Floating-Point Data Types Description of floating-point types. \u2022 Complex Data Types Description of complex number types. \u2022 The Void Type A type indicating no value at all. \u2022 Other Data Types A brief summary of other types. <pre><code>Constants\n</code></pre> \u2022 Integer Constants Literal integer values. \u2022 Integer Const Type Types of literal integer values. \u2022 Floating Constants Literal floating-point values. \u2022 Imaginary Constants Literal imaginary number values. \u2022 Invalid Numbers Avoiding preprocessing number misconceptions. \u2022 Character Constants Literal character values. \u2022 Unicode Character Codes Unicode characters represented in either UTF-16 or UTF-32. \u2022 Wide Character Constants Literal characters values larger than 8 bits. \u2022 String Constants Literal string values. \u2022 UTF-8 String Constants Literal UTF-8 string values. \u2022 Wide String Constants Literal string values made up of 16- or 32-bit characters. <pre><code>Pointers\n</code></pre> \u2022 Address of Data Using the \u201caddress-of\u201d operator. \u2022 Pointer Types For each type, there is a pointer type. \u2022 Pointer Declarations Declaring variables with pointer types. \u2022 Pointer Type Designators Designators for pointer types. \u2022 Pointer Dereference Accessing what a pointer points at. \u2022 Null Pointers Pointers which do not point to any object. \u2022 Invalid Dereference Dereferencing null or invalid pointers. \u2022 Void Pointers Totally generic pointers, can cast to any. \u2022 Pointer Comparison Comparing memory address values. \u2022 Pointer Arithmetic Computing memory address values. \u2022 Pointers and Arrays Using pointer syntax instead of array syntax. \u2022 Low-Level Pointer Arithmetic More about computing memory address values. \u2022 Pointer Increment/Decrement Incrementing and decrementing pointers. \u2022 Pointer Arithmetic Drawbacks A common pointer bug to watch out for. \u2022 Pointer-Integer Conversion Converting pointer types to integer types. \u2022 Printing Pointers Using <code>printf</code> for a pointer\u2019s value. <pre><code>Structures\n</code></pre> \u2022 Referencing Fields Accessing field values in a structure object. \u2022 Arrays as Fields Accessing field values in a structure object. \u2022 Dynamic Memory Allocation Allocating space for objects while the program is running. \u2022 Field Offset Memory layout of fields within a structure. \u2022 Structure Layout Planning the memory layout of fields. \u2022 Packed Structures Packing structure fields as close as possible. \u2022 Bit Fields Dividing integer fields into fields with fewer bits. \u2022 Bit Field Packing How bit fields pack together in integers. \u2022 const Fields Making structure fields immutable. \u2022 Zero Length Zero-length array as a variable-length object. \u2022 Flexible Array Fields Another approach to variable-length objects. \u2022 Overlaying Structures Casting one structure type over an object of another structure type. \u2022 Structure Assignment Assigning values to structure objects. \u2022 Unions Viewing the same object in different types. \u2022 Packing With Unions Using a union type to pack various types into the same memory space. \u2022 Cast to Union Casting a value one of the union\u2019s alternative types to the type of the union itself. \u2022 Structure Constructors Building new structure objects. \u2022 Unnamed Types as Fields Fields\u2019 types do not always need names. \u2022 Incomplete Types Types which have not been fully defined. \u2022 Intertwined Incomplete Types Defining mutually-recursive structure types. \u2022 Type Tags Scope of structure and union type tags. <pre><code>Arrays\n</code></pre> \u2022 Accessing Array Elements How to access individual elements of an array. \u2022 Declaring an Array How to name and reserve space for a new array. \u2022 Strings A string in C is a special case of array. \u2022 Incomplete Array Types Naming, but not allocating, a new array. \u2022 Limitations of C Arrays Arrays are not first-class objects. \u2022 Multidimensional Arrays Arrays of arrays. \u2022 Constructing Array Values Assigning values to an entire array at once. \u2022 Arrays of Variable Length Declaring arrays of non-constant size. <pre><code>Statements\n</code></pre> \u2022 Expression Statement Evaluate an expression, as a statement, usually done for a side effect. \u2022 if Statement Basic conditional execution. \u2022 if-else Statement Multiple branches for conditional execution. \u2022 Blocks Grouping multiple statements together. \u2022 return Statement Return a value from a function. \u2022 Loop Statements Repeatedly executing a statement or block. \u2022 switch Statement Multi-way conditional choices. \u2022 switch Example A plausible example of using <code>switch</code>. \u2022 Duffs Device A special way to use <code>switch</code>. \u2022 Case Ranges Ranges of values for <code>switch</code> cases. \u2022 Null Statement A statement that does nothing. \u2022 goto Statement Jump to another point in the source code, identified by a label. \u2022 Local Labels Labels with limited scope. \u2022 Labels as Values Getting the address of a label. \u2022 Statement Exprs A series of statements used as an expression. <pre><code>Variables\n</code></pre> \u2022 Variable Declarations Name a variable and and reserve space for it. \u2022 Initializers Assigning initial values to variables. \u2022 Designated Inits Assigning initial values to array elements at particular array indices. \u2022 Auto Type Obtaining the type of a variable. \u2022 Local Variables Variables declared in function definitions. \u2022 File-Scope Variables Variables declared outside of function definitions. \u2022 Static Local Variables Variables declared within functions, but with permanent storage allocation. \u2022 Extern Declarations Declaring a variable which is allocated somewhere else. \u2022 Allocating File-Scope When is space allocated for file-scope variables? \u2022 auto and register Historically used storage directions. \u2022 Omitting Types The bad practice of declaring variables with implicit type. <pre><code>Type Qualifiers\n</code></pre> \u2022 const Variables whose values don\u2019t change. \u2022 volatile Variables whose values may be accessed or changed outside of the control of this program. \u2022 restrict Pointers Restricted pointers for code optimization. \u2022 restrict Pointer Example Example of how that works. <pre><code>Functions\n</code></pre> \u2022 Function Definitions Writing the body of a function. \u2022 Function Declarations Declaring the interface of a function. \u2022 Function Calls Using functions. \u2022 Function Call Semantics Call-by-value argument passing. \u2022 Function Pointers Using references to functions. \u2022 The main Function Where execution of a GNU C program begins. <pre><code>Type Conversions\n</code></pre> \u2022 Explicit Type Conversion Casting a value from one type to another. \u2022 Assignment Type Conversions Automatic conversion by assignment operation. \u2022 Argument Promotions Automatic conversion of function parameters. \u2022 Operand Promotions Automatic conversion of arithmetic operands. \u2022 Common Type When operand types differ, which one is used? <pre><code>Scope\n</code></pre> \u2022 Scope Different categories of identifier scope. <pre><code>Preprocessing\n</code></pre> \u2022 Preproc Overview Introduction to the C preprocessor. \u2022 Directives The form of preprocessor directives. \u2022 Preprocessing Tokens The lexical elements of preprocessing. \u2022 Header Files Including one source file in another. \u2022 Macros Macro expansion by the preprocessor. \u2022 Conditionals Controlling whether to compile some lines or ignore them. \u2022 Diagnostics Reporting warnings and errors. \u2022 Line Control Reporting source line numbers. \u2022 Null Directive A preprocessing no-op. <pre><code>Integers in Depth\n</code></pre> \u2022 Integer Representations How integer values appear in memory. \u2022 Maximum and Minimum Values Value ranges of integer types. <pre><code>Floating Point in Depth\n</code></pre> \u2022 Floating Representations How floating-point values appear in memory. \u2022 Floating Type Specs Precise details of memory representations. \u2022 Special Float Values Infinity, Not a Number, and Subnormal Numbers. \u2022 Invalid Optimizations Don\u2019t mess up non-numbers and signed zeros. \u2022 Exception Flags Handling certain conditions in floating point. \u2022 Exact Floating-Point Not all floating calculations lose precision. \u2022 Rounding When a floating result can\u2019t be represented exactly in the floating-point type in use. \u2022 Rounding Issues Avoid magnifying rounding errors. \u2022 Significance Loss Subtracting numbers that are almost equal. \u2022 Fused Multiply-Add Taking advantage of a special floating-point instruction for faster execution. \u2022 Error Recovery Determining rounding errors. \u2022 Exact Floating Constants Precisely specified floating-point numbers. \u2022 Handling Infinity When floating calculation is out of range. \u2022 Handling NaN What floating calculation is undefined. \u2022 Signed Zeros Positive zero vs. negative zero. \u2022 Scaling by the Base A useful exact floating-point operation. \u2022 Rounding Control Specifying some rounding behaviors. \u2022 Machine Epsilon The smallest number you can add to 1.0 and get a sum which is larger than 1.0. \u2022 Complex Arithmetic Details of arithmetic with complex numbers. \u2022 Round-Trip Base Conversion What happens between base-2 and base-10. \u2022 Further Reading References for floating-point numbers. <pre><code>Directing Compilation\n</code></pre> \u2022 Pragmas Controlling compilation of some constructs. \u2022 Static Assertions Compile-time tests for conditions. <pre><code></code></pre> <p></p> <p>Next: Complete Program, Previous: Top, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1-the-first-example","title":"1 The First Example","text":"<p>This chapter presents the source code for a very simple C program and uses it to explain a few features of the language. If you already know the basic points of C presented in this chapter, you can skim it or skip it.</p> <p>We present examples of C source code (other than comments) using a fixed-width typeface, since that\u2019s the way they look when you edit them in an editor such as GNU Emacs.</p> \u2022 Recursive Fibonacci Writing a simple function recursively. \u2022 Stack Each function call uses space in the stack. \u2022 Iterative Fibonacci Writing the same function iteratively. <p></p> <p>Next: Stack, Up: The First Example \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#11-example-recursive-fibonacci","title":"1.1 Example: Recursive Fibonacci","text":"<p>To introduce the most basic features of C, let\u2019s look at code for a simple mathematical function that does calculations on integers. This function calculates the <code>n</code>th number in the Fibonacci series, in which each number is the sum of the previous two: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \u2026.</p> <pre><code>int\nfib (int n)\n{\n  if (n &lt;= 2)  /* This avoids infinite recursion.  */\n    return 1;\n  else\n    return fib (n - 1) + fib (n - 2);\n}\n</code></pre> <p>This very simple program illustrates several features of C:</p> <ul> <li> <p>A function definition, whose first two lines constitute the function     header. See Function Definitions.</p> </li> <li> <p>A function parameter <code>n</code>, referred to as the variable <code>n</code> inside the     function body. See Function Parameter     Variables. A function definition     uses parameters to refer to the argument values provided in a call     to that function.</p> </li> <li> <p>Arithmetic. C programs add with \u2018<code>+</code>\u2019 and subtract with \u2018<code>-</code>\u2019. See     Arithmetic.</p> </li> <li> <p>Numeric comparisons. The operator \u2018<code>&lt;=</code>\u2019 tests for \u201cless than or     equal.\u201d See Numeric Comparisons.</p> </li> <li> <p>Integer constants written in base 10. See Integer     Constants.</p> </li> <li> <p>A function call. The function call <code>fib (n - 1)</code> calls the function     <code>fib</code>, passing as its argument the value <code>n - 1</code>. See Function     Calls.</p> </li> <li> <p>A comment, which starts with \u2018<code>/*</code>\u2019 and ends with \u2018<code>*/</code>\u2019. The     comment has no effect on the execution of the program. Its purpose     is to provide explanations to people reading the source code.     Including comments in the code is tremendously important\u2014they     provide background information so others can understand the code     more quickly. See Comments.</p> <p>In this manual, we present comment text in the variable-width typeface used for the text of the chapters, not in the fixed-width typeface used for the rest of the code. That is to make comments easier to read. This distinction of typeface does not exist in a real file of C source code.</p> </li> <li> <p>Two kinds of statements, the <code>return</code> statement and the <code>if</code>\u2026<code>else</code>     statement. See Statements.</p> </li> <li> <p>Recursion. The function <code>fib</code> calls itself; that is called a     recursive call. These are valid in C, and quite common.</p> <p>The <code>fib</code> function would not be useful if it didn\u2019t return. Thus, recursive definitions, to be of any use, must avoid infinite recursion.</p> <p>This function definition prevents infinite recursion by specially handling the case where <code>n</code> is two or less. Thus the maximum depth of recursive calls is less than <code>n</code>.</p> </li> </ul> \u2022 Function Header The function\u2019s name and how it is called. \u2022 Function Body Declarations and statements that implement the function. <p></p> <p>Next: Function Body, Up: Recursive Fibonacci \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#111-function-header","title":"1.1.1 Function Header","text":"<p>In our example, the first two lines of the function definition are the header. Its purpose is to state the function\u2019s name and say how it is called:</p> <pre><code>int\nfib (int n)\n</code></pre> <p>says that the function returns an integer (type <code>int</code>), its name is <code>fib</code>, and it takes one argument named <code>n</code> which is also an integer. (Data types will be explained later, in Primitive Types.)</p> <p></p> <p>Previous: Function Header, Up: Recursive Fibonacci \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#112-function-body","title":"1.1.2 Function Body","text":"<p>The rest of the function definition is called the function body. Like every function body, this one starts with \u2018<code>{</code>\u2019, ends with \u2018<code>}</code>\u2019, and contains zero or more statements and declarations. Statements specify actions to take, whereas declarations define names of variables, functions, and so on. Each statement and each declaration ends with a semicolon (\u2018<code>;</code>\u2019).</p> <p>Statements and declarations often contain expressions; an expression is a construct whose execution produces a value of some data type, but may also take actions through \u201cside effects\u201d that alter subsequent execution. A statement, by contrast, does not have a value; it affects further execution of the program only through the actions it takes.</p> <p>This function body contains no declarations, and just one statement, but that one is a complex statement in that it contains nested statements. This function uses two kinds of statements:</p> <p><code>return</code> The <code>return</code> statement makes the function return immediately. It looks like this:</p> <pre><code>return value;\n</code></pre> <p>Its meaning is to compute the expression <code>value</code> and exit the function, making it return whatever value that expression produced. For instance,</p> <pre><code>return 1;\n</code></pre> <p>returns the integer 1 from the function, and</p> <pre><code>return fib (n - 1) + fib (n - 2);\n</code></pre> <p>returns a value computed by performing two function calls as specified and adding their results.</p> <p><code>if``\u2026``else</code> The <code>if</code>\u2026<code>else</code> statement is a conditional. Each time it executes, it chooses one of its two substatements to execute and ignores the other. It looks like this:</p> <pre><code>if (condition)\n  if-true-statement\nelse\n  if-false-statement\n</code></pre> <p>Its meaning is to compute the expression <code>condition</code> and, if it\u2019s \u201ctrue,\u201d execute <code>if-true-statement</code>. Otherwise, execute <code>if-false-statement</code>. See if-else Statement.</p> <p>Inside the <code>if</code>\u2026<code>else</code> statement, <code>condition</code> is simply an expression. It\u2019s considered \u201ctrue\u201d if its value is nonzero. (A comparison operation, such as <code>n &lt;= 2</code>, produces the value 1 if it\u2019s \u201ctrue\u201d and 0 if it\u2019s \u201cfalse.\u201d See Numeric Comparisons.) Thus,</p> <pre><code>if (n &lt;= 2)\n  return 1;\nelse\n  return fib (n - 1) + fib (n - 2);\n</code></pre> <p>first tests whether the value of <code>n</code> is less than or equal to 2. If so, the expression <code>n &lt;= 2</code> has the value 1. So execution continues with the statement</p> <pre><code>return 1;\n</code></pre> <p>Otherwise, execution continues with this statement:</p> <pre><code>return fib (n - 1) + fib (n - 2);\n</code></pre> <p>Each of these statements ends the execution of the function and provides a value for it to return. See return Statement.</p> <p>Calculating <code>fib</code> using ordinary integers in C works only for <code>n</code> &lt; 47, because the value of <code>fib (47)</code> is too large to fit in type <code>int</code>. The addition operation that tries to add <code>fib (46)</code> and <code>fib (45)</code> cannot deliver the correct result. This occurrence is called integer overflow.</p> <p>Overflow can manifest itself in various ways, but one thing that can\u2019t possibly happen is to produce the correct value, since that can\u2019t fit in the space for the value. See Integer Overflow.</p> <p>See Functions, for a full explanation about functions.</p> <p></p> <p>Next: Iterative Fibonacci, Previous: Recursive Fibonacci, Up: The First Example \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#12-the-stack-and-stack-overflow","title":"1.2 The Stack, And Stack Overflow","text":"<p>Recursion has a drawback: there are limits to how many nested levels of function calls a program can make. In C, each function call allocates a block of memory which it uses until the call returns. C allocates these blocks consecutively within a large area of memory known as the stack, so we refer to the blocks as stack frames.</p> <p>The size of the stack is limited; if the program tries to use too much, that causes the program to fail because the stack is full. This is called stack overflow.</p> <p> </p> <p>Stack overflow on GNU/Linux typically manifests itself as the signal named <code>SIGSEGV</code>, also known as a \u201csegmentation fault.\u201d By default, this signal terminates the program immediately, rather than letting the program try to recover, or reach an expected ending point. (We commonly say in this case that the program \u201ccrashes\u201d). See Signals.</p> <p>It is inconvenient to observe a crash by passing too large an argument to recursive Fibonacci, because the program would run a long time before it crashes. This algorithm is simple but ridiculously slow: in calculating <code>fib (``n``)</code>, the number of (recursive) calls <code>fib (1)</code> or <code>fib (2)</code> that it makes equals the final result.</p> <p>However, you can observe stack overflow very quickly if you use this function instead:</p> <pre><code>int\nfill_stack (int n)\n{\n  if (n &lt;= 1)  /* This limits the depth of recursion.  */\n    return 1;\n  else\n    return fill_stack (n - 1);\n}\n</code></pre> <p>Under gNewSense GNU/Linux on the Lemote Yeeloong, without optimization and using the default configuration, an experiment showed there is enough stack space to do 261906 nested calls to that function. One more, and the stack overflows and the program crashes. On another platform, with a different configuration, or with a different function, the limit might be bigger or smaller.</p> <p></p> <p>Previous: Stack, Up: The First Example \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#13-example-iterative-fibonacci","title":"1.3 Example: Iterative Fibonacci","text":"<p>Here\u2019s a much faster algorithm for computing the same Fibonacci series. It is faster for two reasons. First, it uses iteration (that is, repetition or looping) rather than recursion, so it doesn\u2019t take time for a large number of function calls. But mainly, it is faster because the number of repetitions is small\u2014only <code>n</code>.</p> <pre><code>int\nfib (int n)\n{\n  int last = 1;   /* Initial value is fib (1).  */\n  int prev = 0;   /* Initial value controls fib (2).  */\n  int i;\n\n  for (i = 1; i &lt; n; ++i)\n    /* If n is 1 or less, the loop runs zero times,  */\n    /* since i &lt; n is false the first time.  */\n    {\n      /* Now last is fib (i)\n         and prev is fib (i - 1).  */\n      /* Compute fib (i + 1).  */\n      int next = prev + last;\n      /* Shift the values down.  */\n      prev = last;\n      last = next;\n      /* Now last is fib (i + 1)\n         and prev is fib (i).\n         But that won\u2019t stay true for long,\n         because we are about to increment i.  */\n    }\n\n  return last;\n}\n</code></pre> <p>This definition computes <code>fib (``n``)</code> in a time proportional to <code>n</code>. The comments in the definition explain how it works: it advances through the series, always keeps the last two values in <code>last</code> and <code>prev</code>, and adds them to get the next value.</p> <p>Here are the additional C features that this definition uses:</p> <p>Internal blocks Within a function, wherever a statement is called for, you can write a block. It looks like <code>{</code><code>\u2026</code><code>}</code> and contains zero or more statements and declarations. (You can also use additional blocks as statements in a block.)</p> <p>The function body also counts as a block, which is why it can contain statements and declarations.</p> <p>See Blocks.</p> <p>Declarations of local variables This function body contains declarations as well as statements. There are three declarations directly in the function body, as well as a fourth declaration in an internal block. Each starts with <code>int</code> because it declares a variable whose type is integer. One declaration can declare several variables, but each of these declarations is simple and declares just one variable.</p> <p>Variables declared inside a block (either a function body or an internal block) are local variables. These variables exist only within that block; their names are not defined outside the block, and exiting the block deallocates their storage. This example declares four local variables: <code>last</code>, <code>prev</code>, <code>i</code>, and <code>next</code>.</p> <p>The most basic local variable declaration looks like this:</p> <pre><code>type variablename;\n</code></pre> <p>For instance,</p> <pre><code>int i;\n</code></pre> <p>declares the local variable <code>i</code> as an integer. See Variable Declarations.</p> <p>Initializers When you declare a variable, you can also specify its initial value, like this:</p> <pre><code>type variablename = value;\n</code></pre> <p>For instance,</p> <pre><code>int last = 1;\n</code></pre> <p>declares the local variable <code>last</code> as an integer (type <code>int</code>) and starts it off with the value 1. See Initializers.</p> <p>Assignment Assignment: a specific kind of expression, written with the \u2018<code>=</code>\u2019 operator, that stores a new value in a variable or other place. Thus,</p> <pre><code>variable = value\n</code></pre> <p>is an expression that computes <code>value</code> and stores the value in <code>variable</code>. See Assignment Expressions.</p> <p>Expression statements An expression statement is an expression followed by a semicolon. That computes the value of the expression, then ignores the value.</p> <p>An expression statement is useful when the expression changes some data or has other side effects\u2014for instance, with function calls, or with assignments as in this example. See Expression Statement.</p> <p>Using an expression with no side effects in an expression statement is pointless except in very special cases. For instance, the expression statement <code>x;</code> would examine the value of <code>x</code> and ignore it. That is not useful.</p> <p>Increment operator The increment operator is \u2018<code>++</code>\u2019. <code>++i</code> is an expression that is short for <code>i = i + 1</code>. See Increment/Decrement.</p> <p><code>for</code> statements A <code>for</code> statement is a clean way of executing a statement repeatedly\u2014a loop (see Loop Statements). Specifically,</p> <pre><code>for (i = 1; i &lt; n; ++i)\n  body\n</code></pre> <p>means to start by doing <code>i = 1</code> (set <code>i</code> to one) to prepare for the loop. The loop itself consists of</p> <ul> <li>Testing <code>i &lt; n</code> and exiting the loop if that\u2019s false.</li> <li>Executing <code>body</code>.</li> <li>Advancing the loop (executing <code>++i</code>, which increments <code>i</code>).</li> </ul> <p>The net result is to execute <code>body</code> with 1 in <code>i</code>, then with 2 in <code>i</code>, and so on, stopping just before the repetition where <code>i</code> would equal <code>n</code>. If <code>n</code> is less than 1, the loop will execute the body zero times.</p> <p>The body of the <code>for</code> statement must be one and only one statement. You can\u2019t write two statements in a row there; if you try to, only the first of them will be treated as part of the loop.</p> <p>The way to put multiple statements in such a place is to group them with a block, and that\u2019s what we do in this example.</p> <p></p> <p>Next: Storage, Previous: The First Example, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2-a-complete-program","title":"2 A Complete Program","text":"<p>It\u2019s all very well to write a Fibonacci function, but you cannot run it by itself. It is a useful program, but it is not a complete program.</p> <p>In this chapter we present a complete program that contains the <code>fib</code> function. This example shows how to make the program start, how to make it finish, how to do computation, and how to print a result.</p> \u2022 Complete Example Turn the simple function into a full program. \u2022 Complete Explanation Explanation of each part of the example. \u2022 Complete Line-by-Line Explaining each line of the example. \u2022 Compile Example Using GCC to compile the example. <p></p> <p>Next: Complete Explanation, Up: Complete Program \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#21-complete-program-example","title":"2.1 Complete Program Example","text":"<p>Here is the complete program that uses the simple, recursive version of the <code>fib</code> function (see Recursive Fibonacci):</p> <pre><code>#include &lt;stdio.h&gt;\n\nint\nfib (int n)\n{\n  if (n &lt;= 2)  /* This avoids infinite recursion.  */\n    return 1;\n  else\n    return fib (n - 1) + fib (n - 2);\n}\n\nint\nmain (void)\n{\n  printf (\"Fibonacci series item %d is %d\\n\",\n          20, fib (20));\n  return 0;\n}\n</code></pre> <p>This program prints a message that shows the value of <code>fib (20)</code>.</p> <p>Now for an explanation of what that code means.</p> <p></p> <p>Next: Complete Line-by-Line, Previous: Complete Example, Up: Complete Program \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#22-complete-program-explanation","title":"2.2 Complete Program Explanation","text":"<p>Here\u2019s the explanation of the code of the example in the previous section.</p> <p>This sample program prints a message that shows the value of <code>fib (20)</code>, and exits with code 0 (which stands for successful execution).</p> <p>Every C program is started by running the function named <code>main</code>. Therefore, the example program defines a function named <code>main</code> to provide a way to start it. Whatever that function does is what the program does. See The main Function.</p> <p>The <code>main</code> function is the first one called when the program runs, but it doesn\u2019t come first in the example code. The order of the function definitions in the source code makes no difference to the program\u2019s meaning.</p> <p>The initial call to <code>main</code> always passes certain arguments, but <code>main</code> does not have to pay attention to them. To ignore those arguments, define <code>main</code> with <code>void</code> as the parameter list. (<code>void</code> as a function\u2019s parameter list normally means \u201ccall with no arguments,\u201d but <code>main</code> is a special case.)</p> <p>The function <code>main</code> returns 0 because that is the conventional way for <code>main</code> to indicate successful execution. It could instead return a positive integer to indicate failure, and some utility programs have specific conventions for the meaning of certain numeric failure codes. See Values from main.</p> <p></p> <p>The simplest way to print text in C is by calling the <code>printf</code> function, so here we explain very briefly what that function does. For a full explanation of <code>printf</code> and the other standard I/O functions, see The GNU C Library in The GNU C Library Reference Manual.</p> <p></p> <p>The first argument to <code>printf</code> is a string constant (see String Constants) that is a template for output. The function <code>printf</code> copies most of that string directly as output, including the newline character at the end of the string, which is written as \u2018<code>\\n</code>\u2019. The output goes to the program\u2019s standard output destination, which in the usual case is the terminal.</p> <p>\u2018<code>%</code>\u2019 in the template introduces a code that substitutes other text into the output. Specifically, \u2018<code>%d</code>\u2019 means to take the next argument to <code>printf</code> and substitute it into the text as a decimal number. (The argument for \u2018<code>%d</code>\u2019 must be of type <code>int</code>; if it isn\u2019t, <code>printf</code> will malfunction.) So the output is a line that looks like this:</p> <pre><code>Fibonacci series item 20 is 6765\n</code></pre> <p>This program does not contain a definition for <code>printf</code> because it is defined by the C library, which makes it available in all C programs. However, each program does need to declare <code>printf</code> so it will be called correctly. The <code>#include</code> line takes care of that; it includes a header file called <code>stdio.h</code> into the program\u2019s code. That file is provided by the operating system and it contains declarations for the many standard input/output functions in the C library, one of which is <code>printf</code>.</p> <p>Don\u2019t worry about header files for now; we\u2019ll explain them later in Header Files.</p> <p>The first argument of <code>printf</code> does not have to be a string constant; it can be any string (see Strings). However, using a constant is the most common case.</p> <p></p> <p>Next: Compile Example, Previous: Complete Explanation, Up: Complete Program \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#23-complete-program-line-by-line","title":"2.3 Complete Program, Line by Line","text":"<p>Here\u2019s the same example, explained line by line. Beginners, do you find this helpful or not? Would you prefer a different layout for the example? Please tell rms@gnu.org.</p> <pre><code>#include &lt;stdio.h&gt;      /* Include declaration of usual */\n                        /*   I/O functions such as printf.  */\n                        /* Most programs need these.  */\n\nint                     /* This function returns an int.  */\nfib (int n)             /* Its name is fib;  */\n                        /*   its argument is called n.  */\n{                       /* Start of function body.  */\n  /* This stops the recursion from being infinite.  */\n  if (n &lt;= 2)           /* If n is 1 or 2,  */\n    return 1;           /*   make fib return 1.  */\n  else                  /* otherwise, add the two previous  */\n                        /* Fibonacci numbers.  */\n    return fib (n - 1) + fib (n - 2);\n}\n\nint                     /* This function returns an int.  */\nmain (void)             /* Start here; ignore arguments.  */\n{                       /* Print message with numbers in it.  */\n  printf (\"Fibonacci series item %d is %d\\n\",\n          20, fib (20));\n  return 0;             /* Terminate program, report success.  */\n}\n</code></pre> <p></p> <p>Previous: Complete Line-by-Line, Up: Complete Program \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#24-compiling-the-example-program","title":"2.4 Compiling the Example Program","text":"<p>To run a C program requires converting the source code into an executable file. This is called compiling the program, and the command to do that using GNU C is <code>gcc</code>.</p> <p>This example program consists of a single source file. If we call that file <code>fib1.c</code>, the complete command to compile it is this:</p> <pre><code>gcc -g -O -o fib1 fib1.c\n</code></pre> <p>Here, <code>-g</code> says to generate debugging information, <code>-O</code> says to optimize at the basic level, and <code>-o fib1</code> says to put the executable program in the file <code>fib1</code>.</p> <p>To run the program, use its file name as a shell command. For instance,</p> <pre><code>./fib1\n</code></pre> <p>However, unless you are sure the program is correct, you should expect to need to debug it. So use this command,</p> <pre><code>gdb fib1\n</code></pre> <p>which starts the GDB debugger (see A Sample GDB Session in Debugging with GDB) so you can run and debug the executable program <code>fib1</code>.</p> <p>Richard Stallman\u2019s advice, from personal experience, is to turn to the debugger as soon as you can reproduce the problem. Don\u2019t try to avoid it by using other methods instead\u2014occasionally they are shortcuts, but usually they waste an unbounded amount of time. With the debugger, you will surely find the bug in a reasonable time; overall, you will get your work done faster. The sooner you get serious and start the debugger, the sooner you are likely to find the bug.</p> <p>See Compilation, for an introduction to compiling more complex programs which consist of more than one source file.</p> <p></p> <p>Next: Beyond Integers, Previous: Complete Program, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#3-storage-and-data","title":"3 Storage and Data","text":"<p>Storage in C programs is made up of units called bytes. A byte is the smallest unit of storage that can be used in a first-class manner.</p> <p>On nearly all computers, a byte consists of 8 bits. There are a few peculiar computers (mostly \u201cembedded controllers\u201d for very small systems) where a byte is longer than that, but this manual does not try to explain the peculiarity of those computers; we assume that a byte is 8 bits.</p> <p>Every C data type is made up of a certain number of bytes; that number is the data type\u2019s size. See Type Size, for details. The types <code>signed char</code> and <code>unsigned char</code> are one byte long; use those types to operate on data byte by byte. See Signed and Unsigned Types. You can refer to a series of consecutive bytes as an array of <code>char</code> elements; that\u2019s what a character string looks like in memory. See String Constants.</p> <p></p> <p>Next: Lexical Syntax, Previous: Storage, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#4-beyond-integers","title":"4 Beyond Integers","text":"<p>So far we\u2019ve presented programs that operate on integers. In this chapter we\u2019ll present examples of handling non-integral numbers and arrays of numbers.</p> \u2022 Float Example A function that uses floating-point numbers. \u2022 Array Example A function that works with arrays. \u2022 Array Example Call How to call that function. \u2022 Array Example Variations Different ways to write the call example. <p></p> <p>Next: Array Example, Up: Beyond Integers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#41-an-example-with-non-integer-numbers","title":"4.1 An Example with Non-Integer Numbers","text":"<p>Here\u2019s a function that operates on and returns floating point numbers that don\u2019t have to be integers. Floating point represents a number as a fraction together with a power of 2. (For more detail, see Floating-Point Data Types.) This example calculates the average of three floating point numbers that are passed to it as arguments:</p> <pre><code>double\naverage_of_three (double a, double b, double c)\n{\n  return (a + b + c) / 3;\n}\n</code></pre> <p>The values of the parameter <code>a</code>, <code>b</code> and <code>c</code> do not have to be integers, and even when they happen to be integers, most likely their average is not an integer.</p> <p><code>double</code> is the usual data type in C for calculations on floating-point numbers.</p> <p>To print a <code>double</code> with <code>printf</code>, we must use \u2018<code>%f</code>\u2019 instead of \u2018<code>%d</code>\u2019:</p> <pre><code>printf (\"Average is %f\\n\",\n        average_of_three (1.1, 9.8, 3.62));\n</code></pre> <p>The code that calls <code>printf</code> must pass a <code>double</code> for printing with \u2018<code>%f</code>\u2019 and an <code>int</code> for printing with \u2018<code>%d</code>\u2019. If the argument has the wrong type, <code>printf</code> will produce meaningless output.</p> <p>Here\u2019s a complete program that computes the average of three specific numbers and prints the result:</p> <pre><code>double\naverage_of_three (double a, double b, double c)\n{\n  return (a + b + c) / 3;\n}\n\nint\nmain (void)\n{\n    printf (\"Average is %f\\n\",\n            average_of_three (1.1, 9.8, 3.62));\n    return 0;\n}\n</code></pre> <p>From now on we will not present examples of calls to <code>main</code>. Instead we encourage you to write them for yourself when you want to test executing some code.</p> <p></p> <p>Next: Array Example Call, Previous: Float Example, Up: Beyond Integers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#42-an-example-with-arrays","title":"4.2 An Example with Arrays","text":"<p>A function to take the average of three numbers is very specific and limited. A more general function would take the average of any number of numbers. That requires passing the numbers in an array. An array is an object in memory that contains a series of values of the same data type. This chapter presents the basic concepts and use of arrays through an example; for the full explanation, see Arrays.</p> <p>Here\u2019s a function definition to take the average of several floating-point numbers, passed as type <code>double</code>. The first parameter, <code>length</code>, specifies how many numbers are passed. The second parameter, <code>input_data</code>, is an array that holds those numbers.</p> <pre><code>double\navg_of_double (int length, double input_data[])\n{\n  double sum = 0;\n  int i;\n\n  for (i = 0; i &lt; length; i++)\n    sum = sum + input_data[i];\n\n  return sum / length;\n}\n</code></pre> <p>This introduces the expression to refer to an element of an array: <code>input_data[i]</code> means the element at index <code>i</code> in <code>input_data</code>. The index of the element can be any expression with an integer value; in this case, the expression is <code>i</code>. See Accessing Array Elements.</p> <p></p> <p>The lowest valid index in an array is 0, not 1, and the highest valid index is one less than the number of elements. (This is known as zero-origin indexing.)</p> <p>This example also introduces the way to declare that a function parameter is an array. Such declarations are modeled after the syntax for an element of the array. Just as <code>double foo</code> declares that <code>foo</code> is of type <code>double</code>, <code>double input_data[]</code> declares that each element of <code>input_data</code> is of type <code>double</code>. Therefore, <code>input_data</code> itself has type \u201carray of <code>double</code>.\u201d</p> <p>When declaring an array parameter, it\u2019s not necessary to say how long the array is. In this case, the parameter <code>input_data</code> has no length information. That\u2019s why the function needs another parameter, <code>length</code>, for the caller to provide that information to the function <code>avg_of_double</code>.</p> <p></p> <p>Next: Array Example Variations, Previous: Array Example, Up: Beyond Integers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#43-calling-the-array-example","title":"4.3 Calling the Array Example","text":"<p>To call the function <code>avg_of_double</code> requires making an array and then passing it as an argument. Here is an example.</p> <pre><code>{\n  /* The array of values to average.  */\n  double nums_to_average[5];\n  /* The average, once we compute it.  */\n  double average;\n\n  /* Fill in elements of nums_to_average.  */\n\n  nums_to_average[0] = 58.7;\n  nums_to_average[1] = 5.1;\n  nums_to_average[2] = 7.7;\n  nums_to_average[3] = 105.2;\n  nums_to_average[4] = -3.14159;\n\n  average = avg_of_double (5, nums_to_average);\n\n  /* \u2026now make use of average\u2026 */\n}\n</code></pre> <p>This shows an array subscripting expression again, this time on the left side of an assignment, storing a value into an element of an array.</p> <p>It also shows how to declare a local variable that is an array: <code>double nums_to_average[5];</code>. Since this declaration allocates the space for the array, it needs to know the array\u2019s length. You can specify the length with any expression whose value is an integer, but in this declaration the length is a constant, the integer 5.</p> <p>The name of the array, when used by itself as an expression, stands for the address of the array\u2019s data, and that\u2019s what gets passed to the function <code>avg_of_double</code> in <code>avg_of_double (5, nums_to_average)</code>.</p> <p>We can make the code easier to maintain by avoiding the need to write 5, the array length, when calling <code>avg_of_double</code>. That way, if we change the array to include more elements, we won\u2019t have to change that call. One way to do this is with the <code>sizeof</code> operator:</p> <pre><code>  average = avg_of_double ((sizeof (nums_to_average)\n                            / sizeof (nums_to_average[0])),\n                           nums_to_average);\n</code></pre> <p>This computes the number of elements in <code>nums_to_average</code> by dividing its total size by the size of one element. See Type Size, for more details of using <code>sizeof</code>.</p> <p>We don\u2019t show in this example what happens after storing the result of <code>avg_of_double</code> in the variable <code>average</code>. Presumably more code would follow that uses that result somehow. (Why compute the average and not use it?) But that isn\u2019t part of this topic.</p> <p></p> <p>Previous: Array Example Call, Up: Beyond Integers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#44-variations-for-array-example","title":"4.4 Variations for Array Example","text":"<p>The code to call <code>avg_of_double</code> has two declarations that start with the same data type:</p> <pre><code>  /* The array of values to average.  */\n  double nums_to_average[5];\n  /* The average, once we compute it.  */\n  double average;\n</code></pre> <p>In C, you can combine the two, like this:</p> <pre><code>  double nums_to_average[5], average;\n</code></pre> <p>This declares <code>nums_to_average</code> so each of its elements is a <code>double</code>, and <code>average</code> so that it simply is a <code>double</code>.</p> <p>However, while you can combine them, that doesn\u2019t mean you should. If it is useful to write comments about the variables, and usually it is, then it\u2019s clearer to keep the declarations separate so you can put a comment on each one. That also helps with using textual tools to find occurrences of a variable in source files.</p> <p>We set all of the elements of the array <code>nums_to_average</code> with assignments, but it is more convenient to use an initializer in the declaration:</p> <pre><code>{\n  /* The array of values to average.  */\n  double nums_to_average[]\n    = { 58.7, 5.1, 7.7, 105.2, -3.14159 };\n\n  /* The average, once we compute it.  */\n  average = avg_of_double ((sizeof (nums_to_average)\n                            / sizeof (nums_to_average[0])),\n                           nums_to_average);\n\n  /* \u2026now make use of average\u2026 */\n}\n</code></pre> <p>The array initializer is a comma-separated list of values, delimited by braces. See Initializers.</p> <p>Note that the declaration does not specify a size for <code>nums_to_average</code>, so the size is determined from the initializer. There are five values in the initializer, so <code>nums_to_average</code> gets length 5. If we add another element to the initializer, <code>nums_to_average</code> will have six elements.</p> <p>Because the code computes the number of elements from the size of the array, using <code>sizeof</code>, the program will operate on all the elements in the initializer, regardless of how many those are.</p> <p></p> <p>Next: Arithmetic, Previous: Beyond Integers, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#5-lexical-syntax","title":"5 Lexical Syntax","text":"<p>To start the full description of the C language, we explain the lexical syntax and lexical units of C code. The lexical units of a programming language are known as tokens. This chapter covers all the tokens of C except for constants, which are covered in a later chapter (see Constants). One vital kind of token is the identifier (see Identifiers), which is used for names of any kind.</p> \u2022 English Write programs in English! \u2022 Characters The characters allowed in C programs. \u2022 Whitespace The particulars of whitespace characters. \u2022 Comments How to include comments in C code. \u2022 Identifiers How to form identifiers (names). \u2022 Operators/Punctuation Characters used as operators or punctuation. \u2022 Line Continuation Splitting one line into multiple lines. <p></p> <p>Next: Characters, Up: Lexical Syntax \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#51-write-programs-in-english","title":"5.1 Write Programs in English!","text":"<p>In principle, you can write the function and variable names in a program, and the comments, in any human language. C allows any kinds of Unicode characters in comments, and you can put them into identifiers with a special prefix (see Unicode Character Codes). However, to enable programmers in all countries to understand and develop the program, it is best under today\u2019s circumstances to write all identifiers and comments in English.</p> <p>English is the common language of programmers; in all countries, programmers generally learn English. If names and comments in a program are written in English, most programmers in Bangladesh, Belgium, Bolivia, Brazil, Bulgaria and Burundi can understand them. In all those countries, most programmers can speak English, or at least read it, but they do not read each other\u2019s languages at all. In India, with so many languages, two programmers may have no common language other than English.</p> <p>If you don\u2019t feel confident in writing English, do the best you can, and follow each English comment with a version in a language you write better; add a note asking others to translate that to English. Someone will eventually do that.</p> <p>The program\u2019s user interface is a different matter. We don\u2019t need to choose one language for that; it is easy to support multiple languages and let each user choose the language for display. This requires writing the program to support localization of its interface. (The <code>gettext</code> package exists to support this; see The GNU C Library in The GNU C Library Reference Manual.) Then a community-based translation effort can provide support for all the languages users want to use.</p> <p></p> <p>Next: Whitespace, Previous: English, Up: Lexical Syntax \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#52-characters","title":"5.2 Characters","text":"<p>GNU C source files are usually written in the ASCII character set, which was defined in the 1960s for English. However, they can also include Unicode characters represented in the UTF-8 multibyte encoding. This makes it possible to represent accented letters such as \u2018<code>\u00e1</code>\u2019, as well as other scripts such as Arabic, Chinese, Cyrillic, Hebrew, Japanese, and Korean.<sup>1</sup></p> <p>In C source code, non-ASCII characters are valid in comments, in wide character constants (see Wide Character Constants), and in string constants (see String Constants).</p> <p>Another way to specify non-ASCII characters in constants (character or string) and identifiers is with an escape sequence starting with backslash, specifying the intended Unicode character. (See Unicode Character Codes.) This specifies non-ASCII characters without putting a real non-ASCII character in the source file itself.</p> <p>C accepts two-character aliases called digraphs for certain characters. See Digraphs.</p> <p></p> <p>Next: Comments, Previous: Characters, Up: Lexical Syntax \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#53-whitespace","title":"5.3 Whitespace","text":"<p>Whitespace means characters that exist in a file but appear blank in a printed listing of a file (or traditionally did appear blank, several decades ago). The C language requires whitespace in order to separate two consecutive identifiers, or to separate an identifier from a numeric constant. Other than that, and a few special situations described later, whitespace is optional; you can put it in when you wish, to make the code easier to read.</p> <p>Space and tab in C code are treated as whitespace characters. So are line breaks. You can represent a line break with the newline character (also called linefeed or LF), CR (carriage return), or the CRLF sequence (two characters: carriage return followed by a newline character).</p> <p>The formfeed character, Control-L, was traditionally used to divide a file into pages. It is still used this way in source code, and the tools that generate nice printouts of source code still start a new page after each \u201cformfeed\u201d character. Dividing code into pages separated by formfeed characters is a good way to break it up into comprehensible pieces and show other programmers where they start and end.</p> <p>The vertical tab character, Control-K, was traditionally used to make printing advance down to the next section of a page. We know of no particular reason to use it in source code, but it is still accepted as whitespace in C.</p> <p>Comments are also syntactically equivalent to whitespace.</p> <p></p> <p>Next: Identifiers, Previous: Whitespace, Up: Lexical Syntax \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#54-comments","title":"5.4 Comments","text":"<p>A comment encapsulates text that has no effect on the program\u2019s execution or meaning.</p> <p>The purpose of comments is to explain the code to people that read it. Writing good comments for your code is tremendously important\u2014they should provide background information that helps programmers understand the reasons why the code is written the way it is. You, returning to the code six months from now, will need the help of these comments to remember why you wrote it this way.</p> <p>Outdated comments that become incorrect are counterproductive, so part of the software developer\u2019s responsibility is to update comments as needed to correspond with changes to the program code.</p> <p>C allows two kinds of comment syntax, the traditional style and the C<code>++</code> style. A traditional C comment starts with \u2018<code>/*</code>\u2019 and ends with \u2018<code>*/</code>\u2019. For instance,</p> <pre><code>/* This is a comment in traditional C syntax. */\n</code></pre> <p>A traditional comment can contain \u2018<code>/*</code>\u2019, but these delimiters do not nest as pairs. The first \u2018<code>*/</code>\u2019 ends the comment regardless of whether it contains \u2018<code>/*</code>\u2019 sequences.</p> <pre><code>/* This /* is a comment */ But this is not! */\n</code></pre> <p>A line comment starts with \u2018<code>//</code>\u2019 and ends at the end of the line. For instance,</p> <pre><code>// This is a comment in C++ style.\n</code></pre> <p>Line comments do nest, in effect, because \u2018<code>//</code>\u2019 inside a line comment is part of that comment:</p> <pre><code>// this whole line is // one comment\nThis is code, not comment.\n</code></pre> <p>It is safe to put line comments inside block comments, or vice versa.</p> <pre><code>/* traditional comment\n   // contains line comment\n   more traditional comment\n */ text here is not a comment\n\n// line comment /* contains traditional comment */\n</code></pre> <p>But beware of commenting out one end of a traditional comment with a line comment. The delimiter \u2018<code>/*</code>\u2019 doesn\u2019t start a comment if it occurs inside an already-started comment.</p> <pre><code> // line comment  /* That would ordinarily begin a block comment.\n    Oops! The line comment has ended;\n    this isn't a comment any more.  */\n</code></pre> <p>Comments are not recognized within string constants. <code>\"/*\u00a0blah\u00a0*/\"</code> is the string constant \u2018<code>/*\u00a0blah\u00a0*/</code>\u2019, not an empty string.</p> <p>In this manual we show the text in comments in a variable-width font, for readability, but this font distinction does not exist in source files.</p> <p>A comment is syntactically equivalent to whitespace, so it always separates tokens. Thus,</p> <pre><code>  int/* comment */foo;\nis equivalent to\n  int foo;\n</code></pre> <p>but clean code always uses real whitespace to separate the comment visually from surrounding code.</p> <p></p> <p>Next: Operators/Punctuation, Previous: Comments, Up: Lexical Syntax \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#55-identifiers","title":"5.5 Identifiers","text":"<p>An identifier (name) in C is a sequence of letters and digits, as well as \u2018<code>_</code>\u2019, that does not start with a digit. Most compilers also allow \u2018<code>$</code>\u2019. An identifier can be as long as you like; for example,</p> <pre><code>int anti_dis_establishment_arian_ism;\n</code></pre> <p></p> <p>Letters in identifiers are case-sensitive in C; thus, <code>a</code> and <code>A</code> are two different identifiers.</p> <p> </p> <p>Identifiers in C are used as variable names, function names, typedef names, enumeration constants, type tags, field names, and labels. Certain identifiers in C are keywords, which means they have specific syntactic meanings. Keywords in C are reserved words, meaning you cannot use them in any other way. For instance, you can\u2019t define a variable or function named <code>return</code> or <code>if</code>.</p> <p>You can also include other characters, even non-ASCII characters, in identifiers by writing their Unicode character names, which start with \u2018<code>\\u</code>\u2019 or \u2018<code>\\U</code>\u2019, in the identifier name. See Unicode Character Codes. However, it is usually a bad idea to use non-ASCII characters in identifiers, and when the names are written in English, they never need non-ASCII characters. See English.</p> <p>As stated above, whitespace is required to separate two consecutive identifiers, or to separate an identifier from a preceding or following numeric constant.</p> <p></p> <p>Next: Line Continuation, Previous: Identifiers, Up: Lexical Syntax \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#56-operators-and-punctuation","title":"5.6 Operators and Punctuation","text":"<p>Here we describe the lexical syntax of operators and punctuation in C. The specific operators of C and their meanings are presented in subsequent chapters.</p> <p>Most operators in C consist of one or two characters that can\u2019t be used in identifiers. The characters used for operators in C are \u2018<code>!~^&amp;|*/%+-=&lt;&gt;,.?:</code>\u2019.</p> <p>Some operators are a single character. For instance, \u2018<code>-</code>\u2019 is the operator for negation (with one operand) and the operator for subtraction (with two operands).</p> <p>Some operators are two characters. For example, \u2018<code>++</code>\u2019 is the increment operator. Recognition of multicharacter operators works by grouping together as many consecutive characters as can constitute one operator.</p> <p>For instance, the character sequence \u2018<code>++</code>\u2019 is always interpreted as the increment operator; therefore, if we want to write two consecutive instances of the operator \u2018<code>+</code>\u2019, we must separate them with a space so that they do not combine as one token. Applying the same rule, <code>a+++++b</code> is always tokenized as <code>a++\u00a0++\u00a0+\u00a0b</code>, not as <code>a++\u00a0+\u00a0++b</code>, even though the latter could be part of a valid C program and the former could not (since <code>a++</code> is not an lvalue and thus can\u2019t be the operand of <code>++</code>).</p> <p>A few C operators are keywords rather than special characters. They include <code>sizeof</code> (see Type Size) and <code>_Alignof</code> (see Type Alignment).</p> <p>The characters \u2018<code>;{}[]()</code>\u2019 are used for punctuation and grouping. Semicolon (\u2018<code>;</code>\u2019) ends a statement. Braces (\u2018<code>{</code>\u2019 and \u2018<code>}</code>\u2019) begin and end a block at the statement level (see Blocks), and surround the initializer (see Initializers) for a variable with multiple elements or fields (such as arrays or structures).</p> <p>Square brackets (\u2018<code>[</code>\u2019 and \u2018<code>]</code>\u2019) do array indexing, as in <code>array[5]</code>.</p> <p>Parentheses are used in expressions for explicit nesting of expressions (see Basic Arithmetic), around the parameter declarations in a function declaration or definition, and around the arguments in a function call, as in <code>printf (\"Foo %d\\n\", i)</code> (see Function Calls). Several kinds of statements also use parentheses as part of their syntax\u2014for instance, <code>if</code> statements, <code>for</code> statements, <code>while</code> statements, and <code>switch</code> statements. See if Statement, and following sections.</p> <p>Parentheses are also required around the operand of the operator keywords <code>sizeof</code> and <code>_Alignof</code> when the operand is a data type rather than a value. See Type Size.</p> <p></p> <p>Previous: Operators/Punctuation, Up: Lexical Syntax \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#57-line-continuation","title":"5.7 Line Continuation","text":"<p>The sequence of a backslash and a newline is ignored absolutely anywhere in a C program. This makes it possible to split a single source line into multiple lines in the source file. GNU C tolerates and ignores other whitespace between the backslash and the newline. In particular, it always ignores a CR (carriage return) character there, in case some text editor decided to end the line with the CRLF sequence.</p> <p>The main use of line continuation in C is for macro definitions that would be inconveniently long for a single line (see Macros).</p> <p>It is possible to continue a line comment onto another line with backslash-newline. You can put backslash-newline in the middle of an identifier, even a keyword, or an operator. You can even split \u2018<code>/*</code>\u2019, \u2018<code>*/</code>\u2019, and \u2018<code>//</code>\u2019 onto multiple lines with backslash-newline. Here\u2019s an ugly example:</p> <pre><code>/\\\n*\n*/ fo\\\no +\\\n= 1\\\n0;\n</code></pre> <p>That\u2019s equivalent to \u2018<code>/* */ foo += 10;</code>\u2019.</p> <p>Don\u2019t do those things in real programs, since they make code hard to read.</p> <p>Note: For the sake of using certain tools on the source code, it is wise to end every source file with a newline character which is not preceded by a backslash, so that it really ends the last line.</p> <p></p> <p>Next: Assignment Expressions, Previous: Lexical Syntax, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#6-arithmetic","title":"6 Arithmetic","text":"<p>Arithmetic operators in C attempt to be as similar as possible to the abstract arithmetic operations, but it is impossible to do this perfectly. Numbers in a computer have a finite range of possible values, and non-integer values have a limit on their possible accuracy. Nonetheless, except when results are out of range, you will encounter no surprises in using \u2018<code>+</code>\u2019 for addition, \u2018<code>-</code>\u2019 for subtraction, and \u2018<code>*</code>\u2019 for multiplication.</p> <p>Each C operator has a precedence, which is its rank in the grammatical order of the various operators. The operators with the highest precedence grab adjoining operands first; these expressions then become operands for operators of lower precedence. We give some information about precedence of operators in this chapter where we describe the operators; for the full explanation, see Binary Operator Grammar.</p> <p>The arithmetic operators always promote their operands before operating on them. This means converting narrow integer data types to a wider data type (see Operand Promotions). If you are just learning C, don\u2019t worry about this yet.</p> <p>Given two operands that have different types, most arithmetic operations convert them both to their common type. For instance, if one is <code>int</code> and the other is <code>double</code>, the common type is <code>double</code>. (That\u2019s because <code>double</code> can represent all the values that an <code>int</code> can hold, but not vice versa.) For the full details, see Common Type.</p> \u2022 Basic Arithmetic Addition, subtraction, multiplication, and division. \u2022 Integer Arithmetic How C performs arithmetic with integer values. \u2022 Integer Overflow When an integer value exceeds the range of its type. \u2022 Mixed Mode Calculating with both integer values and floating-point values. \u2022 Division and Remainder How integer division works. \u2022 Numeric Comparisons Comparing numeric values for equality or order. \u2022 Shift Operations Shift integer bits left or right. \u2022 Bitwise Operations Bitwise conjunction, disjunction, negation. <p></p> <p>Next: Integer Arithmetic, Up: Arithmetic \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#61-basic-arithmetic","title":"6.1 Basic Arithmetic","text":"<p>Basic arithmetic in C is done with the usual binary operators of algebra: addition (\u2018<code>+</code>\u2019), subtraction (\u2018<code>-</code>\u2019), multiplication (\u2018<code>*</code>\u2019) and division (\u2018<code>/</code>\u2019). The unary operator \u2018<code>-</code>\u2019 is used to change the sign of a number. The unary <code>+</code> operator also exists; it yields its operand unaltered.</p> <p>\u2018<code>/</code>\u2019 is the division operator, but dividing integers may not give the result you expect. Its value is an integer, which is not equal to the mathematical quotient when that is a fraction. Use \u2018<code>%</code>\u2019 to get the corresponding integer remainder when necessary. See Division and Remainder. Floating point division yields value as close as possible to the mathematical quotient.</p> <p>These operators use algebraic syntax with the usual algebraic precedence rule (see Binary Operator Grammar) that multiplication and division are done before addition and subtraction, but you can use parentheses to explicitly specify how the operators nest. They are left-associative (see Associativity and Ordering). Thus,</p> <pre><code>-a + b - c + d * e / f\n</code></pre> <p>is equivalent to</p> <pre><code>(((-a) + b) - c) + ((d * e) / f)\n</code></pre> <p></p> <p>Next: Integer Overflow, Previous: Basic Arithmetic, Up: Arithmetic \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#62-integer-arithmetic","title":"6.2 Integer Arithmetic","text":"<p>Each of the basic arithmetic operations in C has two variants for integers: signed and unsigned. The choice is determined by the data types of their operands.</p> <p>Each integer data type in C is either signed or unsigned. A signed type can hold a range of positive and negative numbers, with zero near the middle of the range. An unsigned type can hold only nonnegative numbers; its range starts with zero and runs upward.</p> <p>The most basic integer types are <code>int</code>, which normally can hold numbers from -2,147,483,648 to 2,147,483,647, and <code>unsigned int</code>, which normally can hold numbers from 0 to 4,294,967,295. (This assumes <code>int</code> is 32 bits wide, always true for GNU C on real computers but not always on embedded controllers.) See Integer Types, for full information about integer types.</p> <p>When a basic arithmetic operation is given two signed operands, it does signed arithmetic. Given two unsigned operands, it does unsigned arithmetic.</p> <p>If one operand is <code>unsigned int</code> and the other is <code>int</code>, the operator treats them both as unsigned. More generally, the common type of the operands determines whether the operation is signed or not. See Common Type.</p> <p>Printing the results of unsigned arithmetic with <code>printf</code> using \u2018<code>%d</code>\u2019 can produce surprising results for values far away from zero. Even though the rules above say that the computation was done with unsigned arithmetic, the printed result may appear to be signed!</p> <p>The explanation is that the bit pattern resulting from addition, subtraction or multiplication is actually the same for signed and unsigned operations. The difference is only in the data type of the result, which affects the interpretation of the result bit pattern, and whether the arithmetic operation can overflow (see the next section).</p> <p>But \u2018<code>%d</code>\u2019 doesn\u2019t know its argument\u2019s data type. It sees only the value\u2019s bit pattern, and it is defined to interpret that as <code>signed int</code>. To print it as unsigned requires using \u2018<code>%u</code>\u2019 instead of \u2018<code>%d</code>\u2019. See The GNU C Library in The GNU C Library Reference Manual.</p> <p>Arithmetic in C never operates directly on narrow integer types (those with fewer bits than <code>int</code>; Narrow Integers). Instead it \u201cpromotes\u201d them to <code>int</code>. See Operand Promotions.</p> <p></p> <p>Next: Mixed Mode, Previous: Integer Arithmetic, Up: Arithmetic \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#63-integer-overflow","title":"6.3 Integer Overflow","text":"<p>When the mathematical value of an arithmetic operation doesn\u2019t fit in the range of the data type in use, that\u2019s called overflow. When it happens in integer arithmetic, it is integer overflow.</p> <p>Integer overflow happens only in arithmetic operations. Type conversion operations, by definition, do not cause overflow, not even when the result can\u2019t fit in its new type. See Integer Conversion.</p> <p>Signed numbers use two\u2019s-complement representation, in which the most negative number lacks a positive counterpart (see Integers in Depth). Thus, the unary \u2018<code>-</code>\u2019 operator on a signed integer can overflow.</p> \u2022 Unsigned Overflow Overflow in unsigned integer arithmetic. \u2022 Signed Overflow Overflow in signed integer arithmetic. <p></p> <p>Next: Signed Overflow, Up: Integer Overflow \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#631-overflow-with-unsigned-integers","title":"6.3.1 Overflow with Unsigned Integers","text":"<p>Unsigned arithmetic in C ignores overflow; it produces the true result modulo the <code>n</code>th power of 2, where <code>n</code> is the number of bits in the data type. We say it \u201ctruncates\u201d the true result to the lowest <code>n</code> bits.</p> <p>A true result that is negative, when taken modulo the <code>n</code>th power of 2, yields a positive number. For instance,</p> <pre><code>unsigned int x = 1;\nunsigned int y;\n\ny = -x;\n</code></pre> <p>causes overflow because the negative number -1 can\u2019t be stored in an unsigned type. The actual result, which is -1 modulo the <code>n</code>th power of 2, is one less than the <code>n</code>th power of 2. That is the largest value that the unsigned data type can store. For a 32-bit <code>unsigned int</code>, the value is 4,294,967,295. See Maximum and Minimum Values.</p> <p>Adding that number to itself, as here,</p> <pre><code>unsigned int z;\n\nz = y + y;\n</code></pre> <p>ought to yield 8,489,934,590; however, that is again too large to fit, so overflow truncates the value to 4,294,967,294. If that were a signed integer, it would mean -2, which (not by coincidence) equals -1 + -1.</p> <p></p> <p>Previous: Unsigned Overflow, Up: Integer Overflow \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#632-overflow-with-signed-integers","title":"6.3.2 Overflow with Signed Integers","text":"<p>For signed integers, the result of overflow in C is in principle undefined, meaning that anything whatsoever could happen. Therefore, C compilers can do optimizations that treat the overflow case with total unconcern. (Since the result of overflow is undefined in principle, one cannot claim that these optimizations are erroneous.)</p> <p>Watch out: These optimizations can do surprising things. For instance,</p> <pre><code>int i;\n\u2026\nif (i &lt; i + 1)\n  x = 5;\n</code></pre> <p>could be optimized to do the assignment unconditionally, because the <code>if</code>-condition is always true if <code>i + 1</code> does not overflow.</p> <p>GCC offers compiler options to control handling signed integer overflow. These options operate per module; that is, each module behaves according to the options it was compiled with.</p> <p>These two options specify particular ways to handle signed integer overflow, other than the default way:</p> <p><code>-fwrapv</code> Make signed integer operations well-defined, like unsigned integer operations: they produce the <code>n</code> low-order bits of the true result. The highest of those <code>n</code> bits is the sign bit of the result. With <code>-fwrapv</code>, these out-of-range operations are not considered overflow, so (strictly speaking) integer overflow never happens.</p> <p>The option <code>-fwrapv</code> enables some optimizations based on the defined values of out-of-range results. In GCC 8, it disables optimizations that are based on assuming signed integer operations will not overflow.</p> <p><code>-ftrapv</code> Generate a signal <code>SIGFPE</code> when signed integer overflow occurs. This terminates the program unless the program handles the signal. See Signals.</p> <p>One other option is useful for finding where overflow occurs:</p> <p><code>-fsanitize=signed-integer-overflow</code> Output a warning message at run time when signed integer overflow occurs. This checks the \u2018<code>+</code>\u2019, \u2018<code>*</code>\u2019, and \u2018<code>-</code>\u2019 operators. This takes priority over <code>-ftrapv</code>.</p> <p></p> <p>Next: Division and Remainder, Previous: Integer Overflow, Up: Arithmetic \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#64-mixed-mode-arithmetic","title":"6.4 Mixed-Mode Arithmetic","text":"<p>Mixing integers and floating-point numbers in a basic arithmetic operation converts the integers automatically to floating point. In most cases, this gives exactly the desired results. But sometimes it matters precisely where the conversion occurs.</p> <p>If <code>i</code> and <code>j</code> are integers, <code>(i + j) * 2.0</code> adds them as an integer, then converts the sum to floating point for the multiplication. If the addition causes an overflow, that is not equivalent to converting each integer to floating point and then adding the two floating point numbers. You can get the latter result by explicitly converting the integers, as in <code>((double) i + (double) j) * 2.0</code>. See Explicit Type Conversion.</p> <p>Adding or multiplying several values, including some integers and some floating point, performs the operations left to right. Thus, <code>3.0 + i + j</code> converts <code>i</code> to floating point, then adds 3.0, then converts <code>j</code> to floating point and adds that. You can specify a different order using parentheses: <code>3.0 + (i + j)</code> adds <code>i</code> and <code>j</code> first and then adds that sum (converted to floating point) to 3.0. In this respect, C differs from other languages, such as Fortran.</p> <p></p> <p>Next: Numeric Comparisons, Previous: Mixed Mode, Up: Arithmetic \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#65-division-and-remainder","title":"6.5 Division and Remainder","text":"<p>Division of integers in C rounds the result to an integer. The result is always rounded towards zero.</p> <pre><code> 16 / 3  \u21d2 5\n-16 / 3  \u21d2 -5\n 16 / -3 \u21d2 -5\n-16 / -3 \u21d2 5\n</code></pre> <p>To get the corresponding remainder, use the \u2018<code>%</code>\u2019 operator:</p> <pre><code> 16 % 3  \u21d2 1\n-16 % 3  \u21d2 -1\n 16 % -3 \u21d2 1\n-16 % -3 \u21d2 -1\n</code></pre> <p>\u2018<code>%</code>\u2019 has the same operator precedence as \u2018<code>/</code>\u2019 and \u2018<code>*</code>\u2019.</p> <p>From the rounded quotient and the remainder, you can reconstruct the dividend, like this:</p> <pre><code>int\noriginal_dividend (int divisor, int quotient, int remainder)\n{\n  return divisor * quotient + remainder;\n}\n</code></pre> <p>To do unrounded division, use floating point. If only one operand is floating point, \u2018<code>/</code>\u2019 converts the other operand to floating point.</p> <pre><code>16.0 / 3   \u21d2 5.333333333333333\n16   / 3.0 \u21d2 5.333333333333333\n16.0 / 3.0 \u21d2 5.333333333333333\n16   / 3   \u21d2 5\n</code></pre> <p>The remainder operator \u2018<code>%</code>\u2019 is not allowed for floating-point operands, because it is not needed. The concept of remainder makes sense for integers because the result of division of integers has to be an integer. For floating point, the result of division is a floating-point number, in other words a fraction, which will differ from the exact result only by a very small amount.</p> <p>There are functions in the standard C library to calculate remainders from integral-values division of floating-point numbers. See The GNU C Library in The GNU C Library Reference Manual.</p> <p>Integer division overflows in one specific case: dividing the smallest negative value for the data type (see Maximum and Minimum Values) by -1. That\u2019s because the correct result, which is the corresponding positive number, does not fit (see Integer Overflow) in the same number of bits. On some computers now in use, this always causes a signal <code>SIGFPE</code> (see Signals), the same behavior that the option <code>-ftrapv</code> specifies (see Signed Overflow).</p> <p>Division by zero leads to unpredictable results\u2014depending on the type of computer, it might cause a signal <code>SIGFPE</code>, or it might produce a numeric result.</p> <p> </p> <p>Watch out: Make sure the program does not divide by zero. If you can\u2019t prove that the divisor is not zero, test whether it is zero, and skip the division if so.</p> <p></p> <p>Next: Shift Operations, Previous: Division and Remainder, Up: Arithmetic \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#66-numeric-comparisons","title":"6.6 Numeric Comparisons","text":"<p>There are two kinds of comparison operators: equality and ordering. Equality comparisons test whether two expressions have the same value. The result is a truth value: a number that is 1 for \u201ctrue\u201d and 0 for \u201cfalse.\u201d</p> <pre><code>a == b   /* Test for equal.  */\na != b   /* Test for not equal.  */\n</code></pre> <p>The equality comparison is written <code>==</code> because plain <code>=</code> is the assignment operator.</p> <p>Ordering comparisons test which operand is greater or less. Their results are truth values. These are the ordering comparisons of C:</p> <pre><code>a &lt; b   /* Test for less-than.  */\na &gt; b   /* Test for greater-than.  */\na &lt;= b  /* Test for less-than-or-equal.  */\na &gt;= b  /* Test for greater-than-or-equal.  */\n</code></pre> <p>For any integers <code>a</code> and <code>b</code>, exactly one of the comparisons <code>a &lt; b</code>, <code>a == b</code> and <code>a &gt; b</code> is true, just as in mathematics. However, if <code>a</code> and <code>b</code> are special floating point values (not ordinary numbers), all three can be false. See Special Float Values, and Invalid Optimizations.</p> <p></p> <p>Next: Bitwise Operations, Previous: Numeric Comparisons, Up: Arithmetic \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#67-shift-operations","title":"6.7 Shift Operations","text":"<p>Shifting an integer means moving the bit values to the left or right within the bits of the data type. Shifting is defined only for integers. Here\u2019s the way to write it:</p> <pre><code>/* Left shift.  */\n5 &lt;&lt; 2 \u21d2 20\n\n/* Right shift.  */\n5 &gt;&gt; 2 \u21d2 1\n</code></pre> <p>The left operand is the value to be shifted, and the right operand says how many bits to shift it (the shift count). The left operand is promoted (see Operand Promotions), so shifting never operates on a narrow integer type; it\u2019s always either <code>int</code> or wider. The result of the shift operation has the same type as the promoted left operand.</p> \u2022 Bits Shifted In How shifting makes new bits to shift in. \u2022 Shift Caveats Caveats of shift operations. \u2022 Shift Hacks Clever tricks with shift operations. <p></p> <p>Next: Shift Caveats, Up: Shift Operations \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#671-shifting-makes-new-bits","title":"6.7.1 Shifting Makes New Bits","text":"<p>A shift operation shifts towards one end of the number and has to generate new bits at the other end.</p> <p>Shifting left one bit must generate a new least significant bit. It always brings in zero there. It is equivalent to multiplying by the appropriate power of 2. For example,</p> <pre><code>5 &lt;&lt; 3     is equivalent to   5 * 2*2*2\n-10 &lt;&lt; 4   is equivalent to   -10 * 2*2*2*2\n</code></pre> <p>The meaning of shifting right depends on whether the data type is signed or unsigned (see Signed and Unsigned Types). For a signed data type, it performs \u201carithmetic shift,\u201d which keeps the number\u2019s sign unchanged by duplicating the sign bit. For an unsigned data type, it performs \u201clogical shift,\u201d which always shifts in zeros at the most significant bit.</p> <p>In both cases, shifting right one bit is division by two, rounding towards negative infinity. For example,</p> <pre><code>(unsigned) 19 &gt;&gt; 2 \u21d2 4\n(unsigned) 20 &gt;&gt; 2 \u21d2 5\n(unsigned) 21 &gt;&gt; 2 \u21d2 5\n</code></pre> <p>For negative left operand <code>a</code>, <code>a &gt;&gt; 1</code> is not equivalent to <code>a / 2</code>. They both divide by 2, but \u2018<code>/</code>\u2019 rounds toward zero.</p> <p>The shift count must be zero or greater. Shifting by a negative number of bits gives machine-dependent results.</p> <p></p> <p>Next: Shift Hacks, Previous: Bits Shifted In, Up: Shift Operations \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#672-caveats-for-shift-operations","title":"6.7.2 Caveats for Shift Operations","text":"<p>Warning: If the shift count is greater than or equal to the width in bits of the promoted first operand, the results are machine-dependent. Logically speaking, the \u201ccorrect\u201d value would be either -1 (for right shift of a negative number) or 0 (in all other cases), but the actual result is whatever the machine\u2019s shift instruction does in that case. So unless you can prove that the second operand is not too large, write code to check it at run time.</p> <p>Warning: Never rely on how the shift operators relate in precedence to other arithmetic binary operators. Programmers don\u2019t remember these precedences, and won\u2019t understand the code. Always use parentheses to explicitly specify the nesting, like this:</p> <pre><code>a + (b &lt;&lt; 5)   /* Shift first, then add.  */\n(a + b) &lt;&lt; 5   /* Add first, then shift.  */\n</code></pre> <p>Note: according to the C standard, shifting of signed values isn\u2019t guaranteed to work properly when the value shifted is negative, or becomes negative during the operation of shifting left. However, only pedants have a reason to be concerned about this; only computers with strange shift instructions could plausibly do this wrong. In GNU C, the operation always works as expected,</p> <p></p> <p>Previous: Shift Caveats, Up: Shift Operations \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#673-shift-hacks","title":"6.7.3 Shift Hacks","text":"<p>You can use the shift operators for various useful hacks. For example, given a date specified by day of the month <code>d</code>, month <code>m</code>, and year <code>y</code>, you can store the entire date in a single integer <code>date</code>:</p> <pre><code>unsigned int d = 12;       /* 12 in binary is 0b1100.  */\nunsigned int m = 6;             /* 6 in binary is 0b110.  */\nunsigned int y = 1983;          /* 1983 in binary is 0b11110111111.  */\nunsigned int date = (((y &lt;&lt; 4) + m) &lt;&lt; 5) + d;\n                                /* Add 0b11110111111000000000\n                                   and 0b11000000 and 0b1100.\n                                   Sum is 0b11110111111011001100.  */\n</code></pre> <p>To extract the day, month, and year out of <code>date</code>, use a combination of shift and remainder:</p> <pre><code>/* 32 in binary is 0b100000.  */\n/* Remainder dividing by 32 gives lowest 5 bits, 0b1100.  */\nd = date % 32;\n/* Shifting 5 bits right discards the day, leaving 0b111101111110110.\n   Remainder dividing by 16 gives lowest remaining 4 bits, 0b110.  */\nm = (date &gt;&gt; 5) % 16;\n/* Shifting 9 bits right discards day and month,\n   leaving 0b111101111110.  */\ny = date &gt;&gt; 9;\n</code></pre> <p><code>-1 &lt;&lt; LOWBITS</code> is a clever way to make an integer whose <code>LOWBITS</code> lowest bits are all 0 and the rest are all 1. <code>-(1 &lt;&lt; LOWBITS)</code> is equivalent to that, due to associativity of multiplication, since negating a value is equivalent to multiplying it by -1.</p> <p></p> <p>Previous: Shift Operations, Up: Arithmetic \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#68-bitwise-operations","title":"6.8 Bitwise Operations","text":"<p>Bitwise operators operate on integers, treating each bit independently. They are not allowed for floating-point types.</p> <p>The examples in this section use binary constants, starting with \u2018<code>0b</code>\u2019 (see Integer Constants). They stand for 32-bit integers of type <code>int</code>.</p> <p><code>~``a</code> Unary operator for bitwise negation; this changes each bit of <code>a</code> from 1 to 0 or from 0 to 1.</p> <pre><code>~0b10101000 \u21d2 0b11111111111111111111111101010111\n~0 \u21d2 0b11111111111111111111111111111111\n~0b11111111111111111111111111111111 \u21d2 0\n~ (-1) \u21d2 0\n</code></pre> <p>It is useful to remember that <code>~``x`` + 1</code> equals <code>-``x</code>, for integers, and <code>~``x</code> equals <code>-``x`` - 1</code>. The last example above shows this with -1 as <code>x</code>.</p> <p><code>a`` &amp; ``b</code> Binary operator for bitwise \u201cand\u201d or \u201cconjunction.\u201d Each bit in the result is 1 if that bit is 1 in both <code>a</code> and <code>b</code>.</p> <pre><code>0b10101010 &amp; 0b11001100 \u21d2 0b10001000\n</code></pre> <p><code>a`` | ``b</code> Binary operator for bitwise \u201cor\u201d (\u201cinclusive or\u201d or \u201cdisjunction\u201d). Each bit in the result is 1 if that bit is 1 in either <code>a</code> or <code>b</code>.</p> <pre><code>0b10101010 | 0b11001100 \u21d2 0b11101110\n</code></pre> <p><code>a`` ^ ``b</code> Binary operator for bitwise \u201cxor\u201d (\u201cexclusive or\u201d). Each bit in the result is 1 if that bit is 1 in exactly one of <code>a</code> and <code>b</code>.</p> <pre><code>0b10101010 ^ 0b11001100 \u21d2 0b01100110\n</code></pre> <p>To understand the effect of these operators on signed integers, keep in mind that all modern computers use two\u2019s-complement representation (see Integer Representations) for negative integers. This means that the highest bit of the number indicates the sign; it is 1 for a negative number and 0 for a positive number. In a negative number, the value in the other bits increases as the number gets closer to zero, so that <code>0b111</code><code>\u2026</code><code>111</code> is -1 and <code>0b100</code><code>\u2026</code><code>000</code> is the most negative possible integer.</p> <p>Warning: C defines a precedence ordering for the bitwise binary operators, but you should never rely on it. You should never rely on how bitwise binary operators relate in precedence to the arithmetic and shift binary operators. Other programmers don\u2019t remember this precedence ordering, so always use parentheses to explicitly specify the nesting.</p> <p>For example, suppose <code>offset</code> is an integer that specifies the offset within shared memory of a table, except that its bottom few bits (<code>LOWBITS</code> says how many) are special flags. Here\u2019s how to get just that offset and add it to the base address.</p> <pre><code>shared_mem_base + (offset &amp; (-1 &lt;&lt; LOWBITS))\n</code></pre> <p>Thanks to the outer set of parentheses, we don\u2019t need to know whether \u2018<code>&amp;</code>\u2019 has higher precedence than \u2018<code>+</code>\u2019. Thanks to the inner set, we don\u2019t need to know whether \u2018<code>&amp;</code>\u2019 has higher precedence than \u2018<code>&lt;&lt;</code>\u2019. But we can rely on all unary operators to have higher precedence than any binary operator, so we don\u2019t need parentheses around the left operand of \u2018<code>&lt;&lt;</code>\u2019.</p> <p></p> <p>Next: Execution Control Expressions, Previous: Arithmetic, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#7-assignment-expressions","title":"7 Assignment Expressions","text":"<p>As a general concept in programming, an assignment is a construct that stores a new value into a place where values can be stored\u2014for instance, in a variable. Such places are called lvalues (see Lvalues) because they are locations that hold a value.</p> <p>An assignment in C is an expression because it has a value; we call it an assignment expression. A simple assignment looks like</p> <pre><code>lvalue = value-to-store\n</code></pre> <p>We say it assigns the value of the expression <code>value-to-store</code> to the location <code>lvalue</code>, or that it stores <code>value-to-store</code> there. You can think of the \u201cl\u201d in \u201clvalue\u201d as standing for \u201cleft,\u201d since that\u2019s what you put on the left side of the assignment operator.</p> <p>However, that\u2019s not the only way to use an lvalue, and not all lvalues can be assigned to. To use the lvalue in the left side of an assignment, it has to be modifiable. In C, that means it was not declared with the type qualifier <code>const</code> (see const).</p> <p>The value of the assignment expression is that of <code>lvalue</code> after the new value is stored in it. This means you can use an assignment inside other expressions. Assignment operators are right-associative so that</p> <pre><code>x = y = z = 0;\n</code></pre> <p>is equivalent to</p> <pre><code>x = (y = (z = 0));\n</code></pre> <p>This is the only useful way for them to associate; the other way,</p> <pre><code>((x = y) = z) = 0;\n</code></pre> <p>would be invalid since an assignment expression such as <code>x = y</code> is not valid as an lvalue.</p> <p>Warning: Write parentheses around an assignment if you nest it inside another expression, unless that is a conditional expression, or comma-separated series, or another assignment.</p> \u2022 Simple Assignment The basics of storing a value. \u2022 Lvalues Expressions into which a value can be stored. \u2022 Modifying Assignment Shorthand for changing an lvalue\u2019s contents. \u2022 Increment/Decrement Shorthand for incrementing and decrementing an lvalue\u2019s contents. \u2022 Postincrement/Postdecrement Accessing then incrementing or decrementing. \u2022 Assignment in Subexpressions How to avoid ambiguity. \u2022 Write Assignments Separately Write assignments as separate statements. <p></p> <p>Next: Lvalues, Up: Assignment Expressions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#71-simple-assignment","title":"7.1 Simple Assignment","text":"<p>A simple assignment expression computes the value of the right operand and stores it into the lvalue on the left. Here is a simple assignment expression that stores 5 in <code>i</code>:</p> <pre><code>i = 5\n</code></pre> <p>We say that this is an assignment to the variable <code>i</code> and that it assigns <code>i</code> the value 5. It has no semicolon because it is an expression (so it has a value). Adding a semicolon at the end would make it a statement (see Expression Statement).</p> <p>Here is another example of a simple assignment expression. Its operands are not simple, but the kind of assignment done here is simple assignment.</p> <pre><code>x[foo ()] = y + 6\n</code></pre> <p>A simple assignment with two different numeric data types converts the right operand value to the lvalue\u2019s type, if possible. It can convert any numeric type to any other numeric type.</p> <p>Simple assignment is also allowed on some non-numeric types: pointers (see Pointers), structures (see Structure Assignment), and unions (see Unions).</p> <p>Warning: Assignment is not allowed on arrays because there are no array values in C; C variables can be arrays, but these arrays cannot be manipulated as wholes. See Limitations of C Arrays.</p> <p>See Assignment Type Conversions, for the complete rules about data types used in assignments.</p> <p></p> <p>Next: Modifying Assignment, Previous: Simple Assignment, Up: Assignment Expressions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#72-lvalues","title":"7.2 Lvalues","text":"<p>An expression that identifies a memory space that holds a value is called an lvalue, because it is a location that can hold a value.</p> <p>The standard kinds of lvalues are:</p> <ul> <li>A variable.</li> <li>A pointer-dereference expression (see Pointer     Dereference) using unary \u2018<code>*</code>\u2019.</li> <li>A structure field reference (see Structures) using     \u2018<code>.</code>\u2019, if the structure value is an lvalue.</li> <li>A structure field reference using \u2018<code>-&gt;</code>\u2019. This is always an lvalue     since \u2018<code>-&gt;</code>\u2019 implies pointer dereference.</li> <li>A union alternative reference (see Unions), on the same     conditions as for structure fields.</li> <li>An array-element reference using     \u2018<code>[</code><code>\u2026</code><code>]</code>\u2019, if the array is an lvalue.</li> </ul> <p>If an expression\u2019s outermost operation is any other operator, that expression is not an lvalue. Thus, the variable <code>x</code> is an lvalue, but <code>x + 0</code> is not, even though these two expressions compute the same value (assuming <code>x</code> is a number).</p> <p>An array can be an lvalue (the rules above determine whether it is one), but using the array in an expression converts it automatically to a pointer to the zeroth element. The result of this conversion is not an lvalue. Thus, if the variable <code>a</code> is an array, you can\u2019t use <code>a</code> by itself as the left operand of an assignment. But you can assign to an element of <code>a</code>, such as <code>a[0]</code>. That is an lvalue since <code>a</code> is an lvalue.</p> <p></p> <p>Next: Increment/Decrement, Previous: Lvalues, Up: Assignment Expressions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#73-modifying-assignment","title":"7.3 Modifying Assignment","text":"<p>You can abbreviate the common construct</p> <pre><code>lvalue = lvalue + expression\n</code></pre> <p>as</p> <pre><code>lvalue += expression\n</code></pre> <p>This is known as a modifying assignment. For instance,</p> <pre><code>i = i + 5;\ni += 5;\n</code></pre> <p>shows two statements that are equivalent. The first uses simple assignment; the second uses modifying assignment.</p> <p>Modifying assignment works with any binary arithmetic operator. For instance, you can subtract something from an lvalue like this,</p> <pre><code>lvalue -= expression\n</code></pre> <p>or multiply it by a certain amount like this,</p> <pre><code>lvalue *= expression\n</code></pre> <p>or shift it by a certain amount like this.</p> <pre><code>lvalue &lt;&lt;= expression\nlvalue &gt;&gt;= expression\n</code></pre> <p>In most cases, this feature adds no power to the language, but it provides substantial convenience. Also, when <code>lvalue</code> contains code that has side effects, the simple assignment performs those side effects twice, while the modifying assignment performs them once. For instance,</p> <pre><code>x[foo ()] = x[foo ()] + 5;\n</code></pre> <p>calls <code>foo</code> twice, and it could return different values each time. If <code>foo ()</code> returns 1 the first time and 3 the second time, then the effect could be to add <code>x[3]</code> and 5 and store the result in <code>x[1]</code>, or to add <code>x[1]</code> and 5 and store the result in <code>x[3]</code>. We don\u2019t know which of the two it will do, because C does not specify which call to <code>foo</code> is computed first.</p> <p>Such a statement is not well defined, and shouldn\u2019t be used.</p> <p>By contrast,</p> <pre><code>x[foo ()] += 5;\n</code></pre> <p>is well defined: it calls <code>foo</code> only once to determine which element of <code>x</code> to adjust, and it adjusts that element by adding 5 to it.</p> <p></p> <p>Next: Postincrement/Postdecrement, Previous: Modifying Assignment, Up: Assignment Expressions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#74-increment-and-decrement-operators","title":"7.4 Increment and Decrement Operators","text":"<p>The operators \u2018<code>++</code>\u2019 and \u2018<code>--</code>\u2019 are the increment and decrement operators. When used on a numeric value, they add or subtract 1. We don\u2019t consider them assignments, but they are equivalent to assignments.</p> <p>Using \u2018<code>++</code>\u2019 or \u2018<code>--</code>\u2019 as a prefix, before an lvalue, is called preincrement or predecrement. This adds or subtracts 1 and the result becomes the expression\u2019s value. For instance,</p> <pre><code>#include &lt;stdio.h&gt;   /* Declares printf. */\n\nint\nmain (void)\n{\n  int i = 5;\n  printf (\"%d\\n\", i);\n  printf (\"%d\\n\", ++i);\n  printf (\"%d\\n\", i);\n  return 0;\n}\n</code></pre> <p>prints lines containing 5, 6, and 6 again. The expression <code>++i</code> increments <code>i</code> from 5 to 6, and has the value 6, so the output from <code>printf</code> on that line says \u2018<code>6</code>\u2019.</p> <p>Using \u2018<code>--</code>\u2019 instead, for predecrement,</p> <pre><code>#include &lt;stdio.h&gt;   /* Declares printf. */\n\nint\nmain (void)\n{\n  int i = 5;\n  printf (\"%d\\n\", i);\n  printf (\"%d\\n\", --i);\n  printf (\"%d\\n\", i);\n  return 0;\n}\n</code></pre> <p>prints three lines that contain (respectively) \u2018<code>5</code>\u2019, \u2018<code>4</code>\u2019, and again \u2018<code>4</code>\u2019.</p> <p></p> <p>Next: Assignment in Subexpressions, Previous: Increment/Decrement, Up: Assignment Expressions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#75-postincrement-and-postdecrement","title":"7.5 Postincrement and Postdecrement","text":"<p>Using \u2018<code>++</code>\u2019 or \u2018<code>--</code>\u2019 after an lvalue does something peculiar: it gets the value directly out of the lvalue and then increments or decrements it. Thus, the value of <code>i++</code> is the same as the value of <code>i</code>, but <code>i++</code> also increments <code>i</code> \u201ca little later.\u201d This is called postincrement or postdecrement.</p> <p>For example,</p> <pre><code>#include &lt;stdio.h&gt;   /* Declares printf. */\n\nint\nmain (void)\n{\n  int i = 5;\n  printf (\"%d\\n\", i);\n  printf (\"%d\\n\", i++);\n  printf (\"%d\\n\", i);\n  return 0;\n}\n</code></pre> <p>prints lines containing 5, again 5, and 6. The expression <code>i++</code> has the value 5, which is the value of <code>i</code> at the time, but it increments <code>i</code> from 5 to 6 just a little later.</p> <p>How much later is \u201cjust a little later\u201d? The compiler has some flexibility in deciding that. The rule is that the increment has to happen by the next sequence point; in simple cases, that means by the end of the statement. See Sequence Points.</p> <p>Regardless of precisely where the compiled code increments the value of <code>i</code>, the crucial thing is that the value of <code>i++</code> is the value that <code>i</code> has before incrementing it.</p> <p>If a unary operator precedes a postincrement or postincrement expression, the increment nests inside:</p> <pre><code>-a++   is equivalent to   -(a++)\n</code></pre> <p>That\u2019s the only order that makes sense; <code>-a</code> is not an lvalue, so it can\u2019t be incremented.</p> <p>The most common use of postincrement is with arrays. Here\u2019s an example of using postincrement to access one element of an array and advance the index for the next access. Compare this with the example <code>avg_of_double</code> (see Array Example), which is almost the same but doesn\u2019t use postincrement.</p> <pre><code>double\navg_of_double_alt (int length, double input_data[])\n{\n  double sum = 0;\n  int i;\n\n  /* Fetch each element and add it into sum.  */\n  for (i = 0; i &lt; length;)\n    /* Use the index i, then increment it.  */\n    sum += input_data[i++];\n\n  return sum / length;\n}\n</code></pre> <p></p> <p>Next: Write Assignments Separately, Previous: Postincrement/Postdecrement, Up: Assignment Expressions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#76-pitfall-assignment-in-subexpressions","title":"7.6 Pitfall: Assignment in Subexpressions","text":"<p>In C, the order of computing parts of an expression is not fixed. Aside from a few special cases, the operations can be computed in any order. If one part of the expression has an assignment to <code>x</code> and another part of the expression uses <code>x</code>, the result is unpredictable because that use might be computed before or after the assignment.</p> <p>Here\u2019s an example of ambiguous code:</p> <pre><code>x = 20;\nprintf (\"%d %d\\n\", x, x = 4);\n</code></pre> <p>If the second argument, <code>x</code>, is computed before the third argument, <code>x = 4</code>, the second argument\u2019s value will be 20. If they are computed in the other order, the second argument\u2019s value will be 4.</p> <p>Here\u2019s one way to make that code unambiguous:</p> <pre><code>y = 20;\nprintf (\"%d %d\\n\", y, x = 4);\n</code></pre> <p>Here\u2019s another way, with the other meaning:</p> <pre><code>x = 4;\nprintf (\"%d %d\\n\", x, x);\n</code></pre> <p>This issue applies to all kinds of assignments, and to the increment and decrement operators, which are equivalent to assignments. See Order of Execution, for more information about this.</p> <p>However, it can be useful to write assignments inside an <code>if</code>-condition or <code>while</code>-test along with logical operators. See Logicals and Assignments.</p> <p></p> <p>Previous: Assignment in Subexpressions, Up: Assignment Expressions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#77-write-assignments-in-separate-statements","title":"7.7 Write Assignments in Separate Statements","text":"<p>It is often convenient to write an assignment inside an <code>if</code>-condition, but that can reduce the readability of the program. Here\u2019s an example of what to avoid:</p> <pre><code>if (x = advance (x))\n  \u2026\n</code></pre> <p>The idea here is to advance <code>x</code> and test if the value is nonzero. However, readers might miss the fact that it uses \u2018<code>=</code>\u2019 and not \u2018<code>==</code>\u2019. In fact, writing \u2018<code>=</code>\u2019 where \u2018<code>==</code>\u2019 was intended inside a condition is a common error, so GNU C can give warnings when \u2018<code>=</code>\u2019 appears in a way that suggests it\u2019s an error.</p> <p>It is much clearer to write the assignment as a separate statement, like this:</p> <pre><code>x = advance (x);\nif (x != 0)\n  \u2026\n</code></pre> <p>This makes it unmistakably clear that <code>x</code> is assigned a new value.</p> <p>Another method is to use the comma operator (see Comma Operator), like this:</p> <pre><code>if (x = advance (x), x != 0)\n  \u2026\n</code></pre> <p>However, putting the assignment in a separate statement is usually clearer unless the assignment is very short, because it reduces nesting.</p> <p></p> <p>Next: Binary Operator Grammar, Previous: Assignment Expressions, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#8-execution-control-expressions","title":"8 Execution Control Expressions","text":"<p>This chapter describes the C operators that combine expressions to control which of those expressions execute, or in which order.</p> \u2022 Logical Operators Logical conjunction, disjunction, negation. \u2022 Logicals and Comparison Logical operators with comparison operators. \u2022 Logicals and Assignments Assignments with logical operators. \u2022 Conditional Expression An if/else construct inside expressions. \u2022 Comma Operator Build a sequence of subexpressions. <p></p> <p>Next: Logicals and Comparison, Up: Execution Control Expressions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#81-logical-operators","title":"8.1 Logical Operators","text":"<p>The logical operators combine truth values, which are normally represented in C as numbers. Any expression with a numeric value is a valid truth value: zero means false, and any other value means true. A pointer type is also meaningful as a truth value; a null pointer (which is zero) means false, and a non-null pointer means true (see Pointer Types). The value of a logical operator is always 1 or 0 and has type <code>int</code> (see Integer Types).</p> <p>The logical operators are used mainly in the condition of an <code>if</code> statement, or in the end test in a <code>for</code> statement or <code>while</code> statement (see Statements). However, they are valid in any context where an integer-valued expression is allowed.</p> <p>\u2018<code>! ``exp</code>\u2019 Unary operator for logical \u201cnot.\u201d The value is 1 (true) if <code>exp</code> is 0 (false), and 0 (false) if <code>exp</code> is nonzero (true).</p> <p>Warning: if <code>exp</code> is anything but an lvalue or a function call, you should write parentheses around it.</p> <p>\u2018<code>left`` &amp;&amp; ``right</code>\u2019 The logical \u201cand\u201d binary operator computes <code>left</code> and, if necessary, <code>right</code>. If both of the operands are true, the \u2018<code>&amp;&amp;</code>\u2019 expression gives the value 1 (which is true). Otherwise, the \u2018<code>&amp;&amp;</code>\u2019 expression gives the value 0 (false). If <code>left</code> yields a false value, that determines the overall result, so <code>right</code> is not computed.</p> <p>\u2018<code>left`` || ``right</code>\u2019 The logical \u201cor\u201d binary operator computes <code>left</code> and, if necessary, <code>right</code>. If at least one of the operands is true, the \u2018<code>||</code>\u2019 expression gives the value 1 (which is true). Otherwise, the \u2018<code>||</code>\u2019 expression gives the value 0 (false). If <code>left</code> yields a true value, that determines the overall result, so <code>right</code> is not computed.</p> <p>Warning: never rely on the relative precedence of \u2018<code>&amp;&amp;</code>\u2019 and \u2018<code>||</code>\u2019. When you use them together, always use parentheses to specify explicitly how they nest, as shown here:</p> <pre><code>if ((r != 0 &amp;&amp; x % r == 0)\n    ||\n    (s != 0 &amp;&amp; x % s == 0))\n</code></pre> <p></p> <p>Next: Logicals and Assignments, Previous: Logical Operators, Up: Execution Control Expressions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#82-logical-operators-and-comparisons","title":"8.2 Logical Operators and Comparisons","text":"<p>The most common thing to use inside the logical operators is a comparison. Conveniently, \u2018<code>&amp;&amp;</code>\u2019 and \u2018<code>||</code>\u2019 have lower precedence than comparison operators and arithmetic operators, so we can write expressions like this without parentheses and get the nesting that is natural: two comparison operations that must both be true.</p> <pre><code>if (r != 0 &amp;&amp; x % r == 0)\n</code></pre> <p>This example also shows how it is useful that \u2018<code>&amp;&amp;</code>\u2019 guarantees to skip the right operand if the left one turns out false. Because of that, this code never tries to divide by zero.</p> <p>This is equivalent:</p> <pre><code>if (r &amp;&amp; x % r == 0)\n</code></pre> <p>A truth value is simply a number, so using <code>r</code> as a truth value tests whether it is nonzero. But <code>r</code>\u2019s meaning as en expression is not a truth value\u2014it is a number to divide by. So it is better style to write the explicit <code>!= 0</code>.</p> <p>Here\u2019s another equivalent way to write it:</p> <pre><code>if (!(r == 0) &amp;&amp; x % r == 0)\n</code></pre> <p>This illustrates the unary \u2018<code>!</code>\u2019 operator, and the need to write parentheses around its operand.</p> <p></p> <p>Next: Conditional Expression, Previous: Logicals and Comparison, Up: Execution Control Expressions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#83-logical-operators-and-assignments","title":"8.3 Logical Operators and Assignments","text":"<p>There are cases where assignments nested inside the condition can actually make a program easier to read. Here is an example using a hypothetical type <code>list</code> which represents a list; it tests whether the list has at least two links, using hypothetical functions, <code>nonempty</code> which is true if the argument is a nonempty list, and <code>list_next</code> which advances from one list link to the next. We assume that a list is never a null pointer, so that the assignment expressions are always \u201ctrue.\u201d</p> <pre><code>if (nonempty (list)\n    &amp;&amp; (temp1 = list_next (list))\n    &amp;&amp; nonempty (temp1)\n    &amp;&amp; (temp2 = list_next (temp1)))\n  \u2026  /* use temp1 and temp2 */\n</code></pre> <p>Here we take advantage of the \u2018<code>&amp;&amp;</code>\u2019 operator to avoid executing the rest of the code if a call to <code>nonempty</code> returns \u201cfalse.\u201d The only natural place to put the assignments is among those calls.</p> <p>It would be possible to rewrite this as several statements, but that could make it much more cumbersome. On the other hand, when the test is even more complex than this one, splitting it into multiple statements might be necessary for clarity.</p> <p>If an empty list is a null pointer, we can dispense with calling <code>nonempty</code>:</p> <pre><code>if ((temp1 = list_next (list))\n    &amp;&amp; (temp2 = list_next (temp1)))\n \u2026\n</code></pre> <p></p> <p>Next: Comma Operator, Previous: Logicals and Assignments, Up: Execution Control Expressions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#84-conditional-expression","title":"8.4 Conditional Expression","text":"<p>C has a conditional expression that selects one of two expressions to compute and get the value from. It looks like this:</p> <pre><code>condition ? iftrue : iffalse\n</code></pre> \u2022 Conditional Rules Rules for the conditional operator. \u2022 Conditional Branches About the two branches in a conditional. <p></p> <p>Next: Conditional Branches, Up: Conditional Expression \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#841-rules-for-the-conditional-operator","title":"8.4.1 Rules for the Conditional Operator","text":"<p>The first operand, <code>condition</code>, should be a value that can be compared with zero\u2014a number or a pointer. If it is true (nonzero), then the conditional expression computes <code>iftrue</code> and its value becomes the value of the conditional expression. Otherwise the conditional expression computes <code>iffalse</code> and its value becomes the value of the conditional expression. The conditional expression always computes just one of <code>iftrue</code> and <code>iffalse</code>, never both of them.</p> <p>Here\u2019s an example: the absolute value of a number <code>x</code> can be written as <code>(x &gt;= 0 ? x : -x)</code>.</p> <p>Warning: The conditional expression operators have rather low syntactic precedence. Except when the conditional expression is used as an argument in a function call, write parentheses around it. For clarity, always write parentheses around it if it extends across more than one line.</p> <p>Assignment operators and the comma operator (see Comma Operator) have lower precedence than conditional expression operators, so write parentheses around those when they appear inside a conditional expression. See Order of Execution.</p> <p></p> <p>Previous: Conditional Rules, Up: Conditional Expression \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#842-conditional-operator-branches","title":"8.4.2 Conditional Operator Branches","text":"<p>We call <code>iftrue</code> and <code>iffalse</code> the branches of the conditional.</p> <p>The two branches should normally have the same type, but a few exceptions are allowed. If they are both numeric types, the conditional converts both to their common type (see Common Type).</p> <p>With pointers (see Pointers), the two values can be pointers to nearly compatible types (see Compatible Types). In this case, the result type is a similar pointer whose target type combines all the type qualifiers (see Type Qualifiers) of both branches.</p> <p>If one branch has type <code>void *</code> and the other is a pointer to an object (not to a function), the conditional converts the <code>void *</code> branch to the type of the other.</p> <p>If one branch is an integer constant with value zero and the other is a pointer, the conditional converts zero to the pointer\u2019s type.</p> <p>In GNU C, you can omit <code>iftrue</code> in a conditional expression. In that case, if <code>condition</code> is nonzero, its value becomes the value of the conditional expression, after conversion to the common type. Thus,</p> <pre><code>x ? : y\n</code></pre> <p>has the value of <code>x</code> if that is nonzero; otherwise, the value of <code>y</code>.</p> <p> </p> <p>Omitting <code>iftrue</code> is useful when <code>condition</code> has side effects. In that case, writing that expression twice would carry out the side effects twice, but writing it once does them just once. For example, if we suppose that the function <code>next_element</code> advances a pointer variable to point to the next element in a list and returns the new pointer,</p> <pre><code>next_element () ? : default_pointer\n</code></pre> <p>is a way to advance the pointer and use its new value if it isn\u2019t null, but use <code>default_pointer</code> if that is null. We cannot do it this way,</p> <pre><code>next_element () ? next_element () : default_pointer\n</code></pre> <p>because that would advance the pointer a second time.</p> <p></p> <p>Previous: Conditional Expression, Up: Execution Control Expressions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#85-comma-operator","title":"8.5 Comma Operator","text":"<p>The comma operator stands for sequential execution of expressions. The value of the comma expression comes from the last expression in the sequence; the previous expressions are computed only for their side effects. It looks like this:</p> <pre><code>exp1, exp2 \u2026\n</code></pre> <p>You can bundle any number of expressions together this way, by putting commas between them.</p> \u2022 Uses of Comma When to use the comma operator. \u2022 Clean Comma Clean use of the comma operator. \u2022 Avoid Comma When to not use the comma operator. <p></p> <p>Next: Clean Comma, Up: Comma Operator \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#851-the-uses-of-the-comma-operator","title":"8.5.1 The Uses of the Comma Operator","text":"<p>With commas, you can put several expressions into a place that requires just one expression\u2014for example, in the header of a <code>for</code> statement. This statement</p> <pre><code>for (i = 0, j = 10, k = 20; i &lt; n; i++)\n</code></pre> <p>contains three assignment expressions, to initialize <code>i</code>, <code>j</code> and <code>k</code>. The syntax of <code>for</code> requires just one expression for initialization; to include three assignments, we use commas to bundle them into a single larger expression, <code>i = 0, j = 10, k = 20</code>. This technique is also useful in the loop-advance expression, the last of the three inside the <code>for</code> parentheses.</p> <p>In the <code>for</code> statement and the <code>while</code> statement (see Loop Statements), a comma provides a way to perform some side effect before the loop-exit test. For example,</p> <pre><code>while (printf (\"At the test, x = %d\\n\", x), x != 0)\n</code></pre> <p></p> <p>Next: Avoid Comma, Previous: Uses of Comma, Up: Comma Operator \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#852-clean-use-of-the-comma-operator","title":"8.5.2 Clean Use of the Comma Operator","text":"<p>Always write parentheses around a series of comma operators, except when it is at top level in an expression statement, or within the parentheses of an <code>if</code>, <code>for</code>, <code>while</code>, or <code>switch</code> statement (see Statements). For instance, in</p> <pre><code>for (i = 0, j = 10, k = 20; i &lt; n; i++)\n</code></pre> <p>the commas between the assignments are clear because they are between a parenthesis and a semicolon.</p> <p>The arguments in a function call are also separated by commas, but that is not an instance of the comma operator. Note the difference between</p> <pre><code>foo (4, 5, 6)\n</code></pre> <p>which passes three arguments to <code>foo</code> and</p> <pre><code>foo ((4, 5, 6))\n</code></pre> <p>which uses the comma operator and passes just one argument (with value 6).</p> <p>Warning: don\u2019t use the comma operator around an argument of a function unless it makes the code more readable. When you do so, don\u2019t put part of another argument on the same line. Instead, add a line break to make the parentheses around the comma operator easier to see, like this.</p> <pre><code>foo ((mumble (x, y), frob (z)),\n     *p)\n</code></pre> <p></p> <p>Previous: Clean Comma, Up: Comma Operator \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#853-when-not-to-use-the-comma-operator","title":"8.5.3 When Not to Use the Comma Operator","text":"<p>You can use a comma in any subexpression, but in most cases it only makes the code confusing, and it is clearer to raise all but the last of the comma-separated expressions to a higher level. Thus, instead of this:</p> <pre><code>x = (y += 4, 8);\n</code></pre> <p>it is much clearer to write this:</p> <pre><code>y += 4, x = 8;\n</code></pre> <p>or this:</p> <pre><code>y += 4;\nx = 8;\n</code></pre> <p>Use commas only in the cases where there is no clearer alternative involving multiple statements.</p> <p>By contrast, don\u2019t hesitate to use commas in the expansion in a macro definition. The trade-offs of code clarity are different in that case, because the use of the macro may improve overall clarity so much that the ugliness of the macro\u2019s definition is a small price to pay. See Macros.</p> <p></p> <p>Next: Order of Execution, Previous: Execution Control Expressions, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#9-binary-operator-grammar","title":"9 Binary Operator Grammar","text":"<p>Binary operators are those that take two operands, one on the left and one on the right.</p> <p>All the binary operators in C are syntactically left-associative. This means that <code>a\u00a0``op``\u00a0b\u00a0``op``\u00a0c</code> means <code>(a\u00a0``op``\u00a0b)\u00a0``op``\u00a0c</code>. However, the only operators you should repeat in this way without parentheses are \u2018<code>+</code>\u2019, \u2018<code>-</code>\u2019, \u2018<code>*</code>\u2019 and \u2018<code>/</code>\u2019, because those cases are clear from algebra. So it is OK to write <code>a + b + c</code> or <code>a - b - c</code>, but never <code>a == b == c</code> or <code>a % b % c</code>. For those operators, use explicit parentheses to show how the operations nest.</p> <p>Each C operator has a precedence, which is its rank in the grammatical order of the various operators. The operators with the highest precedence grab adjoining operands first; these expressions then become operands for operators of lower precedence.</p> <p>The precedence order of operators in C is fully specified, so any combination of operations leads to a well-defined nesting. We state only part of the full precedence ordering here because it is bad practice for C code to depend on the other cases. For cases not specified in this chapter, always use parentheses to make the nesting explicit.<sup>2</sup></p> <p>You can depend on this subsequence of the precedence ordering (stated from highest precedence to lowest):</p> <ol> <li>Postfix operations: access to a field or alternative (\u2018<code>.</code>\u2019 and     \u2018<code>-&gt;</code>\u2019), array subscripting, function calls, and unary postfix     operators.</li> <li>Unary prefix operators.</li> <li>Multiplication, division, and remainder (they have the same     precedence).</li> <li>Addition and subtraction (they have the same precedence).</li> <li>Comparisons\u2014but watch out!</li> <li>Logical operators \u2018<code>&amp;&amp;</code>\u2019 and \u2018<code>||</code>\u2019\u2014but watch out!</li> <li>Conditional expression with \u2018<code>?</code>\u2019 and \u2018<code>:</code>\u2019.</li> <li>Assignments.</li> <li>Sequential execution (the comma operator, \u2018<code>,</code>\u2019).</li> </ol> <p>Two of the lines in the above list say \u201cbut watch out!\u201d That means that the line covers operators with subtly different precedence. Never depend on the grammar of C to decide how two comparisons nest; instead, always use parentheses to specify their nesting.</p> <p>You can let several \u2018<code>&amp;&amp;</code>\u2019 operators associate, or several \u2018<code>||</code>\u2019 operators, but always use parentheses to show how \u2018<code>&amp;&amp;</code>\u2019 and \u2018<code>||</code>\u2019 nest with each other. See Logical Operators.</p> <p>There is one other precedence ordering that code can depend on:</p> <ol> <li>Unary postfix operators.</li> <li>Bitwise and shift operators\u2014but watch out!</li> <li>Conditional expression with \u2018<code>?</code>\u2019 and \u2018<code>:</code>\u2019.</li> </ol> <p>The caveat for bitwise and shift operators is like that for logical operators: you can let multiple uses of one bitwise operator associate, but always use parentheses to control nesting of dissimilar operators.</p> <p>These lists do not specify any precedence ordering between the bitwise and shift operators of the second list and the binary operators above conditional expressions in the first list. When they come together, parenthesize them. See Bitwise Operations.</p> <p></p> <p>Next: Primitive Types, Previous: Binary Operator Grammar, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#10-order-of-execution","title":"10 Order of Execution","text":"<p>The order of execution of a C program is not always obvious, and not necessarily predictable. This chapter describes what you can count on.</p> \u2022 Reordering of Operands Operations in C are not necessarily computed in the order they are written. \u2022 Associativity and Ordering Some associative operations are performed in a particular order; others are not. \u2022 Sequence Points Some guarantees about the order of operations. \u2022 Postincrement and Ordering Ambiguous execution order with postincrement. \u2022 Ordering of Operands Evaluation order of operands and function arguments. \u2022 Optimization and Ordering Compiler optimizations can reorder operations only if it has no impact on program results. <p></p> <p>Next: Associativity and Ordering, Up: Order of Execution \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#101-reordering-of-operands","title":"10.1 Reordering of Operands","text":"<p>The C language does not necessarily carry out operations within an expression in the order they appear in the code. For instance, in this expression,</p> <pre><code>foo () + bar ()\n</code></pre> <p><code>foo</code> might be called first or <code>bar</code> might be called first. If <code>foo</code> updates a datum and <code>bar</code> uses that datum, the results can be unpredictable.</p> <p>The unpredictable order of computation of subexpressions also makes a difference when one of them contains an assignment. We already saw this example of bad code,</p> <pre><code>x = 20;\nprintf (\"%d %d\\n\", x, x = 4);\n</code></pre> <p>in which the second argument, <code>x</code>, has a different value depending on whether it is computed before or after the assignment in the third argument.</p> <p></p> <p>Next: Sequence Points, Previous: Reordering of Operands, Up: Order of Execution \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#102-associativity-and-ordering","title":"10.2 Associativity and Ordering","text":"<p>An associative binary operator, such as <code>+</code>, when used repeatedly can combine any number of operands. The operands\u2019 values may be computed in any order.</p> <p>If the values are integers and overflow can be ignored, they may be combined in any order. Thus, given four functions that return <code>unsigned int</code>, calling them and adding their results as here</p> <pre><code>(foo () + bar ()) + (baz () + quux ())\n</code></pre> <p>may add up the results in any order.</p> <p>By contrast, arithmetic on signed integers, in which overflow is significant, is not always associative (see Integer Overflow). Thus, the additions must be done in the order specified, obeying parentheses and left-association. That means computing <code>(foo () + bar ())</code> and <code>(baz () + quux ())</code> first (in either order), then adding the two.</p> <p>The same applies to arithmetic on floating-point values, since that too is not really associative. However, the GCC option <code>-funsafe-math-optimizations</code> allows the compiler to change the order of calculation when an associative operation (associative in exact mathematics) combines several operands. The option takes effect when compiling a module (see Compilation). Changing the order of association can enable the program to pipeline the floating point operations.</p> <p>In all these cases, the four function calls can be done in any order. There is no right or wrong about that.</p> <p></p> <p>Next: Postincrement and Ordering, Previous: Associativity and Ordering, Up: Order of Execution \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#103-sequence-points","title":"10.3 Sequence Points","text":"<p>There are some points in the code where C makes limited guarantees about the order of operations. These are called sequence points. Here is where they occur:</p> <ul> <li> <p>At the end of a full expression; that is to say, an expression     that is not part of a larger expression. All side effects specified     by that expression are carried out before execution moves on to     subsequent code.</p> </li> <li> <p>At the end of the first operand of certain operators: \u2018<code>,</code>\u2019, \u2018<code>&amp;&amp;</code>\u2019,     \u2018<code>||</code>\u2019, and \u2018<code>?:</code>\u2019. All side effects specified by that expression     are carried out before any execution of the next operand.</p> <p>The commas that separate arguments in a function call are not comma operators, and they do not create sequence points. The rule for function arguments and the rule for operands are different (see Ordering of Operands).</p> </li> <li> <p>Just before calling a function. All side effects specified by the     argument expressions are carried out before calling the function.</p> <p>If the function to be called is not constant\u2014that is, if it is computed by an expression\u2014all side effects in that expression are carried out before calling the function.</p> </li> </ul> <p>The ordering imposed by a sequence point applies locally to a limited range of code, as stated above in each case. For instance, the ordering imposed by the comma operator does not apply to code outside the operands of that comma operator. Thus, in this code,</p> <pre><code>(x = 5, foo (x)) + x * x\n</code></pre> <p>the sequence point of the comma operator orders <code>x = 5</code> before <code>foo (x)</code>, but <code>x * x</code> could be computed before or after them.</p> <p></p> <p>Next: Ordering of Operands, Previous: Sequence Points, Up: Order of Execution \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#104-postincrement-and-ordering","title":"10.4 Postincrement and Ordering","text":"<p>The ordering requirements for the postincrement and postdecrement operations (see Postincrement/Postdecrement) are loose: those side effects must happen \u201ca little later,\u201d before the next sequence point. That still leaves room for various orders that give different results. In this expression,</p> <pre><code>z = x++ - foo ()\n</code></pre> <p>it\u2019s unpredictable whether <code>x</code> gets incremented before or after calling the function <code>foo</code>. If <code>foo</code> refers to <code>x</code>, it might see the old value or it might see the incremented value.</p> <p>In this perverse expression,</p> <pre><code>x = x++\n</code></pre> <p><code>x</code> will certainly be incremented but the incremented value may be replaced with the old value. That\u2019s because the incrementation and the assignment may occur in either oder. If the incrementation of <code>x</code> occurs after the assignment to <code>x</code>, the incremented value will remain in place. But if the incrementation happens first, the assignment will put the not-yet-incremented value back into <code>x</code>, so the expression as a whole will leave <code>x</code> unchanged.</p> <p>The conclusion: avoid such expressions. Take care, when you use postincrement and postdecrement, that the specific expression you use is not ambiguous as to order of execution.</p> <p></p> <p>Next: Optimization and Ordering, Previous: Postincrement and Ordering, Up: Order of Execution \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#105-ordering-of-operands","title":"10.5 Ordering of Operands","text":"<p>Operands and arguments can be computed in any order, but there are limits to this intermixing in GNU C:</p> <ul> <li>The operands of a binary arithmetic operator can be computed in     either order, but they can\u2019t be intermixed: one of them has to come     first, followed by the other. Any side effects in the operand that\u2019s     computed first are executed before the other operand is computed.</li> <li>That applies to assignment operators too, except that, in simple     assignment, the previous value of the left operand is unused.</li> <li>The arguments in a function call can be computed in any order, but     they can\u2019t be intermixed. Thus, one argument is fully computed, then     another, and so on until they have all been done. Any side effects     in one argument are executed before computation of another argument     begins.</li> </ul> <p>These rules don\u2019t cover side effects caused by postincrement and postdecrement operators\u2014those can be deferred up to the next sequence point.</p> <p>If you want to get pedantic, the fact is that GCC can reorder the computations in many other ways provided that it doesn\u2019t alter the result of running the program. However, because it doesn\u2019t alter the result of running the program, it is negligible, unless you are concerned with the values in certain variables at various times as seen by other processes. In those cases, you should use <code>volatile</code> to prevent optimizations that would make them behave strangely. See volatile.</p> <p></p> <p>Previous: Ordering of Operands, Up: Order of Execution \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#106-optimization-and-ordering","title":"10.6 Optimization and Ordering","text":"<p>Sequence points limit the compiler\u2019s freedom to reorder operations arbitrarily, but optimizations can still reorder them if the compiler concludes that this won\u2019t alter the results. Thus, in this code,</p> <pre><code>x++;\ny = z;\nx++;\n</code></pre> <p>there is a sequence point after each statement, so the code is supposed to increment <code>x</code> once before the assignment to <code>y</code> and once after. However, incrementing <code>x</code> has no effect on <code>y</code> or <code>z</code>, and setting <code>y</code> can\u2019t affect <code>x</code>, so the code could be optimized into this:</p> <pre><code>y = z;\nx += 2;\n</code></pre> <p>Normally that has no effect except to make the program faster. But there are special situations where it can cause trouble due to things that the compiler cannot know about, such as shared memory. To limit optimization in those places, use the <code>volatile</code> type qualifier (see volatile).</p> <p></p> <p>Next: Constants, Previous: Order of Execution, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#11-primitive-data-types","title":"11 Primitive Data Types","text":"<p>This chapter describes all the primitive data types of C\u2014that is, all the data types that aren\u2019t built up from other types. They include the types <code>int</code> and <code>double</code> that we\u2019ve already covered.</p> \u2022 Integer Types Description of integer types. \u2022 Floating-Point Data Types Description of floating-point types. \u2022 Complex Data Types Description of complex number types. \u2022 The Void Type A type indicating no value at all. \u2022 Other Data Types A brief summary of other types. \u2022 Type Designators Referring to a data type abstractly. <p>These types are all made up of bytes (see Storage).</p> <p></p> <p>Next: Floating-Point Data Types, Up: Primitive Types \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#111-integer-data-types","title":"11.1 Integer Data Types","text":"<p>Here we describe all the integer types and their basic characteristics. See Integers in Depth, for more information about the bit-level integer data representations and arithmetic.</p> \u2022 Basic Integers Overview of the various kinds of integers. \u2022 Signed and Unsigned Types Integers can either hold both negative and non-negative values, or only non-negative. \u2022 Narrow Integers When to use smaller integer types. \u2022 Integer Conversion Casting a value from one integer type to another. \u2022 Boolean Type An integer type for boolean values. \u2022 Integer Variations Sizes of integer types can vary across platforms. <p></p> <p>Next: Signed and Unsigned Types, Up: Integer Types \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1111-basic-integers","title":"11.1.1 Basic Integers","text":"<p>Integer data types in C can be signed or unsigned. An unsigned type can represent only positive numbers and zero. A signed type can represent both positive and negative numbers, in a range spread almost equally on both sides of zero.</p> <p>Aside from signedness, the integer data types vary in size: how many bytes long they are. The size determines the range of integer values the type can hold.</p> <p>Here\u2019s a list of the signed integer data types, with the sizes they have on most computers. Each has a corresponding unsigned type; see Signed and Unsigned Types.</p> <p><code>signed char</code> One byte (8 bits). This integer type is used mainly for integers that represent characters, usually as elements of arrays or fields of other data structures.</p> <p><code>short</code> <code>short int</code> Two bytes (16 bits).</p> <p><code>int</code> Four bytes (32 bits).</p> <p><code>long</code> <code>long int</code> Four bytes (32 bits) or eight bytes (64 bits), depending on the platform. Typically it is 32 bits on 32-bit computers and 64 bits on 64-bit computers, but there are exceptions.</p> <p><code>long long</code> <code>long long int</code> Eight bytes (64 bits). Supported in GNU C in the 1980s, and incorporated into standard C as of ISO C99.</p> <p>You can omit <code>int</code> when you use <code>long</code> or <code>short</code>. This is harmless and customary.</p> <p></p> <p>Next: Narrow Integers, Previous: Basic Integers, Up: Integer Types \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1112-signed-and-unsigned-types","title":"11.1.2 Signed and Unsigned Types","text":"<p>An unsigned integer type can represent only positive numbers and zero. A signed type can represent both positive and negative number, in a range spread almost equally on both sides of zero. For instance, <code>unsigned char</code> holds numbers from 0 to 255 (on most computers), while <code>signed char</code> holds numbers from -128 to 127. Each of these types holds 256 different possible values, since they are both 8 bits wide.</p> <p>Write <code>signed</code> or <code>unsigned</code> before the type keyword to specify a signed or an unsigned type. However, the integer types other than <code>char</code> are signed by default; with them, <code>signed</code> is a no-op.</p> <p>Plain <code>char</code> may be signed or unsigned; this depends on the compiler, the machine in use, and its operating system.</p> <p>In many programs, it makes no difference whether <code>char</code> is signed. When it does matter, don\u2019t leave it to chance; write <code>signed char</code> or <code>unsigned char</code>.<sup>3</sup></p> <p></p> <p>Next: Integer Conversion, Previous: Signed and Unsigned Types, Up: Integer Types \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1113-narrow-integers","title":"11.1.3 Narrow Integers","text":"<p>The types that are narrower than <code>int</code> are rarely used for ordinary variables\u2014we declare them <code>int</code> instead. This is because C converts those narrower types to <code>int</code> for any arithmetic. There is literally no reason to declare a local variable <code>char</code>, for instance.</p> <p>In particular, if the value is really a character, you should declare the variable <code>int</code>. Not <code>char</code>! Using that narrow type can force the compiler to truncate values for conversion, which is a waste. Furthermore, some functions return either a character value, or -1 for \u201cno character.\u201d Using <code>int</code> makes it possible to distinguish -1 from a character by sign.</p> <p>The narrow integer types are useful as parts of other objects, such as arrays and structures. Compare these array declarations, whose sizes on 32-bit processors are shown:</p> <pre><code>signed char ac[1000];   /* 1000 bytes */\nshort as[1000];         /* 2000 bytes */\nint ai[1000];           /* 4000 bytes */\nlong long all[1000];    /* 8000 bytes */\n</code></pre> <p>In addition, character strings must be made up of <code>char</code>s, because that\u2019s what all the standard library string functions expect. Thus, array <code>ac</code> could be used as a character string, but the others could not be.</p> <p></p> <p>Next: Boolean Type, Previous: Narrow Integers, Up: Integer Types \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1114-conversion-among-integer-types","title":"11.1.4 Conversion among Integer Types","text":"<p>C converts between integer types implicitly in many situations. It converts the narrow integer types, <code>char</code> and <code>short</code>, to <code>int</code> whenever they are used in arithmetic. Assigning a new value to an integer variable (or other lvalue) converts the value to the variable\u2019s type.</p> <p>You can also convert one integer type to another explicitly with a cast operator. See Explicit Type Conversion.</p> <p>The process of conversion to a wider type is straightforward: the value is unchanged. The only exception is when converting a negative value (in a signed type, obviously) to a wider unsigned type. In that case, the result is a positive value with the same bits (see Integers in Depth).</p> <p></p> <p>Converting to a narrower type, also called truncation, involves discarding some of the value\u2019s bits. This is not considered overflow (see Integer Overflow) because loss of significant bits is a normal consequence of truncation. Likewise for conversion between signed and unsigned types of the same width.</p> <p>More information about conversion for assignment is in Assignment Type Conversions. For conversion for arithmetic, see Argument Promotions.</p> <p></p> <p>Next: Integer Variations, Previous: Integer Conversion, Up: Integer Types \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1115-boolean-type","title":"11.1.5 Boolean Type","text":"<p>The unsigned integer type <code>bool</code> holds truth values: its possible values are 0 and 1. Converting any nonzero value to <code>bool</code> results in 1. For example:</p> <pre><code>bool a = 0;\nbool b = 1;\nbool c = 4; /* Stores the value 1 in c.  */\n</code></pre> <p>Unlike <code>int</code>, <code>bool</code> is not a keyword. It is defined in the header file <code>stdbool.h</code>.</p> <p></p> <p>Previous: Boolean Type, Up: Integer Types \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1116-integer-variations","title":"11.1.6 Integer Variations","text":"<p>The integer types of C have standard names, but what they mean varies depending on the kind of platform in use: which kind of computer, which operating system, and which compiler. It may even depend on the compiler options used.</p> <p>Plain <code>char</code> may be signed or unsigned; this depends on the platform, too. Even for GNU C, there is no general rule.</p> <p>In theory, all of the integer types\u2019 sizes can vary. <code>char</code> is always considered one \u201cbyte\u201d for C, but it is not necessarily an 8-bit byte; on some platforms it may be more than 8 bits. ISO C specifies only that none of these types is narrower than the ones above it in the list in Basic Integers, and that <code>short</code> has at least 16 bits.</p> <p>It is possible that in the future GNU C will support platforms where <code>int</code> is 64 bits long. In practice, however, on today\u2019s real computers, there is little variation; you can rely on the table given previously (see Basic Integers).</p> <p>To be completely sure of the size of an integer type, use the types <code>int16_t</code>, <code>int32_t</code> and <code>int64_t</code>. Their corresponding unsigned types add \u2018<code>u</code>\u2019 at the front: <code>uint16_t</code>, <code>uint32_t</code> and <code>uint64_t</code>. To define all these types, include the header file <code>stdint.h</code>.</p> <p>The GNU C Compiler can compile for some embedded controllers that use two bytes for <code>int</code>. On some, <code>int</code> is just one \u201cbyte,\u201d and so is <code>short int</code>\u2014but that \u201cbyte\u201d may contain 16 bits or even 32 bits. These processors can\u2019t support an ordinary operating system (they may have their own specialized operating systems), and most C programs do not try to support them.</p> <p></p> <p>Next: Complex Data Types, Previous: Integer Types, Up: Primitive Types \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#112-floating-point-data-types","title":"11.2 Floating-Point Data Types","text":"<p>Floating point is the binary analogue of scientific notation: internally it represents a number as a fraction and a binary exponent; the value is that fraction multiplied by the specified power of 2. (The C standard nominally permits other bases, but in GNU C the base is always 2.)</p> <p>For instance, to represent 6, the fraction would be 0.75 and the exponent would be 3; together they stand for the value 0.75 * 2<sup>3</sup>, meaning 0.75 * 8. The value 1.5 would use 0.75 as the fraction and 1 as the exponent. The value 0.75 would use 0.75 as the fraction and 0 as the exponent. The value 0.375 would use 0.75 as the fraction and -1 as the exponent.</p> <p>These binary exponents are used by machine instructions. You can write a floating-point constant this way if you wish, using hexadecimal; but normally we write floating-point numbers in decimal (base 10). See Floating Constants.</p> <p>C has three floating-point data types:</p> <p><code>double</code> \u201cDouble-precision\u201d floating point, which uses 64 bits. This is the normal floating-point type, and modern computers normally do their floating-point computations in this type, or some wider type. Except when there is a special reason to do otherwise, this is the type to use for floating-point values.</p> <p><code>float</code> \u201cSingle-precision\u201d floating point, which uses 32 bits. It is useful for floating-point values stored in structures and arrays, to save space when the full precision of <code>double</code> is not needed. In addition, single-precision arithmetic is faster on some computers, and occasionally that is useful. But not often\u2014most programs don\u2019t use the type <code>float</code>.</p> <p>C would be cleaner if <code>float</code> were the name of the type we use for most floating-point values; however, for historical reasons, that\u2019s not so.</p> <p><code>long double</code> \u201cExtended-precision\u201d floating point is either 80-bit or 128-bit precision, depending on the machine in use. On some machines, which have no floating-point format wider than <code>double</code>, this is equivalent to <code>double</code>.</p> <p>Floating-point arithmetic raises many subtle issues. See Floating Point in Depth, for more information.</p> <p></p> <p>Next: The Void Type, Previous: Floating-Point Data Types, Up: Primitive Types \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#113-complex-data-types","title":"11.3 Complex Data Types","text":"<p>Complex numbers can include both a real part and an imaginary part. The numeric constants covered above have real-numbered values. An imaginary-valued constant is an ordinary real-valued constant followed by \u2018<code>i</code>\u2019.</p> <p>To declare numeric variables as complex, use the <code>_Complex</code> keyword.<sup>4</sup> The standard C complex data types are floating point,</p> <pre><code>_Complex float foo;\n_Complex double bar;\n_Complex long double quux;\n</code></pre> <p>but GNU C supports integer complex types as well.</p> <p>Since <code>_Complex</code> is a keyword just like <code>float</code> and <code>double</code> and <code>long</code>, the keywords can appear in any order, but the order shown above seems most logical.</p> <p>GNU C supports constants for complex values; for instance, <code>4.0 + 3.0i</code> has the value 4 + 3i as type <code>_Complex double</code>. See Imaginary Constants.</p> <p>To pull the real and imaginary parts of the number back out, GNU C provides the keywords <code>__real__</code> and <code>__imag__</code>:</p> <pre><code>_Complex double foo = 4.0 + 3.0i;\n\ndouble a = __real__ foo; /* a is now 4.0. */\ndouble b = __imag__ foo; /* b is now 3.0. */\n</code></pre> <p>Standard C does not include these keywords, and instead relies on functions defined in <code>complex.h</code> for accessing the real and imaginary parts of a complex number: <code>crealf</code>, <code>creal</code>, and <code>creall</code> extract the real part of a float, double, or long double complex number, respectively; <code>cimagf</code>, <code>cimag</code>, and <code>cimagl</code> extract the imaginary part.</p> <p></p> <p>GNU C also defines \u2018<code>~</code>\u2019 as an operator for complex conjugation, which means negating the imaginary part of a complex number:</p> <pre><code>_Complex double foo = 4.0 + 3.0i;\n_Complex double bar = ~foo; /* bar is now 4 - 3i. */\n</code></pre> <p>For standard C compatibility, you can use the appropriate library function: <code>conjf</code>, <code>conj</code>, or <code>confl</code>.</p> <p></p> <p>Next: Other Data Types, Previous: Complex Data Types, Up: Primitive Types \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#114-the-void-type","title":"11.4 The Void Type","text":"<p>The data type <code>void</code> is a dummy\u2014it allows no operations. It really means \u201cno value at all.\u201d When a function is meant to return no value, we write <code>void</code> for its return type. Then <code>return</code> statements in that function should not specify a value (see return Statement). Here\u2019s an example:</p> <pre><code>void\nprint_if_positive (double x, double y)\n{\n  if (x &lt;= 0)\n    return;\n  if (y &lt;= 0)\n    return;\n  printf (\"Next point is (%f,%f)\\n\", x, y);\n}\n</code></pre> <p>A <code>void</code>-returning function is comparable to what some other languages (for instance, Fortran and Pascal) call a \u201cprocedure\u201d instead of a \u201cfunction.\u201d</p> <p></p> <p>Next: Type Designators, Previous: The Void Type, Up: Primitive Types \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#115-other-data-types","title":"11.5 Other Data Types","text":"<p>Beyond the primitive types, C provides several ways to construct new data types. For instance, you can define pointers, values that represent the addresses of other data (see Pointers). You can define structures, as in many other languages (see Structures), and unions, which define multiple ways to interpret the contents of the same memory space (see Unions). Enumerations are collections of named integer codes (see Enumeration Types).</p> <p>Array types in C are used for allocating space for objects, but C does not permit operating on an array value as a whole. See Arrays.</p> <p></p> <p>Previous: Other Data Types, Up: Primitive Types \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#116-type-designators","title":"11.6 Type Designators","text":"<p>Some C constructs require a way to designate a specific data type independent of any particular variable or expression which has that type. The way to do this is with a type designator. The constructs that need one include casts (see Explicit Type Conversion) and <code>sizeof</code> (see Type Size).</p> <p>We also use type designators to talk about the type of a value in C, so you will see many type designators in this manual. When we say, \u201cThe value has type <code>int</code>,\u201d <code>int</code> is a type designator.</p> <p>To make the designator for any type, imagine a variable declaration for a variable of that type and delete the variable name and the final semicolon.</p> <p>For example, to designate the type of full-word integers, we start with the declaration for a variable <code>foo</code> with that type, which is this:</p> <pre><code>int foo;\n</code></pre> <p>Then we delete the variable name <code>foo</code> and the semicolon, leaving <code>int</code>\u2014exactly the keyword used in such a declaration. Therefore, the type designator for this type is <code>int</code>.</p> <p>What about long unsigned integers? From the declaration</p> <pre><code>unsigned long int foo;\n</code></pre> <p>we determine that the designator is <code>unsigned long int</code>.</p> <p>Following this procedure, the designator for any primitive type is simply the set of keywords which specifies that type in a declaration. The same is true for compound types such as structures, unions, and enumerations.</p> <p>Designators for pointer types do follow the rule of deleting the variable name and semicolon, but the result is not so simple. See Pointer Type Designators, as part of the chapter about pointers. See Array Type Designators), for designators for array types.</p> <p>To understand what type a designator stands for, imagine a variable name inserted into the right place in the designator to make a valid declaration. What type would that variable be declared as? That is the type the designator designates.</p> <p></p> <p>Next: Type Size, Previous: Primitive Types, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#12-constants","title":"12 Constants","text":"<p>A constant is an expression that stands for a specific value by explicitly representing the desired value. C allows constants for numbers, characters, and strings. We have already seen numeric and string constants in the examples.</p> \u2022 Integer Constants Literal integer values. \u2022 Integer Const Type Types of literal integer values. \u2022 Floating Constants Literal floating-point values. \u2022 Imaginary Constants Literal imaginary number values. \u2022 Invalid Numbers Avoiding preprocessing number misconceptions. \u2022 Character Constants Literal character values. \u2022 String Constants Literal string values. \u2022 UTF-8 String Constants Literal UTF-8 string values. \u2022 Unicode Character Codes Unicode characters represented in either UTF-16 or UTF-32. \u2022 Wide Character Constants Literal characters values larger than 8 bits. \u2022 Wide String Constants Literal string values made up of 16- or 32-bit characters. <p></p> <p>Next: Integer Const Type, Up: Constants \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#121-integer-constants","title":"12.1 Integer Constants","text":"<p>An integer constant consists of a number to specify the value, followed optionally by suffix letters to specify the data type.</p> <p>The simplest integer constants are numbers written in base 10 (decimal), such as <code>5</code>, <code>77</code>, and <code>403</code>. A decimal constant cannot start with the character \u2018<code>0</code>\u2019 (zero) because that makes the constant octal.</p> <p>You can get the effect of a negative integer constant by putting a minus sign at the beginning. In grammatical terms, that is an arithmetic expression rather than a constant, but it behaves just like a true constant.</p> <p>Integer constants can also be written in octal (base 8), hexadecimal (base 16), or binary (base 2). An octal constant starts with the character \u2018<code>0</code>\u2019 (zero), followed by any number of octal digits (\u2018<code>0</code>\u2019 to \u2018<code>7</code>\u2019):</p> <pre><code>0      // zero\n077    // 63\n0403   // 259\n</code></pre> <p>Pedantically speaking, the constant <code>0</code> is an octal constant, but we can think of it as decimal; it has the same value either way.</p> <p>A hexadecimal constant starts with \u2018<code>0x</code>\u2019 (upper or lower case) followed by hex digits (\u2018<code>0</code>\u2019 to \u2018<code>9</code>\u2019, as well as \u2018<code>a</code>\u2019 through \u2018<code>f</code>\u2019 in upper or lower case):</p> <pre><code>0xff   // 255\n0XA0   // 160\n0xffFF // 65535\n</code></pre> <p></p> <p>A binary constant starts with \u2018<code>0b</code>\u2019 (upper or lower case) followed by bits (each represented by the characters \u2018<code>0</code>\u2019 or \u2018<code>1</code>\u2019):</p> <pre><code>0b101  // 5\n</code></pre> <p>Binary constants are a GNU C extension, not part of the C standard.</p> <p>Sometimes a space is needed after an integer constant to avoid lexical confusion with the following tokens. See Invalid Numbers.</p> <p></p> <p>Next: Floating Constants, Previous: Integer Constants, Up: Constants \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#122-integer-constant-data-types","title":"12.2 Integer Constant Data Types","text":"<p>The type of an integer constant is normally <code>int</code>, if the value fits in that type, but here are the complete rules. The type of an integer constant is the first one in this sequence that can properly represent the value,</p> <ol> <li><code>int</code></li> <li><code>unsigned int</code></li> <li><code>long int</code></li> <li><code>unsigned long int</code></li> <li><code>long long int</code></li> <li><code>unsigned long long int</code></li> </ol> <p>and that isn\u2019t excluded by the following rules.</p> <p>If the constant has \u2018<code>l</code>\u2019 or \u2018<code>L</code>\u2019 as a suffix, that excludes the first two types (non-<code>long</code>).</p> <p>If the constant has \u2018<code>ll</code>\u2019 or \u2018<code>LL</code>\u2019 as a suffix, that excludes first four types (non-<code>long long</code>).</p> <p>If the constant has \u2018<code>u</code>\u2019 or \u2018<code>U</code>\u2019 as a suffix, that excludes the signed types.</p> <p>Otherwise, if the constant is decimal (not binary, octal, or hexadecimal), that excludes the unsigned types.</p> <p>Here are some examples of the suffixes.</p> <pre><code>3000000000u      // three billion as unsigned int.\n0LL              // zero as a long long int.\n0403l            // 259 as a long int.\n</code></pre> <p>Suffixes in integer constants are rarely used. When the precise type is important, it is cleaner to convert explicitly (see Explicit Type Conversion).</p> <p>See Integer Types.</p> <p></p> <p>Next: Imaginary Constants, Previous: Integer Const Type, Up: Constants \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#123-floating-point-constants","title":"12.3 Floating-Point Constants","text":"<p>A floating-point constant must have either a decimal point, an exponent-of-ten, or both; they distinguish it from an integer constant.</p> <p>To indicate an exponent, write \u2018<code>e</code>\u2019 or \u2018<code>E</code>\u2019. The exponent value follows. It is always written as a decimal number; it can optionally start with a sign. The exponent <code>n</code> means to multiply the constant\u2019s value by ten to the <code>n</code>th power.</p> <p>Thus, \u2018<code>1500.0</code>\u2019, \u2018<code>15e2</code>\u2019, \u2018<code>15e+2</code>\u2019, \u2018<code>15.0e2</code>\u2019, \u2018<code>1.5e+3</code>\u2019, \u2018<code>.15e4</code>\u2019, and \u2018<code>15000e-1</code>\u2019 are six ways of writing a floating-point number whose value is 1500. They are all equivalent in principle.</p> <p>Here are more examples with decimal points:</p> <pre><code>1.0\n1000.\n3.14159\n.05\n.0005\n</code></pre> <p>For each of them, here are some equivalent constants written with exponents:</p> <pre><code>1e0, 1.0000e0\n100e1, 100e+1, 100E+1, 1e3, 10000e-1\n3.14159e0\n5e-2, .0005e+2, 5E-2, .0005E2\n.05e-2\n</code></pre> <p>A floating-point constant normally has type <code>double</code>. You can force it to type <code>float</code> by adding \u2018<code>f</code>\u2019 or \u2018<code>F</code>\u2019 at the end. For example,</p> <pre><code>3.14159f\n3.14159e0f\n1000.f\n100E1F\n.0005f\n.05e-2f\n</code></pre> <p>Likewise, \u2018<code>l</code>\u2019 or \u2018<code>L</code>\u2019 at the end forces the constant to type <code>long double</code>.</p> <p>You can use exponents in hexadecimal floating constants, but since \u2018<code>e</code>\u2019 would be interpreted as a hexadecimal digit, the character \u2018<code>p</code>\u2019 or \u2018<code>P</code>\u2019 (for \u201cpower\u201d) indicates an exponent.</p> <p>The exponent in a hexadecimal floating constant is an optionally signed decimal integer that specifies a power of 2 (not 10 or 16) to multiply into the number.</p> <p>Here are some examples:</p> <pre><code>0xAp2        // 40 in decimal\n0xAp-1       // 5 in decimal\n0x2.0Bp4     // 32.6875 decimal\n0xE.2p3      // 113 decimal\n0x123.ABCp0  // 291.6708984375 in decimal\n0x123.ABCp4  // 4666.734375 in decimal\n0x100p-8     // 1\n0x10p-4      // 1\n0x1p+4       // 16\n0x1p+8       // 256\n</code></pre> <p>See Floating-Point Data Types.</p> <p></p> <p>Next: Invalid Numbers, Previous: Floating Constants, Up: Constants \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#124-imaginary-constants","title":"12.4 Imaginary Constants","text":"<p>A complex number consists of a real part plus an imaginary part. (You may omit one part if it is zero.) This section explains how to write numeric constants with imaginary values. By adding these to ordinary real-valued numeric constants, we can make constants with complex values.</p> <p>The simple way to write an imaginary-number constant is to attach the suffix \u2018<code>i</code>\u2019 or \u2018<code>I</code>\u2019, or \u2018<code>j</code>\u2019 or \u2018<code>J</code>\u2019, to an integer or floating-point constant. For example, <code>2.5fi</code> has type <code>_Complex float</code> and <code>3i</code> has type <code>_Complex int</code>. The four alternative suffix letters are all equivalent.</p> <p></p> <p>The other way to write an imaginary constant is to multiply a real constant by <code>_Complex_I</code>, which represents the imaginary number i. Standard C doesn\u2019t support suffixing with \u2018<code>i</code>\u2019 or \u2018<code>j</code>\u2019, so this clunky method is needed.</p> <p>To write a complex constant with a nonzero real part and a nonzero imaginary part, write the two separately and add them, like this:</p> <pre><code>4.0 + 3.0i\n</code></pre> <p>That gives the value 4 + 3i, with type <code>_Complex double</code>.</p> <p>Such a sum can include multiple real constants, or none. Likewise, it can include multiple imaginary constants, or none. For example:</p> <pre><code>_Complex double foo, bar, quux;\n\nfoo = 2.0i + 4.0 + 3.0i; /* Imaginary part is 5.0. */\nbar = 4.0 + 12.0; /* Imaginary part is 0.0. */\nquux = 3.0i + 15.0i; /* Real part is 0.0. */\n</code></pre> <p>See Complex Data Types.</p> <p></p> <p>Next: Character Constants, Previous: Imaginary Constants, Up: Constants \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#125-invalid-numbers","title":"12.5 Invalid Numbers","text":"<p>Some number-like constructs which are not really valid as numeric constants are treated as numbers in preprocessing directives. If these constructs appear outside of preprocessing, they are erroneous. See Preprocessing Tokens.</p> <p>Sometimes we need to insert spaces to separate tokens so that they won\u2019t be combined into a single number-like construct. For example, <code>0xE+12</code> is a preprocessing number that is not a valid numeric constant, so it is a syntax error. If what we want is the three tokens <code>0xE\u00a0+\u00a012</code>, we have to insert two spaces as separators.</p> <p></p> <p>Next: String Constants, Previous: Invalid Numbers, Up: Constants \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#126-character-constants","title":"12.6 Character Constants","text":"<p>A character constant is written with single quotes, as in <code>'``c``'</code>. In the simplest case, <code>c</code> is a single ASCII character that the constant should represent. The constant has type <code>int</code>, and its value is the character code of that character. For instance, <code>'a'</code> represents the character code for the letter \u2018<code>a</code>\u2019: 97, that is.</p> <p>To put the \u2018<code>'</code>\u2019 character (single quote) in the character constant, escape it with a backslash (\u2018<code>\\</code>\u2019). This character constant looks like <code>'\\''</code>. The backslash character here functions as an escape character, and such a sequence, starting with \u2018<code>\\</code>\u2019, is called an escape sequence.</p> <p>To put the \u2018<code>\\</code>\u2019 character (backslash) in the character constant, escape it with \u2018<code>\\</code>\u2019 (another backslash). This character constant looks like <code>'\\\\'</code>.</p> <p> </p> <p>Here are all the escape sequences that represent specific characters in a character constant. The numeric values shown are the corresponding ASCII character codes, as decimal numbers.</p> <pre><code>'\\a' \u21d2 7       /* alarm, CTRL-g */\n'\\b' \u21d2 8       /* backspace, BS, CTRL-h */\n'\\t' \u21d2 9       /* tab, TAB, CTRL-i */\n'\\n' \u21d2 10      /* newline, CTRL-j */\n'\\v' \u21d2 11      /* vertical tab, CTRL-k */\n'\\f' \u21d2 12      /* formfeed, CTRL-l */\n'\\r' \u21d2 13      /* carriage return, RET, CTRL-m */\n'\\e' \u21d2 27      /* escape character, ESC, CTRL-[ */\n'\\\\' \u21d2 92      /* backslash character, \\ */\n'\\'' \u21d2 39      /* single quote character, ' */\n'\\\"' \u21d2 34      /* double quote character, \" */\n'\\?' \u21d2 63      /* question mark, ? */\n</code></pre> <p>\u2018<code>\\e</code>\u2019 is a GNU C extension; to stick to standard C, write \u2018<code>\\33</code>\u2019. (The number after \u2018<code>backslash</code>\u2019 is octal.) To specify a character constant using decimal, use a cast; for instance, <code>(unsigned char) 27</code>.</p> <p>You can also write octal and hex character codes as \u2018<code>\\``octalcode</code>\u2019 or \u2018<code>\\x``hexcode</code>\u2019. Decimal is not an option here, so octal codes do not need to start with \u2018<code>0</code>\u2019.</p> <p>The character constant\u2019s value has type <code>int</code>. However, the character code is treated initially as a <code>char</code> value, which is then converted to <code>int</code>. If the character code is greater than 127 (<code>0177</code> in octal), the resulting <code>int</code> may be negative on a platform where the type <code>char</code> is 8 bits long and signed.</p> <p></p> <p>Next: UTF-8 String Constants, Previous: Character Constants, Up: Constants \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#127-string-constants","title":"12.7 String Constants","text":"<p>A string constant represents a series of characters. It starts with \u2018<code>\"</code>\u2019 and ends with \u2018<code>\"</code>\u2019; in between are the contents of the string. Quoting special characters such as \u2018<code>\"</code>\u2019, \u2018<code>\\</code>\u2019 and newline in the contents works in string constants as in character constants. In a string constant, \u2018<code>'</code>\u2019 does not need to be quoted.</p> <p>A string constant defines an array of characters which contains the specified characters followed by the null character (code 0). Using the string constant is equivalent to using the name of an array with those contents. In simple cases, where there are no backslash escape sequences, the length in bytes of the string constant is one greater than the number of characters written in it.</p> <p>As with any array in C, using the string constant in an expression converts the array to a pointer (see Pointers) to the array\u2019s zeroth element (see Accessing Array Elements). This pointer will have type <code>char *</code> because it points to an element of type <code>char</code>. <code>char *</code> is an example of a type designator for a pointer type (see Pointer Type Designators). That type is used for strings generally, not just the strings expressed as constants in a program.</p> <p>Thus, the string constant <code>\"Foo!\"</code> is almost equivalent to declaring an array like this</p> <pre><code>char string_array_1[] = {'F', 'o', 'o', '!', '\\0' };\n</code></pre> <p>and then using <code>string_array_1</code> in the program. There are two differences, however:</p> <ul> <li>The string constant doesn\u2019t define a name for the array.</li> <li>The string constant is probably stored in a read-only area of     memory.</li> </ul> <p>Newlines are not allowed in the text of a string constant. The motive for this prohibition is to catch the error of omitting the closing \u2018<code>\"</code>\u2019. To put a newline in a constant string, write it as \u2018<code>\\n</code>\u2019 in the string constant.</p> <p>A real null character in the source code inside a string constant causes a warning. To put a null character in the middle of a string constant, write \u2018<code>\\0</code>\u2019 or \u2018<code>\\000</code>\u2019.</p> <p>Consecutive string constants are effectively concatenated. Thus,</p> <pre><code>\"Fo\" \"o!\"   is equivalent to   \"Foo!\"\n</code></pre> <p>This is useful for writing a string containing multiple lines, like this:</p> <pre><code>\"This message is so long that it needs more than\\n\"\n\"a single line of text.  C does not allow a newline\\n\"\n\"to represent itself in a string constant, so we have to\\n\"\n\"write \\\\n to put it in the string.  For readability of\\n\"\n\"the source code, it is advisable to put line breaks in\\n\"\n\"the source where they occur in the contents of the\\n\"\n\"constant.\\n\"\n</code></pre> <p>The sequence of a backslash and a newline is ignored anywhere in a C program, and that includes inside a string constant. Thus, you can write multi-line string constants this way:</p> <pre><code>\"This is another way to put newlines in a string constant\\n\\\nand break the line after them in the source code.\"\n</code></pre> <p>However, concatenation is the recommended way to do this.</p> <p>You can also write perverse string constants like this,</p> <pre><code>\"Fo\\\no!\"\n</code></pre> <p>but don\u2019t do that\u2014write it like this instead:</p> <pre><code>\"Foo!\"\n</code></pre> <p>Be careful to avoid passing a string constant to a function that modifies the string it receives. The memory where the string constant is stored may be read-only, which would cause a fatal <code>SIGSEGV</code> signal that normally terminates the function (see Signals. Even worse, the memory may not be read-only. Then the function might modify the string constant, thus spoiling the contents of other string constants that are supposed to contain the same value and are unified by the compiler.</p> <p></p> <p>Next: Unicode Character Codes, Previous: String Constants, Up: Constants \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#128-utf-8-string-constants","title":"12.8 UTF-8 String Constants","text":"<p>Writing \u2018<code>u8</code>\u2019 immediately before a string constant, with no intervening space, means to represent that string in UTF-8 encoding as a sequence of bytes. UTF-8 represents ASCII characters with a single byte, and represents non-ASCII Unicode characters (codes 128 and up) as multibyte sequences. Here is an example of a UTF-8 constant:</p> <pre><code>u8\"A c\u00f3nst\u00e0\u00f1t\"\n</code></pre> <p>This constant occupies 13 bytes plus the terminating null, because each of the accented letters is a two-byte sequence.</p> <p>Concatenating an ordinary string with a UTF-8 string conceptually produces another UTF-8 string. However, if the ordinary string contains character codes 128 and up, the results cannot be relied on.</p> <p></p> <p>Next: Wide Character Constants, Previous: UTF-8 String Constants, Up: Constants \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#129-unicode-character-codes","title":"12.9 Unicode Character Codes","text":"<p>You can specify Unicode characters, for individual character constants or as part of string constants (see String Constants), using escape sequences; and even in C identifiers. Use the \u2018<code>\\u</code>\u2019 escape sequence with a 16-bit hexadecimal Unicode character code. If the code value is too big for 16 bits, use the \u2018<code>\\U</code>\u2019 escape sequence with a 32-bit hexadecimal Unicode character code. (These codes are called universal character names.) For example,</p> <pre><code>\\u6C34      /* 16-bit code (UTF-16) */\n\\U0010ABCD  /* 32-bit code (UTF-32) */\n</code></pre> <p>One way to use these is in UTF-8 string constants (see UTF-8 String Constants). For instance,</p> <pre><code>u8\"f\u00f3\u00f3 \\u6C34 \\U0010ABCD\"\n</code></pre> <p>You can also use them in wide character constants (see Wide Character Constants), like this:</p> <pre><code>u'\\u6C34'      /* 16-bit code */\nU'\\U0010ABCD'  /* 32-bit code */\n</code></pre> <p>and in wide string constants (see Wide String Constants), like this:</p> <pre><code>u\"\\u6C34\\u6C33\"  /* 16-bit code */\nU\"\\U0010ABCD\"    /* 32-bit code */\n</code></pre> <p>And in an identifier:</p> <pre><code>int foo\\u6C34bar = 0;\n</code></pre> <p>Codes in the range of <code>D800</code> through <code>DFFF</code> are not valid in Unicode. Codes less than <code>00A0</code> are also forbidden, except for <code>0024</code>, <code>0040</code>, and <code>0060</code>; these characters are actually ASCII control characters, and you can specify them with other escape sequences (see Character Constants).</p> <p></p> <p>Next: Wide String Constants, Previous: Unicode Character Codes, Up: Constants \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1210-wide-character-constants","title":"12.10 Wide Character Constants","text":"<p>A wide character constant represents characters with more than 8 bits of character code. This is an obscure feature that we need to document but that you probably won\u2019t ever use. If you\u2019re just learning C, you may as well skip this section.</p> <p>The original C wide character constant looks like \u2018<code>L</code>\u2019 (upper case!) followed immediately by an ordinary character constant (with no intervening space). Its data type is <code>wchar_t</code>, which is an alias defined in <code>stddef.h</code> for one of the standard integer types. Depending on the platform, it could be 16 bits or 32 bits. If it is 16 bits, these character constants use the UTF-16 form of Unicode; if 32 bits, UTF-32.</p> <p>There are also Unicode wide character constants which explicitly specify the width. These constants start with \u2018<code>u</code>\u2019 or \u2018<code>U</code>\u2019 instead of \u2018<code>L</code>\u2019. \u2018<code>u</code>\u2019 specifies a 16-bit Unicode wide character constant, and \u2018<code>U</code>\u2019 a 32-bit Unicode wide character constant. Their types are, respectively, <code>char16_t</code> and <code>char32_t</code>; they are declared in the header file <code>uchar.h</code>. These character constants are valid even if <code>uchar.h</code> is not included, but some uses of them may be inconvenient without including it to declare those type names.</p> <p>The character represented in a wide character constant can be an ordinary ASCII character. <code>L'a'</code>, <code>u'a'</code> and <code>U'a'</code> are all valid, and they are all equal to <code>'a'</code>.</p> <p>In all three kinds of wide character constants, you can write a non-ASCII Unicode character in the constant itself; the constant\u2019s value is the character\u2019s Unicode character code. Or you can specify the Unicode character with an escape sequence (see Unicode Character Codes).</p> <p></p> <p>Previous: Wide Character Constants, Up: Constants \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1211-wide-string-constants","title":"12.11 Wide String Constants","text":"<p>A wide string constant stands for an array of 16-bit or 32-bit characters. They are rarely used; if you\u2019re just learning C, you may as well skip this section.</p> <p>There are three kinds of wide string constants, which differ in the data type used for each character in the string. Each wide string constant is equivalent to an array of integers, but the data type of those integers depends on the kind of wide string. Using the constant in an expression will convert the array to a pointer to its zeroth element, as usual for arrays in C (see Accessing Array Elements). For each kind of wide string constant, we state here what type that pointer will be.</p> <p><code>char16_t</code> This is a 16-bit Unicode wide string constant: each element is a 16-bit Unicode character code with type <code>char16_t</code>, so the string has the pointer type <code>char16_t\u00a0*</code>. (That is a type designator; see Pointer Type Designators.) The constant is written as \u2018<code>u</code>\u2019 (which must be lower case) followed (with no intervening space) by a string constant with the usual syntax.</p> <p><code>char32_t</code> This is a 32-bit Unicode wide string constant: each element is a 32-bit Unicode character code, and the string has type <code>char32_t\u00a0*</code>. It\u2019s written as \u2018<code>U</code>\u2019 (which must be upper case) followed (with no intervening space) by a string constant with the usual syntax.</p> <p><code>wchar_t</code> This is the original kind of wide string constant. It\u2019s written as \u2018<code>L</code>\u2019 (which must be upper case) followed (with no intervening space) by a string constant with the usual syntax, and the string has type <code>wchar_t\u00a0*</code>.</p> <p>The width of the data type <code>wchar_t</code> depends on the target platform, which makes this kind of wide string somewhat less useful than the newer kinds.</p> <p><code>char16_t</code> and <code>char32_t</code> are declared in the header file <code>uchar.h</code>. <code>wchar_t</code> is declared in <code>stddef.h</code>.</p> <p>Consecutive wide string constants of the same kind concatenate, just like ordinary string constants. A wide string constant concatenated with an ordinary string constant results in a wide string constant. You can\u2019t concatenate two wide string constants of different kinds. In addition, you can\u2019t concatenate a wide string constant (of any kind) with a UTF-8 string constant.</p> <p></p> <p>Next: Pointers, Previous: Constants, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#13-type-size","title":"13 Type Size","text":"<p>Each data type has a size, which is the number of bytes (see Storage) that it occupies in memory. To refer to the size in a C program, use <code>sizeof</code>. There are two ways to use it:</p> <p><code>sizeof ``expression</code> This gives the size of <code>expression</code>, based on its data type. It does not calculate the value of <code>expression</code>, only its size, so if <code>expression</code> includes side effects or function calls, they do not happen. Therefore, <code>sizeof</code> is always a compile-time operation that has zero run-time cost.</p> <p>A value that is a bit field (see Bit Fields) is not allowed as an operand of <code>sizeof</code>.</p> <p>For example,</p> <pre><code>double a;\n\ni = sizeof a + 10;\n</code></pre> <p>sets <code>i</code> to 18 on most computers because <code>a</code> occupies 8 bytes.</p> <p>Here\u2019s how to determine the number of elements in an array <code>array</code>:</p> <pre><code>(sizeof array / sizeof array[0])\n</code></pre> <p>The expression <code>sizeof array</code> gives the size of the array, not the size of a pointer to an element. However, if <code>expression</code> is a function parameter that was declared as an array, that variable really has a pointer type (see Array Parm Pointer), so the result is the size of that pointer.</p> <p><code>sizeof (``type``)</code> This gives the size of <code>type</code>. For example,</p> <pre><code>i = sizeof (double) + 10;\n</code></pre> <p>is equivalent to the previous example.</p> <p>You can\u2019t apply <code>sizeof</code> to an incomplete type (see Incomplete Types), nor <code>void</code>. Using it on a function type gives 1 in GNU C, which makes adding an integer to a function pointer work as desired (see Pointer Arithmetic).</p> <p>Warning: When you use <code>sizeof</code> with a type instead of an expression, you must write parentheses around the type.</p> <p>Warning: When applying <code>sizeof</code> to the result of a cast (see Explicit Type Conversion), you must write parentheses around the cast expression to avoid an ambiguity in the grammar of C. Specifically,</p> <pre><code>sizeof (int) -x\n</code></pre> <p>parses as</p> <pre><code>(sizeof (int)) - x\n</code></pre> <p>If what you want is</p> <pre><code>sizeof ((int) -x)\n</code></pre> <p>you must write it that way, with parentheses.</p> <p>The data type of the value of the <code>sizeof</code> operator is always one of the unsigned integer types; which one of those types depends on the machine. The header file <code>stddef.h</code> defines the typedef name <code>size_t</code> as an alias for this type. See Defining Typedef Names.</p> <p></p> <p>Next: Structures, Previous: Type Size, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#14-pointers","title":"14 Pointers","text":"<p>Among high-level languages, C is rather low-level, close to the machine. This is mainly because it has explicit pointers. A pointer value is the numeric address of data in memory. The type of data to be found at that address is specified by the data type of the pointer itself. Nothing in C can determine the \u201ccorrect\u201d data type of data in memory; it can only blindly follow the data type of the pointer you use to access the data.</p> <p>The unary operator \u2018<code>*</code>\u2019 gets the data that a pointer points to\u2014this is called dereferencing the pointer. Its value always has the type that the pointer points to.</p> <p>C also allows pointers to functions, but since there are some differences in how they work, we treat them later. See Function Pointers.</p> \u2022 Address of Data Using the \u201caddress-of\u201d operator. \u2022 Pointer Types For each type, there is a pointer type. \u2022 Pointer Declarations Declaring variables with pointer types. \u2022 Pointer Type Designators Designators for pointer types. \u2022 Pointer Dereference Accessing what a pointer points at. \u2022 Null Pointers Pointers which do not point to any object. \u2022 Invalid Dereference Dereferencing null or invalid pointers. \u2022 Void Pointers Totally generic pointers, can cast to any. \u2022 Pointer Comparison Comparing memory address values. \u2022 Pointer Arithmetic Computing memory address values. \u2022 Pointers and Arrays Using pointer syntax instead of array syntax. \u2022 Low-Level Pointer Arithmetic More about computing memory address values. \u2022 Pointer Increment/Decrement Incrementing and decrementing pointers. \u2022 Pointer Arithmetic Drawbacks A common pointer bug to watch out for. \u2022 Pointer-Integer Conversion Converting pointer types to integer types. \u2022 Printing Pointers Using <code>printf</code> for a pointer\u2019s value. <p></p> <p>Next: Pointer Types, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#141-address-of-data","title":"14.1 Address of Data","text":"<p>The most basic way to make a pointer is with the \u201caddress-of\u201d operator, \u2018<code>&amp;</code>\u2019. Let\u2019s suppose we have these variables available:</p> <pre><code>int i;\ndouble a[5];\n</code></pre> <p>Now, <code>&amp;i</code> gives the address of the variable <code>i</code>\u2014a pointer value that points to <code>i</code>\u2019s location\u2014and <code>&amp;a[3]</code> gives the address of the element 3 of <code>a</code>. (By the usual 1-origin numbering convention of ordinary English, it is actually the fourth element in the array, since the element at the start has index 0.)</p> <p>The address-of operator is unusual because it operates on a place to store a value (an lvalue, see Lvalues), not on the value currently stored there. (The left argument of a simple assignment is unusual in the same way.) You can use it on any lvalue except a bit field (see Bit Fields) or a constructor (see Structure Constructors).</p> <p></p> <p>Next: Pointer Declarations, Previous: Address of Data, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#142-pointer-types","title":"14.2 Pointer Types","text":"<p>For each data type <code>t</code>, there is a type for pointers to type <code>t</code>. For these variables,</p> <pre><code>int i;\ndouble a[5];\n</code></pre> <ul> <li><code>i</code> has type <code>int</code>; we say <code>&amp;i</code> is a \u201cpointer to <code>int</code>.\u201d</li> <li><code>a</code> has type <code>double[5]</code>; we say <code>&amp;a</code> is a \u201cpointer to arrays of     five <code>double</code>s.\u201d</li> <li><code>a[3]</code> has type <code>double</code>; we say <code>&amp;a[3]</code> is a \u201cpointer to <code>double</code>.\u201d</li> </ul> <p></p> <p>Next: Pointer Type Designators, Previous: Pointer Types, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#143-pointer-variable-declarations","title":"14.3 Pointer-Variable Declarations","text":"<p>The way to declare that a variable <code>foo</code> points to type <code>t</code> is</p> <pre><code>t *foo;\n</code></pre> <p>To remember this syntax, think \u201cif you dereference <code>foo</code>, using the \u2018<code>*</code>\u2019 operator, what you get is type <code>t</code>. Thus, <code>foo</code> points to type <code>t</code>.\u201d</p> <p>Thus, we can declare variables that hold pointers to these three types, like this:</p> <pre><code>int *ptri;            /* Pointer to int. */\ndouble *ptrd;         /* Pointer to double. */\ndouble (*ptrda)[5];   /* Pointer to double[5]. */\n</code></pre> <p>\u2018<code>int *ptri;</code>\u2019 means, \u201cif you dereference <code>ptri</code>, you get an <code>int</code>.\u201d \u2018<code>double (*ptrda)[5];</code>\u2019 means, \u201cif you dereference <code>ptrda</code>, then subscript it by an integer less than 5, you get a <code>double</code>.\u201d The parentheses express the point that you would dereference it first, then subscript it.</p> <p>Contrast the last one with this:</p> <pre><code>double *aptrd[5];     /* Array of five pointers to double. */\n</code></pre> <p>Because \u2018<code>*</code>\u2019 has lower syntactic precedence than subscripting, \u2018<code>double *aptrd[5]</code>\u2019 means, \u201cif you subscript <code>aptrd</code> by an integer less than 5, then dereference it, you get a <code>double</code>.\u201d Therefore, <code>*aptrd[5]</code> declares an array of pointers, not a pointer to an array.</p> <p></p> <p>Next: Pointer Dereference, Previous: Pointer Declarations, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#144-pointer-type-designators","title":"14.4 Pointer-Type Designators","text":"<p>Every type in C has a designator; you make it by deleting the variable name and the semicolon from a declaration (see Type Designators). Here are the designators for the pointer types of the example declarations in the previous section:</p> <pre><code>int *           /* Pointer to int. */\ndouble *        /* Pointer to double. */\ndouble (*)[5]   /* Pointer to double[5]. */\n</code></pre> <p>Remember, to understand what type a designator stands for, imagine the corresponding variable declaration with a variable name in it, and figure out what type that variable would have. Thus, the type designator <code>double (*)[5]</code> corresponds to the variable declaration <code>double (*``variable``)[5]</code>. That declares a pointer variable which, when dereferenced, gives an array of 5 <code>double</code>s. So the type designator means, \u201cpointer to an array of 5 <code>double</code>s.\u201d</p> <p></p> <p>Next: Null Pointers, Previous: Pointer Type Designators, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#145-dereferencing-pointers","title":"14.5 Dereferencing Pointers","text":"<p>The main use of a pointer value is to dereference it (access the data it points at) with the unary \u2018<code>*</code>\u2019 operator. For instance, <code>*&amp;i</code> is the value at <code>i</code>\u2019s address\u2014which is just <code>i</code>. The two expressions are equivalent, provided <code>&amp;i</code> is valid.</p> <p>A pointer-dereference expression whose type is data (not a function) is an lvalue.</p> <p>Pointers become really useful when we store them somewhere and use them later. Here\u2019s a simple example to illustrate the practice:</p> <pre><code>{\n  int i;\n  int *ptr;\n\n  ptr = &amp;i;\n\n  i = 5;\n\n  \u2026\n\n  return *ptr;   /* Returns 5, fetched from i.  */\n}\n</code></pre> <p>This shows how to declare the variable <code>ptr</code> as type <code>int *</code> (pointer to <code>int</code>), store a pointer value into it (pointing at <code>i</code>), and use it later to get the value of the object it points at (the value in <code>i</code>).</p> <p>If anyone can provide a useful example which is this basic, I would be grateful.</p> <p></p> <p>Next: Invalid Dereference, Previous: Pointer Dereference, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#146-null-pointers","title":"14.6 Null Pointers","text":"<p>A pointer value can be null, which means it does not point to any object. The cleanest way to get a null pointer is by writing <code>NULL</code>, a standard macro defined in <code>stddef.h</code>. You can also do it by casting 0 to the desired pointer type, as in <code>(char *) 0</code>. (The cast operator performs explicit type conversion; See Explicit Type Conversion.)</p> <p>You can store a null pointer in any lvalue whose data type is a pointer type:</p> <pre><code>char *foo;\nfoo = NULL;\n</code></pre> <p>These two, if consecutive, can be combined into a declaration with initializer,</p> <pre><code>char *foo = NULL;\n</code></pre> <p>You can also explicitly cast <code>NULL</code> to the specific pointer type you want\u2014it makes no difference.</p> <pre><code>char *foo;\nfoo = (char *) NULL;\n</code></pre> <p>To test whether a pointer is null, compare it with zero or <code>NULL</code>, as shown here:</p> <pre><code>if (p != NULL)\n  /* p is not null.  */\n  operate (p);\n</code></pre> <p>Since testing a pointer for not being null is basic and frequent, all but beginners in C will understand the conditional without need for <code>!= NULL</code>:</p> <pre><code>if (p)\n  /* p is not null.  */\n  operate (p);\n</code></pre> <p></p> <p>Next: Void Pointers, Previous: Null Pointers, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#147-dereferencing-null-or-invalid-pointers","title":"14.7 Dereferencing Null or Invalid Pointers","text":"<p>Trying to dereference a null pointer is an error. On most platforms, it generally causes a signal, usually <code>SIGSEGV</code> (see Signals).</p> <pre><code>char *foo = NULL;\nc = *foo;    /* This causes a signal and terminates.  */\n</code></pre> <p>Likewise a pointer that has the wrong alignment for the target data type (on most types of computer), or points to a part of memory that has not been allocated in the process\u2019s address space.</p> <p>The signal terminates the program, unless the program has arranged to handle the signal (see The GNU C Library in The GNU C Library Reference Manual).</p> <p>However, the signal might not happen if the dereference is optimized away. In the example above, if you don\u2019t subsequently use the value of <code>c</code>, GCC might optimize away the code for <code>*foo</code>. You can prevent such optimization using the <code>volatile</code> qualifier, as shown here:</p> <pre><code>volatile char *p;\nvolatile char c;\nc = *p;\n</code></pre> <p>You can use this to test whether <code>p</code> points to unallocated memory. Set up a signal handler first, so the signal won\u2019t terminate the program.</p> <p></p> <p>Next: Pointer Comparison, Previous: Invalid Dereference, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#148-void-pointers","title":"14.8 Void Pointers","text":"<p>The peculiar type <code>void *</code>, a pointer whose target type is <code>void</code>, is used often in C. It represents a pointer to we-don\u2019t-say-what. Thus,</p> <pre><code>void *numbered_slot_pointer (int);\n</code></pre> <p>declares a function <code>numbered_slot_pointer</code> that takes an integer parameter and returns a pointer, but we don\u2019t say what type of data it points to.</p> <p>The functions for dynamic memory allocation (see Dynamic Memory Allocation) use type <code>void *</code> to refer to blocks of memory, regardless of what sort of data the program stores in those blocks.</p> <p>With type <code>void *</code>, you can pass the pointer around and test whether it is null. However, dereferencing it gives a <code>void</code> value that can\u2019t be used (see The Void Type). To dereference the pointer, first convert it to some other pointer type.</p> <p>Assignments convert <code>void *</code> automatically to any other pointer type, if the left operand has a pointer type; for instance,</p> <pre><code>{\n  int *p;\n  /* Converts return value to int *.  */\n  p = numbered_slot_pointer (5);\n  \u2026\n}\n</code></pre> <p>Passing an argument of type <code>void *</code> for a parameter that has a pointer type also converts. For example, supposing the function <code>hack</code> is declared to require type <code>float *</code> for its parameter, this call to <code>hack</code> will convert the argument to that type.</p> <pre><code>/* Declare hack that way.\n   We assume it is defined somewhere else.  */\nvoid hack (float *);\n\u2026\n/* Now call hack.  */\n{\n  /* Converts return value of numbered_slot_pointer\n     to float * to pass it to hack.  */\n  hack (numbered_slot_pointer (5));\n  \u2026\n}\n</code></pre> <p>You can also convert to another pointer type with an explicit cast (see Explicit Type Conversion), like this:</p> <pre><code>(int *) numbered_slot_pointer (5)\n</code></pre> <p>Here is an example which decides at run time which pointer type to convert to:</p> <pre><code>void\nextract_int_or_double (void *ptr, bool its_an_int)\n{\n  if (its_an_int)\n    handle_an_int (*(int *)ptr);\n  else\n    handle_a_double (*(double *)ptr);\n}\n</code></pre> <p>The expression <code>*(int *)ptr</code> means to convert <code>ptr</code> to type <code>int *</code>, then dereference it.</p> <p></p> <p>Next: Pointer Arithmetic, Previous: Void Pointers, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#149-pointer-comparison","title":"14.9 Pointer Comparison","text":"<p>Two pointer values are equal if they point to the same location, or if they are both null. You can test for this with <code>==</code> and <code>!=</code>. Here\u2019s a trivial example:</p> <pre><code>{\n  int i;\n  int *p, *q;\n\n  p = &amp;i;\n  q = &amp;i;\n  if (p == q)\n    printf (\"This will be printed.\\n\");\n  if (p != q)\n    printf (\"This won't be printed.\\n\");\n}\n</code></pre> <p>Ordering comparisons such as <code>&gt;</code> and <code>&gt;=</code> operate on pointers by converting them to unsigned integers. The C standard says the two pointers must point within the same object in memory, but on GNU/Linux systems these operations simply compare the numeric values of the pointers.</p> <p>The pointer values to be compared should in principle have the same type, but they are allowed to differ in limited cases. First of all, if the two pointers\u2019 target types are nearly compatible (see Compatible Types), the comparison is allowed.</p> <p>If one of the operands is <code>void *</code> (see Void Pointers) and the other is another pointer type, the comparison operator converts the <code>void *</code> pointer to the other type so as to compare them. (In standard C, this is not allowed if the other type is a function pointer type, but it works in GNU C.)</p> <p>Comparison operators also allow comparing the integer 0 with a pointer value. This works by converting 0 to a null pointer of the same type as the other operand.</p> <p></p> <p>Next: Pointers and Arrays, Previous: Pointer Comparison, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1410-pointer-arithmetic","title":"14.10 Pointer Arithmetic","text":"<p>Adding an integer (positive or negative) to a pointer is valid in C. It assumes that the pointer points to an element in an array, and advances or retracts the pointer across as many array elements as the integer specifies. Here is an example, in which adding a positive integer advances the pointer to a later element in the same array.</p> <pre><code>void\nincrementing_pointers ()\n{\n  int array[5] = { 45, 29, 104, -3, 123456 };\n  int elt0, elt1, elt4;\n\n  int *p = &amp;array[0];\n  /* Now p points at element 0.  Fetch it.  */\n  elt0 = *p;\n\n  ++p;\n  /* Now p points at element 1.  Fetch it.  */\n  elt1 = *p;\n\n  p += 3;\n  /* Now p points at element 4 (the last).  Fetch it.  */\n  elt4 = *p;\n\n  printf (\"elt0 %d  elt1 %d  elt4 %d.\\n\",\n          elt0, elt1, elt4);\n  /* Prints elt0 45  elt1 29  elt4 123456.  */\n}\n</code></pre> <p>Here\u2019s an example where adding a negative integer retracts the pointer to an earlier element in the same array.</p> <pre><code>void\ndecrementing_pointers ()\n{\n  int array[5] = { 45, 29, 104, -3, 123456 };\n  int elt0, elt3, elt4;\n\n  int *p = &amp;array[4];\n  /* Now p points at element 4 (the last).  Fetch it.  */\n  elt4 = *p;\n\n  --p;\n  /* Now p points at element 3.  Fetch it.  */\n  elt3 = *p;\n\n  p -= 3;\n  /* Now p points at element 0.  Fetch it.  */\n  elt0 = *p;\n\n  printf (\"elt0 %d  elt3 %d  elt4 %d.\\n\",\n          elt0, elt3, elt4);\n  /* Prints elt0 45  elt3 -3  elt4 123456.  */\n}\n</code></pre> <p>If one pointer value was made by adding an integer to another pointer value, it should be possible to subtract the pointer values and recover that integer. That works too in C.</p> <pre><code>void\nsubtract_pointers ()\n{\n  int array[5] = { 45, 29, 104, -3, 123456 };\n  int *p0, *p3, *p4;\n\n  int *p = &amp;array[4];\n  /* Now p points at element 4 (the last).  Save the value.  */\n  p4 = p;\n\n  --p;\n  /* Now p points at element 3.  Save the value.  */\n  p3 = p;\n\n  p -= 3;\n  /* Now p points at element 0.  Save the value.  */\n  p0 = p;\n\n  printf (\"%d, %d, %d, %d\\n\",\n          p4 - p0, p0 - p0, p3 - p0, p0 - p3);\n  /* Prints 4, 0, 3, -3.  */\n}\n</code></pre> <p>The addition operation does not know where arrays begin or end in memory. All it does is add the integer (multiplied by target object size) to the numeric value of the pointer. When the initial pointer and the result point into the same array, the result is well-defined.</p> <p>Warning: Only experts should do pointer arithmetic involving pointers into different memory objects.</p> <p>The difference between two pointers has type <code>int</code>, or <code>long</code> if necessary (see Integer Types). The clean way to declare it is to use the typedef name <code>ptrdiff_t</code> defined in the file <code>stddef.h</code>.</p> <p>C defines pointer subtraction to be consistent with pointer-integer addition, so that <code>(p3 - p1) + p1</code> equals <code>p3</code>, as in ordinary algebra. Pointer subtraction works by subtracting <code>p1</code>\u2019s numeric value from <code>p3</code>\u2019s, and dividing by target object size. The two pointer arguments should point into the same array.</p> <p>In standard C, addition and subtraction are not allowed on <code>void *</code>, since the target type\u2019s size is not defined in that case. Likewise, they are not allowed on pointers to function types. However, these operations work in GNU C, and the \u201csize of the target type\u201d is taken as 1 byte.</p> <p></p> <p>Next: Low-Level Pointer Arithmetic, Previous: Pointer Arithmetic, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1411-pointers-and-arrays","title":"14.11 Pointers and Arrays","text":"<p>The clean way to refer to an array element is <code>array``[``index``]</code>. Another, complicated way to do the same job is to get the address of that element as a pointer, then dereference it: <code>* (&amp;``array``[0] + ``index``)</code> (or equivalently <code>* (``array`` + ``index``)</code>). This first gets a pointer to element zero, then increments it with <code>+</code> to point to the desired element, then gets the value from there.</p> <p>That pointer-arithmetic construct is the definition of square brackets in C. <code>a``[``b``]</code> means, by definition, <code>*(``a`` + ``b``)</code>. This definition uses <code>a</code> and <code>b</code> symmetrically, so one must be a pointer and the other an integer; it does not matter which comes first.</p> <p>Since indexing with square brackets is defined in terms of addition and dereferencing, that too is symmetrical. Thus, you can write <code>3[array]</code> and it is equivalent to <code>array[3]</code>. However, it would be foolish to write <code>3[array]</code>, since it has no advantage and could confuse people who read the code.</p> <p>It may seem like a discrepancy that the definition <code>*(``a`` + ``b``)</code> requires a pointer, while <code>array[3]</code> uses an array value instead. Why is this valid? The name of the array, when used by itself as an expression (other than in <code>sizeof</code>), stands for a pointer to the array\u2019s zeroth element. Thus, <code>array + 3</code> converts <code>array</code> implicitly to <code>&amp;array[0]</code>, and the result is a pointer to element 3, equivalent to <code>&amp;array[3]</code>.</p> <p>Since square brackets are defined in terms of such an addition, <code>array[3]</code> first converts <code>array</code> to a pointer. That\u2019s why it works to use an array directly in that construct.</p> <p></p> <p>Next: Pointer Increment/Decrement, Previous: Pointers and Arrays, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1412-pointer-arithmetic-at-low-level","title":"14.12 Pointer Arithmetic at Low-Level","text":"<p>The behavior of pointer arithmetic is theoretically defined only when the pointer values all point within one object allocated in memory. But the addition and subtraction operators can\u2019t tell whether the pointer values are all within one object. They don\u2019t know where objects start and end. So what do they really do?</p> <p>Adding pointer <code>p</code> to integer <code>i</code> treats <code>p</code> as a memory address, which is in fact an integer\u2014call it <code>pint</code>. It treats <code>i</code> as a number of elements of the type that <code>p</code> points to. These elements\u2019 sizes add up to <code>i`` * sizeof (*``p``)</code>. So the sum, as an integer, is <code>pint`` + ``i`` * sizeof (*``p``)</code>. This value is reinterpreted as a pointer of the same type as <code>p</code>.</p> <p>If the starting pointer value <code>p</code> and the result do not point at parts of the same object, the operation is not officially legitimate, and C code is not \u201csupposed\u201d to do it. But you can do it anyway, and it gives precisely the results described by the procedure above. In some special situations it can do something useful, but non-wizards should avoid it.</p> <p>Here\u2019s a function to offset a pointer value as if it pointed to an object of any given size, by explicitly performing that calculation:</p> <pre><code>#include &lt;stdint.h&gt;\n\nvoid *\nptr_add (void *p, int i, int objsize)\n{\n  intptr_t p_address = (long) p;\n  intptr_t totalsize = i * objsize;\n  intptr_t new_address = p_address + totalsize;\n  return (void *) new_address;\n}\n</code></pre> <p> This does the same job as <code>p`` + ``i</code> with the proper pointer type for <code>p</code>. It uses the type <code>intptr_t</code>, which is defined in the header file <code>stdint.h</code>. (In practice, <code>long long</code> would always work, but it is cleaner to use <code>intptr_t</code>.)</p> <p></p> <p>Next: Pointer Arithmetic Drawbacks, Previous: Low-Level Pointer Arithmetic, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1413-pointer-increment-and-decrement","title":"14.13 Pointer Increment and Decrement","text":"<p>The \u2018<code>++</code>\u2019 operator adds 1 to a variable. We have seen it for integers (see Increment/Decrement), but it works for pointers too. For instance, suppose we have a series of positive integers, terminated by a zero, and we want to add them up. Here is a simple way to step forward through the array by advancing a pointer.</p> <pre><code>int\nsum_array_till_0 (int *p)\n{\n  int sum = 0;\n\n  for (;;)\n    {\n      /* Fetch the next integer.  */\n      int next = *p++;\n      /* Exit the loop if it\u2019s 0.  */\n      if (next == 0)\n        break;\n      /* Add it into running total.  */\n      sum += next;\n    }\n\n  return sum;\n}\n</code></pre> <p>The statement \u2018<code>break;</code>\u2019 will be explained further on (see break Statement). Used in this way, it immediately exits the surrounding <code>for</code> statement.</p> <p><code>*p++</code> uses postincrement (<code>++</code>; see Postincrement/Postdecrement) on the pointer <code>p</code>. that expression parses as <code>*(p++)</code>, because a postfix operator always takes precedence over a prefix operator. Therefore, it dereferences the entering value of <code>p</code>, then increments <code>p</code> afterwards.</p> <p>Incrementing a variable means adding 1 to it, as in <code>p = p + 1</code>. Since <code>p</code> is a pointer, adding 1 to it advances it by the width of the datum it points to\u2014in this case, <code>sizeof (int)</code>. Therefore, each iteration of the loop picks up the next integer from the series and puts it into <code>next</code>.</p> <p>This <code>for</code>-loop has no initialization expression since <code>p</code> and <code>sum</code> are already initialized, has no end-test since the \u2018<code>break;</code>\u2019 statement will exit it, and needs no expression to advance it since that\u2019s done within the loop by incrementing <code>p</code> and <code>sum</code>. Thus, those three expressions after <code>for</code> are left empty.</p> <p>Another way to write this function is by keeping the parameter value unchanged and using indexing to access the integers in the table.</p> <pre><code>int\nsum_array_till_0_indexing (int *p)\n{\n  int i;\n  int sum = 0;\n\n  for (i = 0; ; i++)\n    {\n      /* Fetch the next integer.  */\n      int next = p[i];\n      /* Exit the loop if it\u2019s 0.  */\n      if (next == 0)\n        break;\n      /* Add it into running total.  */\n      sum += next;\n    }\n\n  return sum;\n}\n</code></pre> <p>In this program, instead of advancing <code>p</code>, we advance <code>i</code> and add it to <code>p</code>. (Recall that <code>p[i]</code> means <code>*(p + i)</code>.) Either way, it uses the same address to get the next integer.</p> <p>It makes no difference in this program whether we write <code>i++</code> or <code>++i</code>, because the value of that expression is not used. We use it for its effect, to increment <code>i</code>.</p> <p>The \u2018<code>--</code>\u2019 operator also works on pointers; it can be used to step backwards through an array, like this:</p> <pre><code>int\nafter_last_nonzero (int *p, int len)\n{\n  /* Set up q to point just after the last array element.  */\n  int *q = p + len;\n\n  while (q != p)\n    /* Step q back until it reaches a nonzero element.  */\n    if (*--q != 0)\n      /* Return the index of the element after that nonzero.  */\n      return q - p + 1;\n\n  return 0;\n}\n</code></pre> <p>That function returns the length of the nonzero part of the array specified by its arguments; that is, the index of the first zero of the run of zeros at the end.</p> <p></p> <p>Next: Pointer-Integer Conversion, Previous: Pointer Increment/Decrement, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1414-drawbacks-of-pointer-arithmetic","title":"14.14 Drawbacks of Pointer Arithmetic","text":"<p>Pointer arithmetic is clean and elegant, but it is also the cause of a major security flaw in the C language. Theoretically, it is only valid to adjust a pointer within one object allocated as a unit in memory. However, if you unintentionally adjust a pointer across the bounds of the object and into some other object, the system has no way to detect this error.</p> <p>A bug which does that can easily result in clobbering (overwriting) part of another object. For example, with <code>array[-1]</code> you can read or write the nonexistent element before the beginning of an array\u2014probably part of some other data.</p> <p>Combining pointer arithmetic with casts between pointer types, you can create a pointer that fails to be properly aligned for its type. For example,</p> <pre><code>int a[2];\nchar *pa = (char *)a;\nint *p = (int *)(pa + 1);\n</code></pre> <p>gives <code>p</code> a value pointing to an \u201cinteger\u201d that includes part of <code>a[0]</code> and part of <code>a[1]</code>. Dereferencing that with <code>*p</code> can cause a fatal <code>SIGSEGV</code> signal or it can return the contents of that badly aligned <code>int</code> (see Signals. If it \u201cworks,\u201d it may be quite slow. It can also cause aliasing confusions (see Aliasing).</p> <p>Warning: Using improperly aligned pointers is risky\u2014don\u2019t do it unless it is really necessary.</p> <p></p> <p>Next: Printing Pointers, Previous: Pointer Arithmetic Drawbacks, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1415-pointer-integer-conversion","title":"14.15 Pointer-Integer Conversion","text":"<p>On modern computers, an address is simply a number. It occupies the same space as some size of integer. In C, you can convert a pointer to the appropriate integer types and vice versa, without losing information. The appropriate integer types are <code>uintptr_t</code> (an unsigned type) and <code>intptr_t</code> (a signed type). Both are defined in <code>stdint.h</code>.</p> <p>For instance,</p> <pre><code>#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid\nprint_pointer (void *ptr)\n{\n  uintptr_t converted = (uintptr_t) ptr;\n\n  printf (\"Pointer value is 0x%x\\n\",\n          (unsigned int) converted);\n}\n</code></pre> <p>The specification \u2018<code>%x</code>\u2019 in the template (the first argument) for <code>printf</code> means to represent this argument using hexadecimal notation. It\u2019s cleaner to use <code>uintptr_t</code>, since hexadecimal printing treats the number as unsigned, but it won\u2019t actually matter: all <code>printf</code> gets to see is the series of bits in the number.</p> <p>Warning: Converting pointers to integers is risky\u2014don\u2019t do it unless it is really necessary.</p> <p></p> <p>Previous: Pointer-Integer Conversion, Up: Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1416-printing-pointers","title":"14.16 Printing Pointers","text":"<p>To print the numeric value of a pointer, use the \u2018<code>%p</code>\u2019 specifier. For example:</p> <pre><code>void\nprint_pointer (void *ptr)\n{\n  printf (\"Pointer value is %p\\n\", ptr);\n}\n</code></pre> <p>The specification \u2018<code>%p</code>\u2019 works with any pointer type. It prints \u2018<code>0x</code>\u2019 followed by the address in hexadecimal, printed as the appropriate unsigned integer type.</p> <p></p> <p>Next: Arrays, Previous: Pointers, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#15-structures","title":"15 Structures","text":"<p>A structure is a user-defined data type that holds various fields of data. Each field has a name and a data type specified in the structure\u2019s definition.</p> <p>Here we define a structure suitable for storing a linked list of integers. Each list item will hold one integer, plus a pointer to the next item.</p> <pre><code>struct intlistlink\n  {\n    int datum;\n    struct intlistlink *next;\n  };\n</code></pre> <p>The structure definition has a type tag so that the code can refer to this structure. The type tag here is <code>intlistlink</code>. The definition refers recursively to the same structure through that tag.</p> <p>You can define a structure without a type tag, but then you can\u2019t refer to it again. That is useful only in some special contexts, such as inside a <code>typedef</code> or a <code>union</code>.</p> <p>The contents of the structure are specified by the field declarations inside the braces. Each field in the structure needs a declaration there. The fields in one structure definition must have distinct names, but these names do not conflict with any other names in the program.</p> <p>A field declaration looks just like a variable declaration. You can combine field declarations with the same beginning, just as you can combine variable declarations.</p> <p>This structure has two fields. One, named <code>datum</code>, has type <code>int</code> and will hold one integer in the list. The other, named <code>next</code>, is a pointer to another <code>struct intlistlink</code> which would be the rest of the list. In the last list item, it would be <code>NULL</code>.</p> <p>This structure definition is recursive, since the type of the <code>next</code> field refers to the structure type. Such recursion is not a problem; in fact, you can use the type <code>struct intlistlink *</code> before the definition of the type <code>struct intlistlink</code> itself. That works because pointers to all kinds of structures really look the same at the machine level.</p> <p>After defining the structure, you can declare a variable of type <code>struct intlistlink</code> like this:</p> <pre><code>struct intlistlink foo;\n</code></pre> <p>The structure definition itself can serve as the beginning of a variable declaration, so you can declare variables immediately after, like this:</p> <pre><code>struct intlistlink\n  {\n    int datum;\n    struct intlistlink *next;\n  } foo;\n</code></pre> <p>But that is ugly. It is almost always clearer to separate the definition of the structure from its uses.</p> <p>Declaring a structure type inside a block (see Blocks) limits the scope of the structure type name to that block. That means the structure type is recognized only within that block. Declaring it in a function parameter list, as here,</p> <pre><code>int f (struct foo {int a, b} parm);\n</code></pre> <p>(assuming that <code>struct foo</code> is not already defined) limits the scope of the structure type <code>struct foo</code> to that parameter list; that is basically useless, so it triggers a warning.</p> <p>Standard C requires at least one field in a structure. GNU C does not require this.</p> \u2022 Referencing Fields Accessing field values in a structure object. \u2022 Arrays as Fields Accessing field values in a structure object. \u2022 Dynamic Memory Allocation Allocating space for objects while the program is running. \u2022 Field Offset Memory layout of fields within a structure. \u2022 Structure Layout Planning the memory layout of fields. \u2022 Packed Structures Packing structure fields as close as possible. \u2022 Bit Fields Dividing integer fields into fields with fewer bits. \u2022 Bit Field Packing How bit fields pack together in integers. \u2022 const Fields Making structure fields immutable. \u2022 Zero Length Zero-length array as a variable-length object. \u2022 Flexible Array Fields Another approach to variable-length objects. \u2022 Overlaying Structures Casting one structure type over an object of another structure type. \u2022 Structure Assignment Assigning values to structure objects. \u2022 Unions Viewing the same object in different types. \u2022 Packing With Unions Using a union type to pack various types into the same memory space. \u2022 Cast to Union Casting a value one of the union\u2019s alternative types to the type of the union itself. \u2022 Structure Constructors Building new structure objects. \u2022 Unnamed Types as Fields Fields\u2019 types do not always need names. \u2022 Incomplete Types Types which have not been fully defined. \u2022 Intertwined Incomplete Types Defining mutually-recursive structure types. \u2022 Type Tags Scope of structure and union type tags. <p></p> <p>Next: Arrays as Fields, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#151-referencing-structure-fields","title":"15.1 Referencing Structure Fields","text":"<p>To make a structure useful, there has to be a way to examine and store its fields. The \u2018<code>.</code>\u2019 (period) operator does that; its use looks like <code>object``.``field</code>.</p> <p>Given this structure and variable,</p> <pre><code>struct intlistlink\n  {\n    int datum;\n    struct intlistlink *next;\n  };\n\nstruct intlistlink foo;\n</code></pre> <p>you can write <code>foo.datum</code> and <code>foo.next</code> to refer to the two fields in the value of <code>foo</code>. These fields are lvalues, so you can store values into them, and read the values out again.</p> <p>Most often, structures are dynamically allocated (see the next section), and we refer to the objects via pointers. <code>(*p).``field</code> is somewhat cumbersome, so there is an abbreviation: <code>p-&gt;``field</code>. For instance, assume the program contains this declaration:</p> <pre><code>struct intlistlink *ptr;\n</code></pre> <p>You can write <code>ptr-&gt;datum</code> and <code>ptr-&gt;next</code> to refer to the two fields in the object that <code>ptr</code> points to.</p> <p>If a unary operator precedes an expression using \u2018<code>-&gt;</code>\u2019, the \u2018<code>-&gt;</code>\u2019 nests inside:</p> <pre><code>  -ptr-&gt;datum   is equivalent to   -(ptr-&gt;datum)\n</code></pre> <p>You can intermix \u2018<code>-&gt;</code>\u2019 and \u2018<code>.</code>\u2019 without parentheses, as shown here:</p> <pre><code>struct { double d; struct intlistlink l; } foo;\n\n\u2026foo.l.next-&gt;next-&gt;datum\u2026\n</code></pre> <p></p> <p>Next: Dynamic Memory Allocation, Previous: Referencing Fields, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#152-arrays-as-fields","title":"15.2 Arrays as Fields","text":"<p>When you declare field in a structure as an array, as here:</p> <pre><code>struct record\n  {\n    char *name;\n    int data[4];\n  };\n</code></pre> <p>Each <code>struct record</code> object holds one string (a pointer, of course) and four integers, all part of a field called <code>data</code>. If <code>recptr</code> is a pointer of type <code>struct record *</code>, then it points to a <code>struct record</code> which contains those things; you can access the second integer in that record with <code>recptr-&gt;data[1]</code>.</p> <p>If you have two objects of type <code>struct record</code>, each one contains an array. With this declaration,</p> <pre><code>struct record r1, r2;\n</code></pre> <p><code>r1.data</code> holds space for 4 <code>int</code>s, and <code>r2.data</code> holds space for another 4 <code>int</code>s,</p> <p></p> <p>Next: Field Offset, Previous: Arrays as Fields, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#153-dynamic-memory-allocation","title":"15.3 Dynamic Memory Allocation","text":"<p>To allocate an object dynamically, call the library function <code>malloc</code> (see The GNU C Library in The GNU C Library Reference Manual). Here is how to allocate an object of type <code>struct intlistlink</code>. To make this code work, include the file <code>stdlib.h</code>, like this:</p> <pre><code>#include &lt;stddef.h&gt;  /* Defines NULL. */\n#include &lt;stdlib.h&gt;  /* Declares malloc.  */\n\n\u2026\n\nstruct intlistlink *\nalloc_intlistlink ()\n{\n  struct intlistlink *p;\n\n  p = malloc (sizeof (struct intlistlink));\n\n  if (p == NULL)\n    fatal (\"Ran out of storage\");\n\n  /* Initialize the contents. */\n  p-&gt;datum = 0;\n  p-&gt;next = NULL;\n\n  return p;\n}\n</code></pre> <p><code>malloc</code> returns <code>void *</code>, so the assignment to <code>p</code> will automatically convert it to type <code>struct intlistlink *</code>. The return value of <code>malloc</code> is always sufficiently aligned (see Type Alignment) that it is valid for any data type.</p> <p>The test for <code>p == NULL</code> is necessary because <code>malloc</code> returns a null pointer if it cannot get any storage. We assume that the program defines the function <code>fatal</code> to report a fatal error to the user.</p> <p>Here\u2019s how to add one more integer to the front of such a list:</p> <pre><code>struct intlistlink *my_list = NULL;\n\nvoid\nadd_to_mylist (int my_int)\n{\n  struct intlistlink *p = alloc_intlistlink ();\n\n  p-&gt;datum = my_int;\n  p-&gt;next = mylist;\n  mylist = p;\n}\n</code></pre> <p>The way to free the objects is by calling <code>free</code>. Here\u2019s a function to free all the links in one of these lists:</p> <pre><code>void\nfree_intlist (struct intlistlink *p)\n{\n  while (p)\n    {\n      struct intlistlink *q = p;\n      p = p-&gt;next;\n      free (q);\n    }\n}\n</code></pre> <p>We must extract the <code>next</code> pointer from the object before freeing it, because <code>free</code> can clobber the data that was in the object. For the same reason, the program must not use the list any more after freeing its elements. To make sure it won\u2019t, it is best to clear out the variable where the list was stored, like this:</p> <pre><code>free_intlist (mylist);\n\nmylist = NULL;\n</code></pre> <p></p> <p>Next: Structure Layout, Previous: Dynamic Memory Allocation, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#154-field-offset","title":"15.4 Field Offset","text":"<p>To determine the offset of a given field <code>field</code> in a structure type <code>type</code>, use the macro <code>offsetof</code>, which is defined in the file <code>stddef.h</code>. It is used like this:</p> <pre><code>offsetof (type, field)\n</code></pre> <p>Here is an example:</p> <pre><code>struct foo\n{\n  int element;\n  struct foo *next;\n};\n\noffsetof (struct foo, next)\n/* On most machines that is 4.  It may be 8.  */\n</code></pre> <p></p> <p>Next: Packed Structures, Previous: Field Offset, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#155-structure-layout","title":"15.5 Structure Layout","text":"<p>The rest of this chapter covers advanced topics about structures. If you are just learning C, you can skip it.</p> <p>The precise layout of a <code>struct</code> type is crucial when using it to overlay hardware registers, to access data structures in shared memory, or to assemble and disassemble packets for network communication. It is also important for avoiding memory waste when the program makes many objects of that type. However, the layout depends on the target platform. Each platform has conventions for structure layout, which compilers need to follow.</p> <p>Here are the conventions used on most platforms.</p> <p>The structure\u2019s fields appear in the structure layout in the order they are declared. When possible, consecutive fields occupy consecutive bytes within the structure. However, if a field\u2019s type demands more alignment than it would get that way, C gives it the alignment it requires by leaving a gap after the previous field.</p> <p>Once all the fields have been laid out, it is possible to determine the structure\u2019s alignment and size. The structure\u2019s alignment is the maximum alignment of any of the fields in it. Then the structure\u2019s size is rounded up to a multiple of its alignment. That may require leaving a gap at the end of the structure.</p> <p>Here are some examples, where we assume that <code>char</code> has size and alignment 1 (always true), and <code>int</code> has size and alignment 4 (true on most kinds of computers):</p> <pre><code>struct foo\n{\n  char a, b;\n  int c;\n};\n</code></pre> <p>This structure occupies 8 bytes, with an alignment of 4. <code>a</code> is at offset 0, <code>b</code> is at offset 1, and <code>c</code> is at offset 4. There is a gap of 2 bytes before <code>c</code>.</p> <p>Contrast that with this structure:</p> <pre><code>struct foo\n{\n  char a;\n  int c;\n  char b;\n};\n</code></pre> <p>This structure has size 12 and alignment 4. <code>a</code> is at offset 0, <code>c</code> is at offset 4, and <code>b</code> is at offset 8. There are two gaps: three bytes before <code>c</code>, and three bytes at the end.</p> <p>These two structures have the same contents at the C level, but one takes 8 bytes and the other takes 12 bytes due to the ordering of the fields. A reliable way to avoid this sort of wastage is to order the fields by size, biggest fields first.</p> <p></p> <p>Next: Bit Fields, Previous: Structure Layout, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#156-packed-structures","title":"15.6 Packed Structures","text":"<p>In GNU C you can force a structure to be laid out with no gaps by adding <code>__attribute__((packed))</code> after <code>struct</code> (or at the end of the structure type declaration). Here\u2019s an example:</p> <pre><code>struct __attribute__((packed)) foo\n{\n  char a;\n  int c;\n  char b;\n};\n</code></pre> <p>Without <code>__attribute__((packed))</code>, this structure occupies 12 bytes (as described in the previous section), assuming 4-byte alignment for <code>int</code>. With <code>__attribute__((packed))</code>, it is only 6 bytes long\u2014the sum of the lengths of its fields.</p> <p>Use of <code>__attribute__((packed))</code> often results in fields that don\u2019t have the normal alignment for their types. Taking the address of such a field can result in an invalid pointer because of its improper alignment. Dereferencing such a pointer can cause a <code>SIGSEGV</code> signal on a machine that doesn\u2019t, in general, allow unaligned pointers.</p> <p>See Attributes.</p> <p></p> <p>Next: Bit Field Packing, Previous: Packed Structures, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#157-bit-fields","title":"15.7 Bit Fields","text":"<p>A structure field declaration with an integer type can specify the number of bits the field should occupy. We call that a bit field. These are useful because consecutive bit fields are packed into a larger storage unit. For instance,</p> <pre><code>unsigned char opcode: 4;\n</code></pre> <p>specifies that this field takes just 4 bits. Since it is unsigned, its possible values range from 0 to 15. A signed field with 4 bits, such as this,</p> <pre><code>signed char small: 4;\n</code></pre> <p>can hold values from -8 to 7.</p> <p>You can subdivide a single byte into those two parts by writing</p> <pre><code>unsigned char opcode: 4;\nsigned char small: 4;\n</code></pre> <p>in the structure. With bit fields, these two numbers fit into a single <code>char</code>.</p> <p>Here\u2019s how to declare a one-bit field that can hold either 0 or 1:</p> <pre><code>unsigned char special_flag: 1;\n</code></pre> <p>You can also use the <code>bool</code> type for bit fields:</p> <pre><code>bool special_flag: 1;\n</code></pre> <p>Except when using <code>bool</code> (which is always unsigned, see Boolean Type), always specify <code>signed</code> or <code>unsigned</code> for a bit field. There is a default, if that\u2019s not specified: the bit field is signed if plain <code>char</code> is signed, except that the option <code>-funsigned-bitfields</code> forces unsigned as the default. But it is cleaner not to depend on this default.</p> <p>Bit fields are special in that you cannot take their address with \u2018<code>&amp;</code>\u2019. They are not stored with the size and alignment appropriate for the specified type, so they cannot be addressed through pointers to that type.</p> <p></p> <p>Next: const Fields, Previous: Bit Fields, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#158-bit-field-packing","title":"15.8 Bit Field Packing","text":"<p>Programs to communicate with low-level hardware interfaces need to define bit fields laid out to match the hardware data. This section explains how to do that.</p> <p>Consecutive bit fields are packed together, but each bit field must fit within a single object of its specified type. In this example,</p> <pre><code>unsigned short a : 3, b : 3, c : 3, d : 3, e : 3;\n</code></pre> <p>all five fields fit consecutively into one two-byte <code>short</code>. They need 15 bits, and one <code>short</code> provides 16. By contrast,</p> <pre><code>unsigned char a : 3, b : 3, c : 3, d : 3, e : 3;\n</code></pre> <p>needs three bytes. It fits <code>a</code> and <code>b</code> into one <code>char</code>, but <code>c</code> won\u2019t fit in that <code>char</code> (they would add up to 9 bits). So <code>c</code> and <code>d</code> go into a second <code>char</code>, leaving a gap of two bits between <code>b</code> and <code>c</code>. Then <code>e</code> needs a third <code>char</code>. By contrast,</p> <pre><code>unsigned char a : 3, b : 3;\nunsigned int c : 3;\nunsigned char d : 3, e : 3;\n</code></pre> <p>needs only two bytes: the type <code>unsigned int</code> allows <code>c</code> to straddle bytes that are in the same word.</p> <p>You can leave a gap of a specified number of bits by defining a nameless bit field. This looks like <code>type`` : ``nbits``;</code>. It is allocated space in the structure just as a named bit field would be allocated.</p> <p>You can force the following bit field to advance to the following aligned memory object with <code>type`` : 0;</code>.</p> <p>Both of these constructs can syntactically share <code>type</code> with ordinary bit fields. This example illustrates both:</p> <pre><code>unsigned int a : 5, : 3, b : 5, : 0, c : 5, : 3, d : 5;\n</code></pre> <p>It puts <code>a</code> and <code>b</code> into one <code>int</code>, with a 3-bit gap between them. Then <code>: 0</code> advances to the next <code>int</code>, so <code>c</code> and <code>d</code> fit into that one.</p> <p>These rules for packing bit fields apply to most target platforms, including all the usual real computers. A few embedded controllers have special layout rules.</p> <p></p> <p>Next: Zero Length, Previous: Bit Field Packing, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#159-const-fields","title":"15.9 <code>const</code> Fields","text":"<p>A structure field declared <code>const</code> cannot be assigned to (see const). For instance, let\u2019s define this modified version of <code>struct intlistlink</code>:</p> <pre><code>struct intlistlink_ro  /* \u201cro\u201d for read-only.  */\n  {\n    const int datum;\n    struct intlistlink *next;\n  };\n</code></pre> <p>This structure can be used to prevent part of the code from modifying the <code>datum</code> field:</p> <pre><code>/* p has type struct intlistlink *.\n   Convert it to struct intlistlink_ro *.  */\nstruct intlistlink_ro *q\n  = (struct intlistlink_ro *) p;\n\nq-&gt;datum = 5;     /* Error! */\np-&gt;datum = 5;     /* Valid since *p is\n                     not a struct intlistlink_ro.  */\n</code></pre> <p>A <code>const</code> field can get a value in two ways: by initialization of the whole structure, and by making a pointer-to-structure point to an object in which that field already has a value.</p> <p>Any <code>const</code> field in a structure type makes assignment impossible for structures of that type (see Structure Assignment). That is because structure assignment works by assigning the structure\u2019s fields, one by one.</p> <p></p> <p>Next: Flexible Array Fields, Previous: const Fields, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1510-arrays-of-length-zero","title":"15.10 Arrays of Length Zero","text":"<p>GNU C allows zero-length arrays. They are useful as the last field of a structure that is really a header for a variable-length object. Here\u2019s an example, where we construct a variable-size structure to hold a line which is <code>this_length</code> characters long:</p> <pre><code>struct line {\n  int length;\n  char contents[0];\n};\n\nstruct line *thisline\n  = ((struct line *)\n     malloc (sizeof (struct line)\n             + this_length));\nthisline-&gt;length = this_length;\n</code></pre> <p>In ISO C90, we would have to give <code>contents</code> a length of 1, which means either wasting space or complicating the argument to <code>malloc</code>.</p> <p></p> <p>Next: Overlaying Structures, Previous: Zero Length, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1511-flexible-array-fields","title":"15.11 Flexible Array Fields","text":"<p>The C99 standard adopted a more complex equivalent of zero-length array fields. It\u2019s called a flexible array, and it\u2019s indicated by omitting the length, like this:</p> <pre><code>struct line\n{\n  int length;\n  char contents[];\n};\n</code></pre> <p>The flexible array has to be the last field in the structure, and there must be other fields before it.</p> <p>Under the C standard, a structure with a flexible array can\u2019t be part of another structure, and can\u2019t be an element of an array.</p> <p>GNU C allows static initialization of flexible array fields. The effect is to \u201cmake the array long enough\u201d for the initializer.</p> <pre><code>struct f1 { int x; int y[]; } f1\n  = { 1, { 2, 3, 4 } };\n</code></pre> <p>This defines a structure variable named <code>f1</code> whose type is <code>struct f1</code>. In C, a variable name or function name never conflicts with a structure type tag.</p> <p>Omitting the flexible array field\u2019s size lets the initializer determine it. This is allowed only when the flexible array is defined in the outermost structure and you declare a variable of that structure type. For example:</p> <pre><code>struct foo { int x; int y[]; };\nstruct bar { struct foo z; };\n\nstruct foo a = { 1, { 2, 3, 4 } };        // Valid.\nstruct bar b = { { 1, { 2, 3, 4 } } };    // Invalid.\nstruct bar c = { { 1, { } } };            // Valid.\nstruct foo d[1] = { { 1 { 2, 3, 4 } } };  // Invalid.\n</code></pre> <p></p> <p>Next: Structure Assignment, Previous: Flexible Array Fields, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1512-overlaying-different-structures","title":"15.12 Overlaying Different Structures","text":"<p>Be careful about using different structure types to refer to the same memory within one function, because GNU C can optimize code assuming it never does that. See Aliasing. Here\u2019s an example of the kind of aliasing that can cause the problem:</p> <pre><code>struct a { int size; char *data; };\nstruct b { int size; char *data; };\nstruct a foo;\nstruct a *p = &amp;foo;\nstruct b *q = (struct b *) &amp;foo;\n</code></pre> <p>Here <code>q</code> points to the same memory that the variable <code>foo</code> occupies, but they have two different types. The two types <code>struct a</code> and <code>struct b</code> are defined alike, but they are not the same type. Interspersing references using the two types, like this,</p> <pre><code>p-&gt;size = 0;\nq-&gt;size = 1;\nx = p-&gt;size;\n</code></pre> <p>allows GNU C to assume that <code>p-&gt;size</code> is still zero when it is copied into <code>x</code>. The GNU C compiler \u201cknows\u201d that <code>q</code> points to a <code>struct b</code> and this is not supposed to overlap with a <code>struct a</code>. Other compilers might also do this optimization.</p> <p>The ISO C standard considers such code erroneous, precisely so that this optimization will not be incorrect.</p> <p></p> <p>Next: Unions, Previous: Overlaying Structures, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1513-structure-assignment","title":"15.13 Structure Assignment","text":"<p>Assignment operating on a structure type copies the structure. The left and right operands must have the same type. Here is an example:</p> <pre><code>#include &lt;stddef.h&gt;  /* Defines NULL. */\n#include &lt;stdlib.h&gt;  /* Declares malloc.  */\n\u2026\n\nstruct point { double x, y; };\n\nstruct point *\ncopy_point (struct point point)\n{\n  struct point *p\n    = (struct point *) malloc (sizeof (struct point));\n  if (p == NULL)\n    fatal (\"Out of memory\");\n  *p = point;\n  return p;\n}\n</code></pre> <p>Notionally, assignment on a structure type works by copying each of the fields. Thus, if any of the fields has the <code>const</code> qualifier, that structure type does not allow assignment:</p> <pre><code>struct point { const double x, y; };\n\nstruct point a, b;\n\na = b;            /* Error! */\n</code></pre> <p>See Assignment Expressions.</p> <p>When a structure type has a field which is an array, as here,</p> <pre><code>struct record\n  {\n    char *name;\n    int data[4];\n  };\n\nstruct record r1, r2;\n</code></pre> <p>structure assigment such as <code>r1 = r2</code> copies array fields\u2019 contents just as it copies all the other fields.</p> <p>This is the only way in C that you can operate on the whole contents of a array with one operation: when the array is contained in a <code>struct</code>. You can\u2019t copy the contents of the <code>data</code> field as an array, because</p> <pre><code>r1.data = r2.data;\n</code></pre> <p>would convert the array objects (as always) to pointers to the zeroth elements of the arrays (of type <code>struct record *</code>), and the assignment would be invalid because the left operand is not an lvalue.</p> <p></p> <p>Next: Packing With Unions, Previous: Structure Assignment, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1514-unions","title":"15.14 Unions","text":"<p>A union type defines alternative ways of looking at the same piece of memory. Each alternative view is defined with a data type, and identified by a name. A union definition looks like this:</p> <pre><code>union name\n{\n  alternative declarations\u2026\n};\n</code></pre> <p>Each alternative declaration looks like a structure field declaration, except that it can\u2019t be a bit field. For instance,</p> <pre><code>union number\n{\n  long int integer;\n  double float;\n}\n</code></pre> <p>lets you store either an integer (type <code>long int</code>) or a floating point number (type <code>double</code>) in the same place in memory. The length and alignment of the union type are the maximum of all the alternatives\u2014they do not have to be the same. In this union example, <code>double</code> probably takes more space than <code>long int</code>, but that doesn\u2019t cause a problem in programs that use the union in the normal way.</p> <p>The members don\u2019t have to be different in data type. Sometimes each member pertains to a way the data will be used. For instance,</p> <pre><code>union datum\n{\n  double latitude;\n  double longitude;\n  double height;\n  double weight;\n  int continent;\n}\n</code></pre> <p>This union holds one of several kinds of data; most kinds are floating points, but the value can also be a code for a continent which is an integer. You could use one member of type <code>double</code> to access all the values which have that type, but the different member names will make the program clearer.</p> <p>The alignment of a union type is the maximum of the alignments of the alternatives. The size of the union type is the maximum of the sizes of the alternatives, rounded up to a multiple of the alignment (because every type\u2019s size must be a multiple of its alignment).</p> <p>All the union alternatives start at the address of the union itself. If an alternative is shorter than the union as a whole, it occupies the first part of the union\u2019s storage, leaving the last part unused for that alternative.</p> <p>Warning: if the code stores data using one union alternative and accesses it with another, the results depend on the kind of computer in use. Only wizards should try to do this. However, when you need to do this, a union is a clean way to do it.</p> <p>Assignment works on any union type by copying the entire value.</p> <p></p> <p>Next: Cast to Union, Previous: Unions, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1515-packing-with-unions","title":"15.15 Packing With Unions","text":"<p>Sometimes we design a union with the intention of packing various kinds of objects into a certain amount of memory space. For example.</p> <pre><code>union bytes8\n{\n  long long big_int_elt;\n  double double_elt;\n  struct { int first, second; } two_ints;\n  struct { void *first, *second; } two_ptrs;\n};\n\nunion bytes8 *p;\n</code></pre> <p>This union makes it possible to look at 8 bytes of data that <code>p</code> points to as a single 8-byte integer (<code>p-&gt;big_int_elt</code>), as a single floating-point number (<code>p-&gt;double_elt</code>), as a pair of integers (<code>p-&gt;two_ints.first</code> and <code>p-&gt;two_ints.second</code>), or as a pair of pointers (<code>p-&gt;two_ptrs.first</code> and <code>p-&gt;two_ptrs.second</code>).</p> <p>To pack storage with such a union makes assumptions about the sizes of all the types involved. This particular union was written expecting a pointer to have the same size as <code>int</code>. On a machine where one pointer takes 8 bytes, the code using this union probably won\u2019t work as expected. The union, as such, will function correctly\u2014if you store two values through <code>two_ints</code> and extract them through <code>two_ints</code>, you will get the same integers back\u2014but the part of the program that expects the union to be 8 bytes long could malfunction, or at least use too much space.</p> <p>The above example shows one case where a <code>struct</code> type with no tag can be useful. Another way to get effectively the same result is with arrays as members of the union:</p> <pre><code>union eight_bytes\n{\n  long long big_int_elt;\n  double double_elt;\n  int two_ints[2];\n  void *two_ptrs[2];\n};\n</code></pre> <p></p> <p>Next: Structure Constructors, Previous: Packing With Unions, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1516-cast-to-a-union-type","title":"15.16 Cast to a Union Type","text":"<p>In GNU C, you can explicitly cast any of the alternative types to the union type; for instance,</p> <pre><code>(union eight_bytes) (long long) 5\n</code></pre> <p>makes a value of type <code>union eight_bytes</code> which gets its contents through the alternative named <code>big_int_elt</code>.</p> <p>The value being cast must exactly match the type of the alternative, so this is not valid:</p> <pre><code>(union eight_bytes) 5  /* Error!  5 is int. */\n</code></pre> <p>A cast to union type looks like any other cast, except that the type specified is a union type. You can specify the type either with <code>union ``tag</code> or with a typedef name (see Defining Typedef Names).</p> <p>Using the cast as the right-hand side of an assignment to a variable of union type is equivalent to storing in an alternative of the union:</p> <pre><code>union foo u;\n\nu = (union foo) x   means   u.i = x\n\nu = (union foo) y   means   u.d = y\n</code></pre> <p>You can also use the union cast as a function argument:</p> <pre><code>void hack (union foo);\n\u2026\nhack ((union foo) x);\n</code></pre> <p></p> <p>Next: Unnamed Types as Fields, Previous: Cast to Union, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1517-structure-constructors","title":"15.17 Structure Constructors","text":"<p>You can construct a structure value by writing its type in parentheses, followed by an initializer that would be valid in a declaration for that type. For instance, given this declaration,</p> <pre><code>struct foo {int a; char b[2];} structure;\n</code></pre> <p>you can create a <code>struct foo</code> value as follows:</p> <pre><code>((struct foo) {x + y, 'a', 0})\n</code></pre> <p>This specifies <code>x + y</code> for field <code>a</code>, the character \u2018<code>a</code>\u2019 for field <code>b</code>\u2019s element 0, and the null character for field <code>b</code>\u2019s element 1.</p> <p>The parentheses around that constructor are not necessary, but we recommend writing them to make the nesting of the containing expression clearer.</p> <p>You can also show the nesting of the two by writing it like this:</p> <pre><code>((struct foo) {x + y, {'a', 0} })\n</code></pre> <p>Each of those is equivalent to writing the following statement expression (see Statement Exprs):</p> <pre><code>({\n  struct foo temp = {x + y, 'a', 0};\n  temp;\n})\n</code></pre> <p>You can also use field labels in the structure constructor to indicate which fields you\u2019re specifying values for, instead of using the order of the fields to specify that:</p> <pre><code>(struct foo) {.a = x + y, .b = {'a', 0}}\n</code></pre> <p>You can also create a union value this way, but it is not especially useful since that is equivalent to doing a cast:</p> <pre><code>  ((union whosis) {value})\nis equivalent to\n  ((union whosis) (value))\n</code></pre> <p></p> <p>Next: Incomplete Types, Previous: Structure Constructors, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1518-unnamed-types-as-fields","title":"15.18 Unnamed Types as Fields","text":"<p>A structure or a union can contain, as fields, unnamed structures and unions. Here\u2019s an example:</p> <pre><code>struct\n{\n  int a;\n  union\n  {\n    int b;\n    float c;\n  };\n  int d;\n} foo;\n</code></pre> <p>You can access the fields of the unnamed union within <code>foo</code> as if they were individual fields at the same level as the union definition:</p> <pre><code>foo.a = 42;\nfoo.b = 47;\nfoo.c = 5.25; // Overwrites the value in foo.b.\nfoo.d = 314;\n</code></pre> <p>Avoid using field names that could cause ambiguity. For example, with this definition:</p> <pre><code>struct\n{\n  int a;\n  struct\n  {\n    int a;\n    float b;\n  };\n} foo;\n</code></pre> <p>it is impossible to tell what <code>foo.a</code> refers to. GNU C reports an error when a definition is ambiguous in this way.</p> <p></p> <p>Next: Intertwined Incomplete Types, Previous: Unnamed Types as Fields, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1519-incomplete-types","title":"15.19 Incomplete Types","text":"<p>A type that has not been fully defined is called an incomplete type. Structure and union types are incomplete when the code makes a forward reference, such as <code>struct foo</code>, before defining the type. An array type is incomplete when its length is unspecified.</p> <p>You can\u2019t use an incomplete type to declare a variable or field, or use it for a function parameter or return type. The operators <code>sizeof</code> and <code>_Alignof</code> give errors when used on an incomplete type.</p> <p>However, you can define a pointer to an incomplete type, and declare a variable or field with such a pointer type. In general, you can do everything with such pointers except dereference them. For example:</p> <pre><code>extern void bar (struct mysterious_value *);\n\nvoid\nfoo (struct mysterious_value *arg)\n{\n  bar (arg);\n}\n\n\u2026\n\n{\n  struct mysterious_value *p, **q;\n\n  p = *q;\n  foo (p);\n}\n</code></pre> <p>These examples are valid because the code doesn\u2019t try to understand what <code>p</code> points to; it just passes the pointer around. (Presumably <code>bar</code> is defined in some other file that really does have a definition for <code>struct mysterious_value</code>.) However, dereferencing the pointer would get an error; that requires a definition for the structure type.</p> <p></p> <p>Next: Type Tags, Previous: Incomplete Types, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1520-intertwined-incomplete-types","title":"15.20 Intertwined Incomplete Types","text":"<p>When several structure types contain pointers to each other, you can define the types in any order because pointers to types that come later are incomplete types. Thus, Here is an example.</p> <pre><code>/* An employee record points to a group.  */\nstruct employee\n{\n  char *name;\n  \u2026\n  struct group *group;  /* incomplete type.  */\n  \u2026\n};\n\n/* An employee list points to employees.  */\nstruct employee_list\n{\n  struct employee *this_one;\n  struct employee_list *next;  /* incomplete type.  */\n  \u2026\n};\n\n/* A group points to one employee_list.  */\nstruct group\n{\n  char *name;\n  \u2026\n  struct employee_list *employees;\n  \u2026\n};\n</code></pre> <p></p> <p>Previous: Intertwined Incomplete Types, Up: Structures \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1521-type-tags","title":"15.21 Type Tags","text":"<p>The name that follows <code>struct</code> (see Structures), <code>union</code> (see Unions, or <code>enum</code> (see Enumeration Types) is called a type tag. In C, a type tag never conflicts with a variable name or function name; the type tags have a separate name space. Thus, there is no name conflict in this code:</p> <pre><code>struct pair { int a, b; };\nint pair = 1;\n</code></pre> <p>nor in this one:</p> <pre><code>struct pair { int a, b; } pair;\n</code></pre> <p>where <code>pair</code> is both a structure type tag and a variable name.</p> <p>However, <code>struct</code>, <code>union</code>, and <code>enum</code> share the same name space of tags, so this is a conflict:</p> <pre><code>struct pair { int a, b; };\nenum pair { c, d };\n</code></pre> <p>and so is this:</p> <pre><code>struct pair { int a, b; };\nstruct pair { int c, d; };\n</code></pre> <p>When the code defines a type tag inside a block, the tag\u2019s scope is limited to that block (as for local variables). Two definitions for one type tag do not conflict if they are in different scopes; rather, each is valid in its scope. For example,</p> <pre><code>struct pair { int a, b; };\n\nvoid\npair_up_doubles (int len, double array[])\n{\n  struct pair { double a, b; };\n  \u2026\n}\n</code></pre> <p>has two definitions for <code>struct pair</code> which do not conflict. The one inside the function applies only within the definition of <code>pair_up_doubles</code>. Within its scope, that definition shadows the outer definition.</p> <p>If <code>struct pair</code> appears inside the function body, before the inner definition, it refers to the outer definition\u2014the only one that has been seen at that point. Thus, in this code,</p> <pre><code>struct pair { int a, b; };\n\nvoid\npair_up_doubles (int len, double array[])\n{\n  struct two_pairs { struct pair *p, *q; };\n  struct pair { double a, b; };\n  \u2026\n}\n</code></pre> <p>the structure <code>two_pairs</code> has pointers to the outer definition of <code>struct pair</code>, which is probably not desirable.</p> <p>To prevent that, you can write <code>struct pair;</code> inside the function body as a variable declaration with no variables. This is a forward declaration of the type tag <code>pair</code>: it makes the type tag local to the current block, with the details of the type to come later. Here\u2019s an example:</p> <pre><code>void\npair_up_doubles (int len, double array[])\n{\n  /* Forward declaration for pair.  */\n  struct pair;\n  struct two_pairs { struct pair *p, *q; };\n  /* Give the details.  */\n  struct pair { double a, b; };\n  \u2026\n}\n</code></pre> <p>However, the cleanest practice is to avoid shadowing type tags.</p> <p></p> <p>Next: Enumeration Types, Previous: Structures, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#16-arrays","title":"16 Arrays","text":"<p>An array is a data object that holds a series of elements, all of the same data type. Each element is identified by its numeric <code>index</code> within the array.</p> <p>We presented arrays of numbers in the sample programs early in this manual (see Array Example). However, arrays can have elements of any data type, including pointers, structures, unions, and other arrays.</p> <p>If you know another programming language, you may suppose that you know all about arrays, but C arrays have special quirks, so in this chapter we collect all the information about arrays in C.</p> <p>The elements of a C array are allocated consecutively in memory, with no gaps between them. Each element is aligned as required for its data type (see Type Alignment).</p> \u2022 Accessing Array Elements How to access individual elements of an array. \u2022 Declaring an Array How to name and reserve space for a new array. \u2022 Strings A string in C is a special case of array. \u2022 Array Type Designators Referring to a specific array type. \u2022 Incomplete Array Types Naming, but not allocating, a new array. \u2022 Limitations of C Arrays Arrays are not first-class objects. \u2022 Multidimensional Arrays Arrays of arrays. \u2022 Constructing Array Values Assigning values to an entire array at once. \u2022 Arrays of Variable Length Declaring arrays of non-constant size. <p></p> <p>Next: Declaring an Array, Up: Arrays \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#161-accessing-array-elements","title":"16.1 Accessing Array Elements","text":"<p>If the variable <code>a</code> is an array, the <code>n</code>th element of <code>a</code> is <code>a[``n``]</code>. You can use that expression to access an element\u2019s value or to assign to it:</p> <pre><code>x = a[5];\na[6] = 1;\n</code></pre> <p>Since the variable <code>a</code> is an lvalue, <code>a[``n``]</code> is also an lvalue.</p> <p>The lowest valid index in an array is 0, not 1, and the highest valid index is one less than the number of elements.</p> <p>The C language does not check whether array indices are in bounds, so if the code uses an out-of-range index, it will access memory outside the array.</p> <p>Warning: Using only valid index values in C is the programmer\u2019s responsibility.</p> <p>Array indexing in C is not a primitive operation: it is defined in terms of pointer arithmetic and dereferencing. Now that we know what <code>a[i]</code> does, we can ask how <code>a[i]</code> does its job.</p> <p>In C, <code>x``[``y``]</code> is an abbreviation for <code>*(``x``+``y``)</code>. Thus, <code>a[i]</code> really means <code>*(a+i)</code>. See Pointers and Arrays.</p> <p>When an expression with array type (such as <code>a</code>) appears as part of a larger C expression, it is converted automatically to a pointer to element zero of that array. For instance, <code>a</code> in an expression is equivalent to <code>&amp;a[0]</code>. Thus, <code>*(a+i)</code> is computed as <code>*(&amp;a[0]+i)</code>.</p> <p>Now we can analyze how that expression gives us the desired element of the array. It makes a pointer to element 0 of <code>a</code>, advances it by the value of <code>i</code>, and dereferences that pointer.</p> <p>Another equivalent way to write the expression is <code>(&amp;a[0])[i]</code>.</p> <p></p> <p>Next: Strings, Previous: Accessing Array Elements, Up: Arrays \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#162-declaring-an-array","title":"16.2 Declaring an Array","text":"<p>To make an array declaration, write <code>[``length``]</code> after the name being declared. This construct is valid in the declaration of a variable, a function parameter, a function value type (the value can\u2019t be an array, but it can be a pointer to one), a structure field, or a union alternative.</p> <p>The surrounding declaration specifies the element type of the array; that can be any type of data, but not <code>void</code> or a function type. For instance,</p> <pre><code>double a[5];\n</code></pre> <p>declares <code>a</code> as an array of 5 <code>double</code>s.</p> <pre><code>struct foo bstruct[length];\n</code></pre> <p>declares <code>bstruct</code> as an array of <code>length</code> objects of type <code>struct foo</code>. A variable array size like this is allowed when the array is not file-scope.</p> <p>Other declaration constructs can nest within the array declaration construct. For instance:</p> <pre><code>struct foo *b[length];\n</code></pre> <p>declares <code>b</code> as an array of <code>length</code> pointers to <code>struct foo</code>. This shows that the length need not be a constant (see Arrays of Variable Length).</p> <pre><code>double (*c)[5];\n</code></pre> <p>declares <code>c</code> as a pointer to an array of 5 <code>double</code>s, and</p> <pre><code>char *(*f (int))[5];\n</code></pre> <p>declares <code>f</code> as a function taking an <code>int</code> argument and returning a pointer to an array of 5 strings (pointers to <code>char</code>s).</p> <pre><code>double aa[5][10];\n</code></pre> <p>declares <code>aa</code> as an array of 5 elements, each of which is an array of 10 <code>double</code>s. This shows how to declare a multidimensional array in C (see Multidimensional Arrays).</p> <p>All these declarations specify the array\u2019s length, which is needed in these cases in order to allocate storage for the array.</p> <p></p> <p>Next: Array Type Designators, Previous: Declaring an Array, Up: Arrays \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#163-strings","title":"16.3 Strings","text":"<p>A string in C is a sequence of elements of type <code>char</code>, terminated with the null character, the character with code zero.</p> <p>Programs often need to use strings with specific, fixed contents. To write one in a C program, use a string constant such as <code>\"Take me to your leader!\"</code>. The data type of a string constant is <code>char *</code>. For the full syntactic details of writing string constants, String Constants.</p> <p>To declare a place to store a non-constant string, declare an array of <code>char</code>. Keep in mind that it must include one extra <code>char</code> for the terminating null. For instance,</p> <pre><code>char text[] = { 'H', 'e', 'l', 'l', 'o', 0 };\n</code></pre> <p>declares an array named \u2018<code>text</code>\u2019 with six elements\u2014five letters and the terminating null character. An equivalent way to get the same result is this,</p> <pre><code>char text[] = \"Hello\";\n</code></pre> <p>which copies the elements of the string constant, including its terminating null character.</p> <pre><code>char message[200];\n</code></pre> <p>declares an array long enough to hold a string of 199 ASCII characters plus the terminating null character.</p> <p>When you store a string into <code>message</code> be sure to check or prove that the length does not exceed its size. For example,</p> <pre><code>void\nset_message (char *text)\n{\n  int i;\n  for (i = 0; i &lt; sizeof (message); i++)\n    {\n      message[i] = text[i];\n      if (text[i] == 0)\n        return;\n    }\n  fatal_error (\"Message is too long for `message'\\n\");\n}\n</code></pre> <p>It\u2019s easy to do this with the standard library function <code>strncpy</code>, which fills out the whole destination array (up to a specified length) with null characters. Thus, if the last character of the destination is not null, the string did not fit. Many system libraries, including the GNU C library, hand-optimize <code>strncpy</code> to run faster than an explicit <code>for</code>-loop.</p> <p>Here\u2019s what the code looks like:</p> <pre><code>void\nset_message (char *text)\n{\n  strncpy (message, text, sizeof (message));\n  if (message[sizeof (message) - 1] != 0)\n    fatal_error (\"Message is too long for `message');\n}\n</code></pre> <p>See The GNU C Library in The GNU C Library Reference Manual, for more information about the standard library functions for operating on strings.</p> <p>You can avoid putting a fixed length limit on strings you construct or operate on by allocating the space for them dynamically. See Dynamic Memory Allocation.</p> <p></p> <p>Next: Incomplete Array Types, Previous: Strings, Up: Arrays \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#164-array-type-designators","title":"16.4 Array Type Designators","text":"<p>Every C type has a type designator, which you make by deleting the variable name and the semicolon from a declaration (see Type Designators). The designators for array types follow this rule, but they may appear surprising.</p> <pre><code>type   int a[5];           designator   int [5]\ntype   double a[5][3];     designator   double [5][3]\ntype   struct foo *a[5];   designator   struct foo *[5]\n</code></pre> <p></p> <p>Next: Limitations of C Arrays, Previous: Array Type Designators, Up: Arrays \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#165-incomplete-array-types","title":"16.5 Incomplete Array Types","text":"<p>An array is equivalent, for most purposes, to a pointer to its zeroth element. When that is true, the length of the array is irrelevant. The length needs to be known only for allocating space for the array, or for <code>sizeof</code> and <code>typeof</code> (see Auto Type). Thus, in some contexts C allows</p> <ul> <li>An <code>extern</code> declaration says how to refer to a variable allocated     elsewhere. It does not need to allocate space for the variable, so     if it is an array, you can omit the length. For example,         extern int foo[];</li> <li>When declaring a function parameter as an array, the argument value     passed to the function is really a pointer to the array\u2019s zeroth     element. This value does not say how long the array really is, there     is no need to declare it. For example,         int         func (int foo[])</li> </ul> <p>These declarations are examples of incomplete array types, types that are not fully specified. The incompleteness makes no difference for accessing elements of the array, but it matters for some other things. For instance, <code>sizeof</code> is not allowed on an incomplete type.</p> <p>With multidimensional arrays, only the first dimension can be omitted. For example, suppose we want to represent the positions of pieces on a chessboard which has the usual 8 files (columns), but more (or fewer) ranks (rows) than the usual 8. This declaration could hold a pointer to a two-dimensional array that can hold that data. Each element of the array holds one row.</p> <pre><code>struct chesspiece *funnyboard[][8];\n</code></pre> <p>Since it is just a pointer to the start of an array, its type can be incomplete, but it must state how big each array element is\u2014the number of elements in each row.</p> <p></p> <p>Next: Multidimensional Arrays, Previous: Incomplete Array Types, Up: Arrays \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#166-limitations-of-c-arrays","title":"16.6 Limitations of C Arrays","text":"<p>Arrays have quirks in C because they are not \u201cfirst-class objects\u201d: there is no way in C to operate on an array as a unit.</p> <p>The other composite objects in C, structures and unions, are first-class objects: a C program can copy a structure or union value in an assignment, or pass one as an argument to a function, or make a function return one. You can\u2019t do those things with an array in C. That is because a value you can operate on never has an array type.</p> <p>An expression in C can have an array type, but that doesn\u2019t produce the array as a value. Instead it is converted automatically to a pointer to the array\u2019s element at index zero. The code can operate on the pointer, and through that on individual elements of the array, but it can\u2019t get and operate on the array as a unit.</p> <p>There are three exceptions to this conversion rule, but none of them offers a way to operate on the array as a whole.</p> <p>First, \u2018<code>&amp;</code>\u2019 applied to an expression with array type gives you the address of the array, as an array type. However, you can\u2019t operate on the whole array that way\u2014if you apply \u2018<code>*</code>\u2019 to get the array back, that expression converts, as usual, to a pointer to its zeroth element.</p> <p>Second, the operators <code>sizeof</code>, <code>_Alignof</code>, and <code>typeof</code> do not convert the array to a pointer; they leave it as an array. But they don\u2019t operate on the array\u2019s data\u2014they only give information about its type.</p> <p>Third, a string constant used as an initializer for an array is not converted to a pointer\u2014rather, the declaration copies the contents of that string in that one special case.</p> <p>You can copy the contents of an array, just not with an assignment operator. You can do it by calling the library function <code>memcpy</code> or <code>memmove</code> (see The GNU C Library in The GNU C Library Reference Manual). Also, when a structure contains just an array, you can copy that structure.</p> <p>An array itself is an lvalue if it is a declared variable, or part of a structure or union that is an lvalue. When you construct an array from elements (see Constructing Array Values), that array is not an lvalue.</p> <p></p> <p>Next: Constructing Array Values, Previous: Limitations of C Arrays, Up: Arrays \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#167-multidimensional-arrays","title":"16.7 Multidimensional Arrays","text":"<p>Strictly speaking, all arrays in C are unidimensional. However, you can create an array of arrays, which is more or less equivalent to a multidimensional array. For example,</p> <pre><code>struct chesspiece *board[8][8];\n</code></pre> <p>declares an array of 8 arrays of 8 pointers to <code>struct chesspiece</code>. This data type could represent the state of a chess game. To access one square\u2019s contents requires two array index operations, one for each dimension. For instance, you can write <code>board[row][column]</code>, assuming <code>row</code> and <code>column</code> are variables with integer values in the proper range.</p> <p>How does C understand <code>board[row][column]</code>? First of all, <code>board</code> is converted automatically to a pointer to the zeroth element (at index zero) of <code>board</code>. Adding <code>row</code> to that makes it point to the desired element. Thus, <code>board[row]</code>\u2019s value is an element of <code>board</code>\u2014an array of 8 pointers.</p> <p>However, as an expression with array type, it is converted automatically to a pointer to the array\u2019s zeroth element. The second array index operation, <code>[column]</code>, accesses the chosen element from that array.</p> <p>As this shows, pointer-to-array types are meaningful in C. You can declare a variable that points to a row in a chess board like this:</p> <pre><code>struct chesspiece *(*rowptr)[8];\n</code></pre> <p>This points to an array of 8 pointers to <code>struct chesspiece</code>. You can assign to it as follows:</p> <pre><code>rowptr = &amp;board[5];\n</code></pre> <p>The dimensions don\u2019t have to be equal in length. Here we declare <code>statepop</code> as an array to hold the population of each state in the United States for each year since 1900:</p> <pre><code>#define NSTATES 50\n{\n  int nyears = current_year - 1900 + 1;\n  int statepop[NSTATES][nyears];\n  \u2026\n}\n</code></pre> <p>The variable <code>statepop</code> is an array of <code>NSTATES</code> subarrays, each indexed by the year (counting from 1900). Thus, to get the element for a particular state and year, we must subscript it first by the number that indicates the state, and second by the index for the year:</p> <pre><code>statepop[state][year - 1900]\n</code></pre> <p></p> <p>The subarrays within the multidimensional array are allocated consecutively in memory, and within each subarray, its elements are allocated consecutively in memory. The most efficient way to process all the elements in the array is to scan the last subscript in the innermost loop. This means consecutive accesses go to consecutive memory locations, which optimizes use of the processor\u2019s memory cache. For example:</p> <pre><code>int total = 0;\nfloat average;\n\nfor (int state = 0; state &lt; NSTATES, ++state)\n  {\n    for (int year = 0; year &lt; nyears; ++year)\n      {\n        total += statepop[state][year];\n      }\n  }\n\naverage = total / nyears;\n</code></pre> <p>C\u2019s layout for multidimensional arrays is different from Fortran\u2019s layout. In Fortran, a multidimensional array is not an array of arrays; rather, multidimensional arrays are a primitive feature, and it is the first index that varies most rapidly between consecutive memory locations. Thus, the memory layout of a 50x114 array in C matches that of a 114x50 array in Fortran.</p> <p></p> <p>Next: Arrays of Variable Length, Previous: Multidimensional Arrays, Up: Arrays \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#168-constructing-array-values","title":"16.8 Constructing Array Values","text":"<p>You can construct an array from elements by writing them inside braces, and preceding all that with the array type\u2019s designator in parentheses. There is no need to specify the array length, since the number of elements determines that. The constructor looks like this:</p> <pre><code>(elttype[]) { elements };\n</code></pre> <p>Here is an example, which constructs an array of string pointers:</p> <pre><code>(char *[]) { \"x\", \"y\", \"z\" };\n</code></pre> <p>That\u2019s equivalent in effect to declaring an array with the same initializer, like this:</p> <pre><code>char *array[] = { \"x\", \"y\", \"z\" };\n</code></pre> <p>and then using the array.</p> <p>If all the elements are simple constant expressions, or made up of such, then the compound literal can be coerced to a pointer to its zeroth element and used to initialize a file-scope variable (see File-Scope Variables), as shown here:</p> <pre><code>char **foo = (char *[]) { \"x\", \"y\", \"z\" };\n</code></pre> <p>The data type of <code>foo</code> is <code>char **</code>, which is a pointer type, not an array type. The declaration is equivalent to defining and then using an array-type variable:</p> <pre><code>char *nameless_array[] = { \"x\", \"y\", \"z\" };\nchar **foo = &amp;nameless_array[0];\n</code></pre> <p></p> <p>Previous: Constructing Array Values, Up: Arrays \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#169-arrays-of-variable-length","title":"16.9 Arrays of Variable Length","text":"<p>In GNU C, you can declare variable-length arrays like any other arrays, but with a length that is not a constant expression. The storage is allocated at the point of declaration and deallocated when the block scope containing the declaration exits. For example:</p> <pre><code>#include &lt;stdio.h&gt;  /* Defines FILE. */\n#include &lt;string.h&gt; /* Declares str. */\n\nFILE *\nconcat_fopen (char *s1, char *s2, char *mode)\n{\n  char str[strlen (s1) + strlen (s2) + 1];\n  strcpy (str, s1);\n  strcat (str, s2);\n  return fopen (str, mode);\n}\n</code></pre> <p>(This uses some standard library functions; see String and Array Utilities in The GNU C Library Reference Manual.)</p> <p>The length of an array is computed once when the storage is allocated and is remembered for the scope of the array in case it is used in <code>sizeof</code>.</p> <p>Warning: don\u2019t allocate a variable-length array if the size might be very large (more than 100,000), or in a recursive function, because that is likely to cause stack overflow. Allocate the array dynamically instead (see Dynamic Memory Allocation).</p> <p>Jumping or breaking out of the scope of the array name deallocates the storage. Jumping into the scope is not allowed; that gives an error message.</p> <p>You can also use variable-length arrays as arguments to functions:</p> <pre><code>struct entry\ntester (int len, char data[len][len])\n{\n  \u2026\n}\n</code></pre> <p>As usual, a function argument declared with an array type is really a pointer to an array that already exists. Calling the function does not allocate the array, so there\u2019s no particular danger of stack overflow in using this construct.</p> <p>To pass the array first and the length afterward, use a forward declaration in the function\u2019s parameter list (another GNU extension). For example,</p> <pre><code>struct entry\ntester (int len; char data[len][len], int len)\n{\n  \u2026\n}\n</code></pre> <p>The <code>int len</code> before the semicolon is a parameter forward declaration, and it serves the purpose of making the name <code>len</code> known when the declaration of <code>data</code> is parsed.</p> <p>You can write any number of such parameter forward declarations in the parameter list. They can be separated by commas or semicolons, but the last one must end with a semicolon, which is followed by the \u201creal\u201d parameter declarations. Each forward declaration must match a \u201creal\u201d declaration in parameter name and data type. ISO C11 does not support parameter forward declarations.</p> <p></p> <p>Next: Defining Typedef Names, Previous: Arrays, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#17-enumeration-types","title":"17 Enumeration Types","text":"<p>An enumeration type represents a limited set of integer values, each with a name. It is effectively equivalent to a primitive integer type.</p> <p>Suppose we have a list of possible emotional states to store in an integer variable. We can give names to these alternative values with an enumeration:</p> <pre><code>enum emotion_state { neutral, happy, sad, worried,\n                     calm, nervous };\n</code></pre> <p>(Never mind that this is a simplistic way to classify emotional states; it\u2019s just a code example.)</p> <p>The names inside the enumeration are called enumerators. The enumeration type defines them as constants, and their values are consecutive integers; <code>neutral</code> is 0, <code>happy</code> is 1, <code>sad</code> is 2, and so on. Alternatively, you can specify values for the enumerators explicitly like this:</p> <pre><code>enum emotion_state { neutral = 2, happy = 5,\n                     sad = 20, worried = 10,\n                     calm = -5, nervous = -300 };\n</code></pre> <p>Each enumerator which does not specify a value gets value zero (if it is at the beginning) or the next consecutive integer.</p> <pre><code>/* neutral is 0 by default,\n   and worried is 21 by default.  */\nenum emotion_state { neutral,\n                      happy = 5, sad = 20, worried,\n                      calm = -5, nervous = -300 };\n</code></pre> <p>If an enumerator is obsolete, you can specify that using it should cause a warning, by including an attribute in the enumerator\u2019s declaration. Here is how <code>happy</code> would look with this attribute:</p> <pre><code>happy __attribute__\n      ((deprecated\n        (\"impossible under plutocratic rule\")))\n      = 5,\n</code></pre> <p>See Attributes.</p> <p>You can declare variables with the enumeration type:</p> <pre><code>enum emotion_state feelings_now;\n</code></pre> <p>In the C code itself, this is equivalent to declaring the variable <code>int</code>. (If all the enumeration values are positive, it is equivalent to <code>unsigned int</code>.) However, declaring it with the enumeration type has an advantage in debugging, because GDB knows it should display the current value of the variable using the corresponding name. If the variable\u2019s type is <code>int</code>, GDB can only show the value as a number.</p> <p>The identifier that follows <code>enum</code> is called a type tag since it distinguishes different enumeration types. Type tags are in a separate name space and belong to scopes like most other names in C. See Type Tags, for explanation.</p> <p>You can predeclare an <code>enum</code> type tag like a structure or union type tag, like this:</p> <pre><code>enum foo;\n</code></pre> <p>The <code>enum</code> type is incomplete until you finish defining it.</p> <p>You can optionally include a trailing comma at the end of a list of enumeration values:</p> <pre><code>enum emotion_state { neutral, happy, sad, worried,\n                     calm, nervous, };\n</code></pre> <p>This is useful in some macro definitions, since it enables you to assemble the list of enumerators without knowing which one is last. The extra comma does not change the meaning of the enumeration in any way.</p> <p></p> <p>Next: Statements, Previous: Enumeration Types, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#18-defining-typedef-names","title":"18 Defining Typedef Names","text":"<p>You can define a data type keyword as an alias for any type, and then use the alias syntactically like a built-in type keyword such as <code>int</code>. You do this using <code>typedef</code>, so these aliases are also called typedef names.</p> <p><code>typedef</code> is followed by text that looks just like a variable declaration, but instead of declaring variables it defines data type keywords.</p> <p>Here\u2019s how to define <code>fooptr</code> as a typedef alias for the type <code>struct foo *</code>, then declare <code>x</code> and <code>y</code> as variables with that type:</p> <pre><code>typedef struct foo *fooptr;\n\nfooptr x, y;\n</code></pre> <p>That declaration is equivalent to the following one:</p> <pre><code>struct foo *x, *y;\n</code></pre> <p>You can define a typedef alias for any type. For instance, this makes <code>frobcount</code> an alias for type <code>int</code>:</p> <pre><code>typedef int frobcount;\n</code></pre> <p>This doesn\u2019t define a new type distinct from <code>int</code>. Rather, <code>frobcount</code> is another name for the type <code>int</code>. Once the variable is declared, it makes no difference which name the declaration used.</p> <p>There is a syntactic difference, however, between <code>frobcount</code> and <code>int</code>: A typedef name cannot be used with <code>signed</code>, <code>unsigned</code>, <code>long</code> or <code>short</code>. It has to specify the type all by itself. So you can\u2019t write this:</p> <pre><code>unsigned frobcount f1;  /* Error! */\n</code></pre> <p>But you can write this:</p> <pre><code>typedef unsigned int unsigned_frobcount;\n\nunsigned_frobcount f1;\n</code></pre> <p>In other words, a typedef name is not an alias for a keyword such as <code>int</code>. It stands for a type, and that could be the type <code>int</code>.</p> <p>Typedef names are in the same namespace as functions and variables, so you can\u2019t use the same name for a typedef and a function, or a typedef and a variable. When a typedef is declared inside a code block, it is in scope only in that block.</p> <p>Warning: Avoid defining typedef names that end in \u2018<code>_t</code>\u2019, because many of these have standard meanings.</p> <p>You can redefine a typedef name to the exact same type as its first definition, but you cannot redefine a typedef name to a different type, even if the two types are compatible. For example, this is valid:</p> <pre><code>typedef int frobcount;\ntypedef int frotzcount;\ntypedef frotzcount frobcount;\ntypedef frobcount frotzcount;\n</code></pre> <p>because each typedef name is always defined with the same type (<code>int</code>), but this is not valid:</p> <pre><code>enum foo {f1, f2, f3};\ntypedef enum foo frobcount;\ntypedef int frobcount;\n</code></pre> <p>Even though the type <code>enum foo</code> is compatible with <code>int</code>, they are not the same type.</p> <p></p> <p>Next: Variables, Previous: Defining Typedef Names, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#19-statements","title":"19 Statements","text":"<p>A statement specifies computations to be done for effect; it does not produce a value, as an expression would. In general a statement ends with a semicolon (\u2018<code>;</code>\u2019), but blocks (which are statements, more or less) are an exception to that rule. See Blocks.</p> <p>The places to use statements are inside a block, and inside a complex statement. A complex statement contains one or two components that are nested statements. Each such component must consist of one and only one statement. The way to put multiple statements in such a component is to group them into a block (see Blocks), which counts as one statement.</p> <p>The following sections describe the various kinds of statement.</p> \u2022 Expression Statement Evaluate an expression, as a statement, usually done for a side effect. \u2022 if Statement Basic conditional execution. \u2022 if-else Statement Multiple branches for conditional execution. \u2022 Blocks Grouping multiple statements together. \u2022 return Statement Return a value from a function. \u2022 Loop Statements Repeatedly executing a statement or block. \u2022 switch Statement Multi-way conditional choices. \u2022 switch Example A plausible example of using <code>switch</code>. \u2022 Duffs Device A special way to use <code>switch</code>. \u2022 Case Ranges Ranges of values for <code>switch</code> cases. \u2022 Null Statement A statement that does nothing. \u2022 goto Statement Jump to another point in the source code, identified by a label. \u2022 Local Labels Labels with limited scope. \u2022 Labels as Values Getting the address of a label. \u2022 Statement Exprs A series of statements used as an expression. <p></p> <p>Next: if Statement, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#191-expression-statement","title":"19.1 Expression Statement","text":"<p>The most common kind of statement in C is an expression statement. It consists of an expression followed by a semicolon. The expression\u2019s value is discarded, so the expressions that are useful are those that have side effects: assignment expressions, increment and decrement expressions, and function calls. Here are examples of expression statements:</p> <pre><code>x = 5;              /* Assignment expression. */\np++;                /* Increment expression. */\nprintf (\"Done\\n\");  /* Function call expression. */\n*p;                 /* Cause SIGSEGV signal if p is null. */\nx + y;              /* Useless statement without effect. */\n</code></pre> <p>In very unusual circumstances we use an expression statement whose purpose is to get a fault if an address is invalid:</p> <pre><code>volatile char *p;\n\u2026\n*p;                 /* Cause signal if p is null. */\n</code></pre> <p>If the target of <code>p</code> is not declared <code>volatile</code>, the compiler might optimize away the memory access, since it knows that the value isn\u2019t really used. See volatile.</p> <p></p> <p>Next: if-else Statement, Previous: Expression Statement, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#192-if-statement","title":"19.2 <code>if</code> Statement","text":"<p>An <code>if</code> statement computes an expression to decide whether to execute the following statement or not. It looks like this:</p> <pre><code>if (condition)\n  execute-if-true\n</code></pre> <p>The first thing this does is compute the value of <code>condition</code>. If that is true (nonzero), then it executes the statement <code>execute-if-true</code>. If the value of <code>condition</code> is false (zero), it doesn\u2019t execute <code>execute-if-true</code>; instead, it does nothing.</p> <p>This is a complex statement because it contains a component <code>if-true-substatement</code> that is a nested statement. It must be one and only one statement. The way to put multiple statements there is to group them into a block (see Blocks).</p> <p></p> <p>Next: Blocks, Previous: if Statement, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#193-if-else-statement","title":"19.3 <code>if-else</code> Statement","text":"<p>An <code>if</code>-<code>else</code> statement computes an expression to decide which of two nested statements to execute. It looks like this:</p> <pre><code>if (condition)\n  if-true-substatement\nelse\n  if-false-substatement\n</code></pre> <p>The first thing this does is compute the value of <code>condition</code>. If that is true (nonzero), then it executes the statement <code>if-true-substatement</code>. If the value of <code>condition</code> is false (zero), then it executes the statement <code>if-false-substatement</code> instead.</p> <p>This is a complex statement because it contains components <code>if-true-substatement</code> and <code>if-else-substatement</code> that are nested statements. Each must be one and only one statement. The way to put multiple statements in such a component is to group them into a block (see Blocks).</p> <p></p> <p>Next: return Statement, Previous: if-else Statement, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#194-blocks","title":"19.4 Blocks","text":"<p>A block is a construct that contains multiple statements of any kind. It begins with \u2018<code>{</code>\u2019 and ends with \u2018<code>}</code>\u2019, and has a series of statements and declarations in between. Another name for blocks is compound statements.</p> <p>Is a block a statement? Yes and no. It doesn\u2019t look like a normal statement\u2014it does not end with a semicolon. But you can use it like a statement; anywhere that a statement is required or allowed, you can write a block and consider that block a statement.</p> <p>So far it seems that a block is a kind of statement with an unusual syntax. But that is not entirely true: a function body is also a block, and that block is definitely not a statement. The text after a function header is not treated as a statement; only a function body is allowed there, and nothing else would be meaningful there.</p> <p>In a formal grammar we would have to choose\u2014either a block is a kind of statement or it is not. But this manual is meant for humans, not for parser generators. The clearest answer for humans is, \u201ca block is a statement, in some ways.\u201d</p> <p> </p> <p>A block that isn\u2019t a function body is called an internal block or a nested block. You can put a nested block directly inside another block, but more often the nested block is inside some complex statement, such as a <code>for</code> statement or an <code>if</code> statement.</p> <p>There are two uses for nested blocks in C:</p> <ul> <li>To specify the scope for local declarations. For instance, a local     variable\u2019s scope is the rest of the innermost containing block.</li> <li>To write a series of statements where, syntactically, one statement     is called for. For instance, the <code>execute-if-true</code> of an <code>if</code>     statement is one statement. To put multiple statements there, they     have to be wrapped in a block, like this:         if (x &lt; 0)           {             printf (\"x was negative\\n\");             x = -x;           }</li> </ul> <p>This example (repeated from above) shows a nested block which serves both purposes: it includes two statements (plus a declaration) in the body of a <code>while</code> statement, and it provides the scope for the declaration of <code>q</code>.</p> <pre><code>void\nfree_intlist (struct intlistlink *p)\n{\n  while (p)\n    {\n      struct intlistlink *q = p;\n      p = p-&gt;next;\n      free (q);\n    }\n}\n</code></pre> <p></p> <p>Next: Loop Statements, Previous: Blocks, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#195-return-statement","title":"19.5 <code>return</code> Statement","text":"<p>The <code>return</code> statement makes the containing function return immediately. It has two forms. This one specifies no value to return:</p> <pre><code>return;\n</code></pre> <p>That form is meant for functions whose return type is <code>void</code> (see The Void Type). You can also use it in a function that returns nonvoid data, but that\u2019s a bad idea, since it makes the function return garbage.</p> <p>The form that specifies a value looks like this:</p> <pre><code>return value;\n</code></pre> <p>which computes the expression <code>value</code> and makes the function return that. If necessary, the value undergoes type conversion to the function\u2019s declared return value type, which works like assigning the value to a variable of that type.</p> <p></p> <p>Next: switch Statement, Previous: return Statement, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#196-loop-statements","title":"19.6 Loop Statements","text":"<p>You can use a loop statement when you need to execute a series of statements repeatedly, making an iteration. C provides several different kinds of loop statements, described in the following subsections.</p> <p>Every kind of loop statement is a complex statement because contains a component, here called <code>body</code>, which is a nested statement. Most often the body is a block.</p> \u2022 while Statement Loop as long as a test expression is true. \u2022 do-while Statement Execute a loop once, with further looping as long as a test expression is true. \u2022 break Statement End a loop immediately. \u2022 for Statement Iterative looping. \u2022 Example of for An example of iterative looping. \u2022 Omitted for-Expressions for-loop expression options. \u2022 for-Index Declarations for-loop declaration options. \u2022 continue Statement Begin the next cycle of a loop. <p></p> <p>Next: do-while Statement, Up: Loop Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1961-while-statement","title":"19.6.1 <code>while</code> Statement","text":"<p>The <code>while</code> statement is the simplest loop construct. It looks like this:</p> <pre><code>while (test)\n  body\n</code></pre> <p>Here, <code>body</code> is a statement (often a nested block) to repeat, and <code>test</code> is the test expression that controls whether to repeat it again. Each iteration of the loop starts by computing <code>test</code> and, if it is true (nonzero), that means the loop should execute <code>body</code> again and then start over.</p> <p>Here\u2019s an example of advancing to the last structure in a chain of structures chained through the <code>next</code> field:</p> <pre><code>#include &lt;stddef.h&gt; /* Defines NULL. */\n\u2026\nwhile (chain-&gt;next != NULL)\n  chain = chain-&gt;next;\n</code></pre> <p>This code assumes the chain isn\u2019t empty to start with; if the chain is empty (that is, if <code>chain</code> is a null pointer), the code gets a <code>SIGSEGV</code> signal trying to dereference that null pointer (see Signals).</p> <p></p> <p>Next: break Statement, Previous: while Statement, Up: Loop Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1962-do-while-statement","title":"19.6.2 <code>do-while</code> Statement","text":"<p>The <code>do</code>\u2013<code>while</code> statement is a simple loop construct that performs the test at the end of the iteration.</p> <pre><code>do\n  body\nwhile (test);\n</code></pre> <p>Here, <code>body</code> is a statement (possibly a block) to repeat, and <code>test</code> is an expression that controls whether to repeat it again.</p> <p>Each iteration of the loop starts by executing <code>body</code>. Then it computes <code>test</code> and, if it is true (nonzero), that means to go back and start over with <code>body</code>. If <code>test</code> is false (zero), then the loop stops repeating and execution moves on past it.</p> <p></p> <p>Next: for Statement, Previous: do-while Statement, Up: Loop Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1963-break-statement","title":"19.6.3 <code>break</code> Statement","text":"<p>The <code>break</code> statement looks like \u2018<code>break;</code>\u2019. Its effect is to exit immediately from the innermost loop construct or <code>switch</code> statement (see switch Statement).</p> <p>For example, this loop advances <code>p</code> until the next null character or newline.</p> <pre><code>while (*p)\n  {\n    /* End loop if we have reached a newline.  */\n    if (*p == '\\n')\n      break;\n    p++\n  }\n</code></pre> <p>When there are nested loops, the <code>break</code> statement exits from the innermost loop containing it.</p> <pre><code>struct list_if_tuples\n{\n  struct list_if_tuples next;\n  int length;\n  data *contents;\n};\n\nvoid\nprocess_all_elements (struct list_if_tuples *list)\n{\n  while (list)\n    {\n      /* Process all the elements in this node\u2019s vector,\n         stopping when we reach one that is null.  */\n      for (i = 0; i &lt; list-&gt;length; i++\n        {\n          /* Null element terminates this node\u2019s vector.  */\n          if (list-&gt;contents[i] == NULL)\n            /* Exit the for loop.  */\n            break;\n          /* Operate on the next element.  */\n          process_element (list-&gt;contents[i]);\n        }\n\n      list = list-&gt;next;\n    }\n}\n</code></pre> <p>The only way in C to exit from an outer loop is with <code>goto</code> (see goto Statement).</p> <p></p> <p>Next: Example of for, Previous: break Statement, Up: Loop Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1964-for-statement","title":"19.6.4 <code>for</code> Statement","text":"<p>A <code>for</code> statement uses three expressions written inside a parenthetical group to define the repetition of the loop. The first expression says how to prepare to start the loop. The second says how to test, before each iteration, whether to continue looping. The third says how to advance, at the end of an iteration, for the next iteration. All together, it looks like this:</p> <pre><code>for (start; continue-test; advance)\n  body\n</code></pre> <p>The first thing the <code>for</code> statement does is compute <code>start</code>. The next thing it does is compute the expression <code>continue-test</code>. If that expression is false (zero), the <code>for</code> statement finishes immediately, so <code>body</code> is executed zero times.</p> <p>However, if <code>continue-test</code> is true (nonzero), the <code>for</code> statement executes <code>body</code>, then <code>advance</code>. Then it loops back to the not-quite-top to test <code>continue-test</code> again. But it does not compute <code>start</code> again.</p> <p></p> <p>Next: Omitted for-Expressions, Previous: for Statement, Up: Loop Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1965-example-of-for","title":"19.6.5 Example of <code>for</code>","text":"<p>Here is the <code>for</code> statement from the iterative Fibonacci function:</p> <pre><code>int i;\nfor (i = 1; i &lt; n; ++i)\n  /* If n is 1 or less, the loop runs zero times,  */\n  /* since i &lt; n is false the first time.  */\n  {\n    /* Now last is fib (i)\n       and prev is fib (i - 1).  */\n    /* Compute fib (i + 1).  */\n    int next = prev + last;\n    /* Shift the values down.  */\n    prev = last;\n    last = next;\n    /* Now last is fib (i + 1)\n       and prev is fib (i).\n       But that won\u2019t stay true for long,\n       because we are about to increment i.  */\n  }\n</code></pre> <p>In this example, <code>start</code> is <code>i = 1</code>, meaning set <code>i</code> to 1. <code>continue-test</code> is <code>i &lt; n</code>, meaning keep repeating the loop as long as <code>i</code> is less than <code>n</code>. <code>advance</code> is <code>i++</code>, meaning increment <code>i</code> by 1. The body is a block that contains a declaration and two statements.</p> <p></p> <p>Next: for-Index Declarations, Previous: Example of for, Up: Loop Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1966-omitted-for-expressions","title":"19.6.6 Omitted <code>for</code>-Expressions","text":"<p>A fully-fleshed <code>for</code> statement contains all these parts,</p> <pre><code>for (start; continue-test; advance)\n  body\n</code></pre> <p>but you can omit any of the three expressions inside the parentheses. The parentheses and the two semicolons are required syntactically, but the expressions between them may be missing. A missing expression means this loop doesn\u2019t use that particular feature of the <code>for</code> statement.</p> <p>Instead of using <code>start</code>, you can do the loop preparation before the <code>for</code> statement: the effect is the same. So we could have written the beginning of the previous example this way:</p> <pre><code>int i = 0;\nfor (; i &lt; n; ++i)\n</code></pre> <p>instead of this way:</p> <pre><code>int i;\nfor (i = 0; i &lt; n; ++i)\n</code></pre> <p>Omitting <code>continue-test</code> means the loop runs forever (or until something else causes exit from it). Statements inside the loop can test conditions for termination and use \u2018<code>break;</code>\u2019 to exit. This is more flexible since you can put those tests anywhere in the loop, not solely at the beginning.</p> <p>Putting an expression in <code>advance</code> is almost equivalent to writing it at the end of the loop body; it does almost the same thing. The only difference is for the <code>continue</code> statement (see continue Statement). So we could have written this:</p> <pre><code>for (i = 0; i &lt; n;)\n  {\n    \u2026\n    ++i;\n  }\n</code></pre> <p>instead of this:</p> <pre><code>for (i = 0; i &lt; n; ++i)\n  {\n    \u2026\n  }\n</code></pre> <p>The choice is mainly a matter of what is more readable for programmers. However, there is also a syntactic difference: <code>advance</code> is an expression, not a statement. It can\u2019t include loops, blocks, declarations, etc.</p> <p></p> <p>Next: continue Statement, Previous: Omitted for-Expressions, Up: Loop Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1967-for-index-declarations","title":"19.6.7 <code>for</code>-Index Declarations","text":"<p>You can declare loop-index variables directly in the <code>start</code> portion of the <code>for</code>-loop, like this:</p> <pre><code>for (int i = 0; i &lt; n; ++i)\n  {\n    \u2026\n  }\n</code></pre> <p>This kind of <code>start</code> is limited to a single declaration; it can declare one or more variables, separated by commas, all of which are the same <code>basetype</code> (<code>int</code>, in this example):</p> <pre><code>for (int i = 0, j = 1, *p = NULL; i &lt; n; ++i, ++j, ++p)\n  {\n    \u2026\n  }\n</code></pre> <p>The scope of these variables is the <code>for</code> statement as a whole. See Variable Declarations for a explanation of <code>basetype</code>.</p> <p>Variables declared in <code>for</code> statements should have initializers. Omitting the initialization gives the variables unpredictable initial values, so this code is erroneous.</p> <pre><code>for (int i; i &lt; n; ++i)\n  {\n    \u2026\n  }\n</code></pre> <p></p> <p>Previous: for-Index Declarations, Up: Loop Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1968-continue-statement","title":"19.6.8 <code>continue</code> Statement","text":"<p>The <code>continue</code> statement looks like \u2018<code>continue;</code>\u2019, and its effect is to jump immediately to the end of the innermost loop construct. If it is a <code>for</code>-loop, the next thing that happens is to execute the loop\u2019s <code>advance</code> expression.</p> <p>For example, this loop increments <code>p</code> until the next null character or newline, and operates (in some way not shown) on all the characters in the line except for spaces. All it does with spaces is skip them.</p> <pre><code>for (;*p; ++p)\n  {\n    /* End loop if we have reached a newline.  */\n    if (*p == '\\n')\n      break;\n    /* Pay no attention to spaces.  */\n    if (*p == ' ')\n      continue;\n    /* Operate on the next character.  */\n    \u2026\n  }\n</code></pre> <p>Executing \u2018<code>continue;</code>\u2019 skips the loop body but it does not skip the <code>advance</code> expression, <code>p++</code>.</p> <p>We could also write it like this:</p> <pre><code>for (;*p; ++p)\n  {\n    /* Exit if we have reached a newline.  */\n    if (*p == '\\n')\n      break;\n    /* Pay no attention to spaces.  */\n    if (*p != ' ')\n      {\n        /* Operate on the next character.  */\n        \u2026\n      }\n  }\n</code></pre> <p>The advantage of using <code>continue</code> is that it reduces the depth of nesting.</p> <p>Contrast <code>continue</code> with the <code>break</code> statement. See break Statement.</p> <p></p> <p>Next: switch Example, Previous: Loop Statements, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#197-switch-statement","title":"19.7 <code>switch</code> Statement","text":"<p>The <code>switch</code> statement selects code to run according to the value of an expression. The expression, in parentheses, follows the keyword <code>switch</code>. After that come all the cases to select among, inside braces. It looks like this:</p> <pre><code>switch (selector)\n  {\n    cases\u2026\n  }\n</code></pre> <p>A case can look like this:</p> <pre><code>case value:\n  statements\n  break;\n</code></pre> <p>which means \u201ccome here if <code>selector</code> happens to have the value <code>value</code>,\u201d or like this (a GNU C extension):</p> <pre><code>case rangestart ... rangeend:\n  statements\n  break;\n</code></pre> <p>which means \u201ccome here if <code>selector</code> happens to have a value between <code>rangestart</code> and <code>rangeend</code> (inclusive).\u201d See Case Ranges.</p> <p>The values in <code>case</code> labels must reduce to integer constants. They can use arithmetic, and <code>enum</code> constants, but they cannot refer to data in memory, because they have to be computed at compile time. It is an error if two <code>case</code> labels specify the same value, or ranges that overlap, or if one is a range and the other is a value in that range.</p> <p>You can also define a default case to handle \u201cany other value,\u201d like this:</p> <pre><code>default:\n  statements\n  break;\n</code></pre> <p>If the <code>switch</code> statement has no <code>default:</code> label, then it does nothing when the value matches none of the cases.</p> <p>The brace-group inside the <code>switch</code> statement is a block, and you can declare variables with that scope just as in any other block (see Blocks). However, initializers in these declarations won\u2019t necessarily be executed every time the <code>switch</code> statement runs, so it is best to avoid giving them initializers.</p> <p><code>break;</code> inside a <code>switch</code> statement exits immediately from the <code>switch</code> statement. See break Statement.</p> <p>If there is no <code>break;</code> at the end of the code for a case, execution continues into the code for the following case. This happens more often by mistake than intentionally, but since this feature is used in real code, we cannot eliminate it.</p> <p>Warning: When one case is intended to fall through to the next, write a comment like \u2018<code>falls through</code>\u2019 to say it\u2019s intentional. That way, other programmers won\u2019t assume it was an error and \u201cfix\u201d it erroneously.</p> <p>Consecutive <code>case</code> statements could, pedantically, be considered an instance of falling through, but we don\u2019t consider or treat them that way because they won\u2019t confuse anyone.</p> <p></p> <p>Next: Duffs Device, Previous: switch Statement, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#198-example-of-switch","title":"19.8 Example of <code>switch</code>","text":"<p>Here\u2019s an example of using the <code>switch</code> statement to distinguish among characters:</p> <p></p> <pre><code>struct vp { int vowels, punct; };\n\nstruct vp\ncount_vowels_and_punct (char *string)\n{\n  int c;\n  int vowels = 0;\n  int punct = 0;\n  /* Don\u2019t change the parameter itself.  */\n  /* That helps in debugging.  */\n  char *p = string;\n  struct vp value;\n\n  while (c = *p++)\n    switch (c)\n      {\n        case 'y':\n        case 'Y':\n          /* We assume y_is_consonant will check surrounding\n                letters to determine whether this y is a vowel.  */\n          if (y_is_consonant (p - 1))\n            break;\n\n          /* Falls through */\n\n        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n        case 'u':\n        case 'A':\n        case 'E':\n        case 'I':\n        case 'O':\n        case 'U':\n          vowels++;\n          break;\n\n        case '.':\n        case ',':\n        case ':':\n        case ';':\n        case '?':\n        case '!':\n        case '\\\"':\n        case '\\'':\n          punct++;\n          break;\n      }\n\n  value.vowels = vowels;\n  value.punct = punct;\n\n  return value;\n}\n</code></pre> <p></p> <p>Next: Case Ranges, Previous: switch Example, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#199-duffs-device","title":"19.9 Duff\u2019s Device","text":"<p>The cases in a <code>switch</code> statement can be inside other control constructs. For instance, we can use a technique known as Duff\u2019s device to optimize this simple function,</p> <pre><code>void\ncopy (char *to, char *from, int count)\n{\n  while (count &gt; 0)\n    *to++ = *from++, count--;\n}\n</code></pre> <p>which copies memory starting at <code>from</code> to memory starting at <code>to</code>.</p> <p>Duff\u2019s device involves unrolling the loop so that it copies several characters each time around, and using a <code>switch</code> statement to enter the loop body at the proper point:</p> <pre><code>void\ncopy (char *to, char *from, int count)\n{\n  if (count &lt;= 0)\n    return;\n  int n = (count + 7) / 8;\n  switch (count % 8)\n    {\n      do {\n        case 0: *to++ = *from++;\n        case 7: *to++ = *from++;\n        case 6: *to++ = *from++;\n        case 5: *to++ = *from++;\n        case 4: *to++ = *from++;\n        case 3: *to++ = *from++;\n        case 2: *to++ = *from++;\n        case 1: *to++ = *from++;\n        } while (--n &gt; 0);\n    }\n}\n</code></pre> <p></p> <p>Next: Null Statement, Previous: Duffs Device, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1910-case-ranges","title":"19.10 Case Ranges","text":"<p>You can specify a range of consecutive values in a single <code>case</code> label, like this:</p> <pre><code>case low ... high:\n</code></pre> <p>This has the same effect as the proper number of individual <code>case</code> labels, one for each integer value from <code>low</code> to <code>high</code>, inclusive.</p> <p>This feature is especially useful for ranges of ASCII character codes:</p> <pre><code>case 'A' ... 'Z':\n</code></pre> <p>Be careful: with integers, write spaces around the <code>...</code> to prevent it from being parsed wrong. For example, write this:</p> <pre><code>case 1 ... 5:\n</code></pre> <p>rather than this:</p> <pre><code>case 1...5:\n</code></pre> <p></p> <p>Next: goto Statement, Previous: Case Ranges, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1911-null-statement","title":"19.11 Null Statement","text":"<p>A null statement is just a semicolon. It does nothing.</p> <p>A null statement is a placeholder for use where a statement is grammatically required, but there is nothing to be done. For instance, sometimes all the work of a <code>for</code>-loop is done in the <code>for</code>-header itself, leaving no work for the body. Here is an example that searches for the first newline in <code>array</code>:</p> <pre><code>for (p = array; *p != '\\n'; p++)\n  ;\n</code></pre> <p></p> <p>Next: Local Labels, Previous: Null Statement, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1912-goto-statement-and-labels","title":"19.12 <code>goto</code> Statement and Labels","text":"<p>The <code>goto</code> statement looks like this:</p> <pre><code>goto label;\n</code></pre> <p>Its effect is to transfer control immediately to another part of the current function\u2014where the label named <code>label</code> is defined.</p> <p>An ordinary label definition looks like this:</p> <pre><code>label:\n</code></pre> <p>and it can appear before any statement. You can\u2019t use <code>default</code> as a label, since that has a special meaning for <code>switch</code> statements.</p> <p>An ordinary label doesn\u2019t need a separate declaration; defining it is enough.</p> <p>Here\u2019s an example of using <code>goto</code> to implement a loop equivalent to <code>do</code>\u2013<code>while</code>:</p> <pre><code>{\n loop_restart:\n  body\n  if (condition)\n    goto loop_restart;\n}\n</code></pre> <p>The name space of labels is separate from that of variables and functions. Thus, there is no error in using a single name in both ways:</p> <pre><code>{\n  int foo;    // Variable foo.\n foo:         // Label foo.\n  body\n  if (foo &gt; 0)  // Variable foo.\n    goto foo;   // Label foo.\n}\n</code></pre> <p>Blocks have no effect on ordinary labels; each label name is defined throughout the whole of the function it appears in. It looks strange to jump into a block with <code>goto</code>, but it works. For example,</p> <pre><code>if (x &lt; 0)\n  goto negative;\nif (y &lt; 0)\n  {\n   negative:\n    printf (\"Negative\\n\");\n    return;\n  }\n</code></pre> <p>If the goto jumps into the scope of a variable, it does not initialize the variable. For example, if <code>x</code> is negative,</p> <pre><code>if (x &lt; 0)\n  goto negative;\nif (y &lt; 0)\n  {\n    int i = 5;\n   negative:\n    printf (\"Negative, and i is %d\\n\", i);\n    return;\n  }\n</code></pre> <p>prints junk because <code>i</code> was not initialized.</p> <p>If the block declares a variable-length automatic array, jumping into it gives a compilation error. However, jumping out of the scope of a variable-length array works fine, and deallocates its storage.</p> <p>A label can\u2019t come directly before a declaration, so the code can\u2019t jump directly to one. For example, this is not allowed:</p> <pre><code>{\n  goto foo;\nfoo:\n  int x = 5;\n  bar(&amp;x);\n}\n</code></pre> <p>The workaround is to add a statement, even an empty statement, directly after the label. For example:</p> <pre><code>{\n  goto foo;\nfoo:\n  ;\n  int x = 5;\n  bar(&amp;x);\n}\n</code></pre> <p>Likewise, a label can\u2019t be the last thing in a block. The workaround solution is the same: add a semicolon after the label.</p> <p>These unnecessary restrictions on labels make no sense, and ought in principle to be removed; but they do only a little harm since labels and <code>goto</code> are rarely the best way to write a program.</p> <p>These examples are all artificial; it would be more natural to write them in other ways, without <code>goto</code>. For instance, the clean way to write the example that prints \u2018<code>Negative</code>\u2019 is this:</p> <pre><code>if (x &lt; 0 || y &lt; 0)\n  {\n    printf (\"Negative\\n\");\n    return;\n  }\n</code></pre> <p>It is hard to construct simple examples where <code>goto</code> is actually the best way to write a program. Its rare good uses tend to be in complex code, thus not apt for the purpose of explaining the meaning of <code>goto</code>.</p> <p>The only good time to use <code>goto</code> is when it makes the code simpler than any alternative. Jumping backward is rarely desirable, because usually the other looping and control constructs give simpler code. Using <code>goto</code> to jump forward is more often desirable, for instance when a function needs to do some processing in an error case and errors can occur at various different places within the function.</p> <p></p> <p>Next: Labels as Values, Previous: goto Statement, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1913-locally-declared-labels","title":"19.13 Locally Declared Labels","text":"<p>In GNU C you can declare local labels in any nested block scope. A local label is used in a <code>goto</code> statement just like an ordinary label, but you can only reference it within the block in which it was declared.</p> <p>A local label declaration looks like this:</p> <pre><code>__label__ label;\n</code></pre> <p>or</p> <pre><code>__label__ label1, label2, \u2026;\n</code></pre> <p>Local label declarations must come at the beginning of the block, before any ordinary declarations or statements.</p> <p>The label declaration declares the label name, but does not define the label itself. That\u2019s done in the usual way, with <code>label``:</code>, before one of the statements in the block.</p> <p>The local label feature is useful for complex macros. If a macro contains nested loops, a <code>goto</code> can be useful for breaking out of them. However, an ordinary label whose scope is the whole function cannot be used: if the macro can be expanded several times in one function, the label will be multiply defined in that function. A local label avoids this problem. For example:</p> <pre><code>#define SEARCH(value, array, target)              \\\ndo {                                              \\\n  __label__ found;                                \\\n  __auto_type _SEARCH_target = (target);          \\\n  __auto_type _SEARCH_array = (array);            \\\n  int i, j;                                       \\\n  int value;                                      \\\n  for (i = 0; i &lt; max; i++)                       \\\n    for (j = 0; j &lt; max; j++)                     \\\n      if (_SEARCH_array[i][j] == _SEARCH_target)  \\\n        { (value) = i; goto found; }              \\\n  (value) = -1;                                   \\\n found:;                                          \\\n} while (0)\n</code></pre> <p>This could also be written using a statement expression (see Statement Exprs):</p> <pre><code>#define SEARCH(array, target)                     \\\n({                                                \\\n  __label__ found;                                \\\n  __auto_type _SEARCH_target = (target);      \\\n  __auto_type _SEARCH_array = (array);     \\\n  int i, j;                                       \\\n  int value;                                      \\\n  for (i = 0; i &lt; max; i++)                       \\\n    for (j = 0; j &lt; max; j++)                     \\\n      if (_SEARCH_array[i][j] == _SEARCH_target)  \\\n        { value = i; goto found; }                \\\n  value = -1;                                     \\\n found:                                           \\\n  value;                                          \\\n})\n</code></pre> <p>Ordinary labels are visible throughout the function where they are defined, and only in that function. However, explicitly declared local labels of a block are visible in nested function definitions inside that block. See Nested Functions, for details.</p> <p>See goto Statement.</p> <p></p> <p>Next: Statement Exprs, Previous: Local Labels, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1914-labels-as-values","title":"19.14 Labels as Values","text":"<p>In GNU C, you can get the address of a label defined in the current function (or a local label defined in the containing function) with the unary operator \u2018<code>&amp;&amp;</code>\u2019. The value has type <code>void *</code>. This value is a constant and can be used wherever a constant of that type is valid. For example:</p> <pre><code>void *ptr;\n\u2026\nptr = &amp;&amp;foo;\n</code></pre> <p>To use these values requires a way to jump to one. This is done with the computed goto statement<sup>5</sup>, <code>goto *``exp``;</code>. For example,</p> <pre><code>goto *ptr;\n</code></pre> <p>Any expression of type <code>void *</code> is allowed.</p> <p>See goto Statement.</p> \u2022 Label Value Uses Examples of using label values. \u2022 Label Value Caveats Limitations of label values. <p></p> <p>Next: Label Value Caveats, Up: Labels as Values \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#19141-label-value-uses","title":"19.14.1 Label Value Uses","text":"<p>One use for label-valued constants is to initialize a static array to serve as a jump table:</p> <pre><code>static void *array[] = { &amp;&amp;foo, &amp;&amp;bar, &amp;&amp;hack };\n</code></pre> <p>Then you can select a label with indexing, like this:</p> <pre><code>goto *array[i];\n</code></pre> <p>Note that this does not check whether the subscript is in bounds\u2014array indexing in C never checks that.</p> <p>You can make the table entries offsets instead of addresses by subtracting one label from the others. Here is an example:</p> <pre><code>static const int array[] = { &amp;&amp;foo - &amp;&amp;foo, &amp;&amp;bar - &amp;&amp;foo,\n                             &amp;&amp;hack - &amp;&amp;foo };\ngoto *(&amp;&amp;foo + array[i]);\n</code></pre> <p>Using offsets is preferable in shared libraries, as it avoids the need for dynamic relocation of the array elements; therefore, the array can be read-only.</p> <p>An array of label values or offsets serves a purpose much like that of the <code>switch</code> statement. The <code>switch</code> statement is cleaner, so use <code>switch</code> by preference when feasible.</p> <p>Another use of label values is in an interpreter for threaded code. The labels within the interpreter function can be stored in the threaded code for super-fast dispatching.</p> <p></p> <p>Previous: Label Value Uses, Up: Labels as Values \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#19142-label-value-caveats","title":"19.14.2 Label Value Caveats","text":"<p>Jumping to a label defined in another function does not work. It can cause unpredictable results.</p> <p>The best way to avoid this is to store label values only in automatic variables, or static variables whose names are declared within the function. Never pass them as arguments.</p> <p></p> <p>An optimization known as cloning generates multiple simplified variants of a function\u2019s code, for use with specific fixed arguments. Using label values in certain ways, such as saving the address in one call to the function and using it again in another call, would make cloning give incorrect results. These functions must disable cloning.</p> <p>Inlining calls to the function would also result in multiple copies of the code, each with its own value of the same label. Using the label in a computed goto is no problem, because the computed goto inhibits inlining. However, using the label value in some other way, such as an indication of where an error occurred, would be optimized wrong. These functions must disable inlining.</p> <p>To prevent inlining or cloning of a function, specify <code>__attribute__((__noinline__,__noclone__))</code> in its definition. See Attributes.</p> <p>When a function uses a label value in a static variable initializer, that automatically prevents inlining or cloning the function.</p> <p></p> <p>Previous: Labels as Values, Up: Statements \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#1915-statements-and-declarations-in-expressions","title":"19.15 Statements and Declarations in Expressions","text":"<p>A block enclosed in parentheses can be used as an expression in GNU C. This provides a way to use local variables, loops and switches within an expression. We call it a statement expression.</p> <p>Recall that a block is a sequence of statements surrounded by braces. In this construct, parentheses go around the braces. For example:</p> <pre><code>({ int y = foo (); int z;\n   if (y &gt; 0) z = y;\n   else z = - y;\n   z; })\n</code></pre> <p>is a valid (though slightly more complex than necessary) expression for the absolute value of <code>foo ()</code>.</p> <p>The last statement in the block should be an expression statement; an expression followed by a semicolon, that is. The value of this expression serves as the value of statement expression. If the last statement is anything else, the statement expression\u2019s value is <code>void</code>.</p> <p>This feature is mainly useful in making macro definitions compute each operand exactly once. See Macros and Auto Type.</p> <p>Statement expressions are not allowed in expressions that must be constant, such as the value for an enumerator, the width of a bit-field, or the initial value of a static variable.</p> <p>Jumping into a statement expression\u2014with <code>goto</code>, or using a <code>switch</code> statement outside the statement expression\u2014is an error. With a computed <code>goto</code> (see Labels as Values), the compiler can\u2019t detect the error, but it still won\u2019t work.</p> <p>Jumping out of a statement expression is permitted, but since subexpressions in C are not computed in a strict order, it is unpredictable which other subexpressions will have been computed by then. For example,</p> <pre><code>  foo (), (({ bar1 (); goto a; 0; }) + bar2 ()), baz();\n</code></pre> <p>calls <code>foo</code> and <code>bar1</code> before it jumps, and never calls <code>baz</code>, but may or may not call <code>bar2</code>. If <code>bar2</code> does get called, that occurs after <code>foo</code> and before <code>bar1</code>.</p> <p></p> <p>Next: Type Qualifiers, Previous: Statements, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#20-variables","title":"20 Variables","text":"<p>Every variable used in a C program needs to be made known by a declaration. It can be used only after it has been declared. It is an error to declare a variable name more than once in the same scope; an exception is that <code>extern</code> declarations and tentative definitions can coexist with another declaration of the same variable.</p> <p>Variables can be declared anywhere within a block or file. (Older versions of C required that all variable declarations within a block occur before any statements.)</p> <p>Variables declared within a function or block are local to it. This means that the variable name is visible only until the end of that function or block, and the memory space is allocated only while control is within it.</p> <p>Variables declared at the top level in a file are called file-scope. They are assigned fixed, distinct memory locations, so they retain their values for the whole execution of the program.</p> \u2022 Variable Declarations Name a variable and and reserve space for it. \u2022 Initializers Assigning initial values to variables. \u2022 Designated Inits Assigning initial values to array elements at particular array indices. \u2022 Auto Type Obtaining the type of a variable. \u2022 Local Variables Variables declared in function definitions. \u2022 File-Scope Variables Variables declared outside of function definitions. \u2022 Static Local Variables Variables declared within functions, but with permanent storage allocation. \u2022 Extern Declarations Declaring a variable which is allocated somewhere else. \u2022 Allocating File-Scope When is space allocated for file-scope variables? \u2022 auto and register Historically used storage directions. \u2022 Omitting Types The bad practice of declaring variables with implicit type. <p></p> <p>Next: Initializers, Up: Variables \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#201-variable-declarations","title":"20.1 Variable Declarations","text":"<p>Here\u2019s what a variable declaration looks like:</p> <pre><code>keywords basetype decorated-variable [= init];\n</code></pre> <p>The <code>keywords</code> specify how to handle the scope of the variable name and the allocation of its storage. Most declarations have no keywords because the defaults are right for them.</p> <p>C allows these keywords to come before or after <code>basetype</code>, or even in the middle of it as in <code>unsigned static int</code>, but don\u2019t do that\u2014it would surprise other programmers. Always write the keywords first.</p> <p>The <code>basetype</code> can be any of the predefined types of C, or a type keyword defined with <code>typedef</code>. It can also be <code>struct ``tag</code>, <code>union ``tag</code>, or <code>enum ``tag</code>. In addition, it can include type qualifiers such as <code>const</code> and <code>volatile</code> (see Type Qualifiers).</p> <p>In the simplest case, <code>decorated-variable</code> is just the variable name. That declares the variable with the type specified by <code>basetype</code>. For instance,</p> <pre><code>int foo;\n</code></pre> <p>uses <code>int</code> as the <code>basetype</code> and <code>foo</code> as the <code>decorated-variable</code>. It declares <code>foo</code> with type <code>int</code>.</p> <pre><code>struct tree_node foo;\n</code></pre> <p>declares <code>foo</code> with type <code>struct tree_node</code>.</p> \u2022 Declaring Arrays and Pointers Declaration syntax for variables of array and pointer types. \u2022 Combining Variable Declarations More than one variable declaration in a single statement. <p></p> <p>Next: Combining Variable Declarations, Up: Variable Declarations \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2011-declaring-arrays-and-pointers","title":"20.1.1 Declaring Arrays and Pointers","text":"<p>To declare a variable that is an array, write <code>variable``[``length``]</code> for <code>decorated-variable</code>:</p> <pre><code>int foo[5];\n</code></pre> <p>To declare a variable that has a pointer type, write <code>*``variable</code> for <code>decorated-variable</code>:</p> <pre><code>struct list_elt *foo;\n</code></pre> <p>These constructs nest. For instance,</p> <pre><code>int foo[3][5];\n</code></pre> <p>declares <code>foo</code> as an array of 3 arrays of 5 integers each,</p> <pre><code>struct list_elt *foo[5];\n</code></pre> <p>declares <code>foo</code> as an array of 5 pointers to structures, and</p> <pre><code>struct list_elt **foo;\n</code></pre> <p>declares <code>foo</code> as a pointer to a pointer to a structure.</p> <pre><code>int **(*foo[30])(int, double);\n</code></pre> <p>declares <code>foo</code> as an array of 30 pointers to functions (see Function Pointers), each of which must accept two arguments (one <code>int</code> and one <code>double</code>) and return type <code>int **</code>.</p> <pre><code>void\nbar (int size)\n{\n  int foo[size];\n  \u2026\n}\n</code></pre> <p>declares <code>foo</code> as an array of integers with a size specified at run time when the function <code>bar</code> is called.</p> <p></p> <p>Previous: Declaring Arrays and Pointers, Up: Variable Declarations \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2012-combining-variable-declarations","title":"20.1.2 Combining Variable Declarations","text":"<p>When multiple declarations have the same <code>keywords</code> and <code>basetype</code>, you can combine them using commas. Thus,</p> <pre><code>keywords basetype\n   decorated-variable-1 [= init1],\n   decorated-variable-2 [= init2];\n</code></pre> <p>is equivalent to</p> <pre><code>keywords basetype\n   decorated-variable-1 [= init1];\nkeywords basetype\n   decorated-variable-2 [= init2];\n</code></pre> <p>Here are some simple examples:</p> <pre><code>int a, b;\nint a = 1, b = 2;\nint a, *p, array[5];\nint a = 0, *p = &amp;a, array[5] = {1, 2};\n</code></pre> <p>In the last two examples, <code>a</code> is an <code>int</code>, <code>p</code> is a pointer to <code>int</code>, and <code>array</code> is an array of 5 <code>int</code>s. Since the initializer for <code>array</code> specifies only two elements, the other three elements are initialized to zero.</p> <p></p> <p>Next: Designated Inits, Previous: Variable Declarations, Up: Variables \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#202-initializers","title":"20.2 Initializers","text":"<p>A variable\u2019s declaration, unless it is <code>extern</code>, should also specify its initial value. For numeric and pointer-type variables, the initializer is an expression for the value. If necessary, it is converted to the variable\u2019s type, just as in an assignment.</p> <p>You can also initialize a local structure-type (see Structures) or local union-type (see Unions) variable this way, from an expression whose value has the same type. But you can\u2019t initialize an array this way (see Arrays), since arrays are not first-class objects in C (see Limitations of C Arrays) and there is no array assignment.</p> <p>You can initialize arrays and structures componentwise, with a list of the elements or components. You can initialize a union with any one of its alternatives.</p> <ul> <li> <p>A component-wise initializer for an array consists of element values     surrounded by \u2018<code>{</code><code>\u2026</code><code>}</code>\u2019. If the values     in the initializer don\u2019t cover all the elements in the array, the     remaining elements are initialized to zero.</p> <p>You can omit the size of the array when you declare it, and let the initializer specify the size:</p> <pre><code>int array[] = { 3, 9, 12 };\n</code></pre> </li> <li> <p>A component-wise initializer for a structure consists of field     values surrounded by \u2018<code>{</code><code>\u2026</code><code>}</code>\u2019. Write     the field values in the same order as the fields are declared in the     structure. If the values in the initializer don\u2019t cover all the     fields in the structure, the remaining fields are initialized to     zero.</p> </li> <li> <p>The initializer for a union-type variable has the form     <code>{ ``value`` }</code>, where <code>value</code> initializes the first alternative     in the union definition.</p> </li> </ul> <p>For an array of arrays, a structure containing arrays, an array of structures, etc., you can nest these constructs. For example,</p> <pre><code>struct point { double x, y; };\n\nstruct point series[]\n  = { {0, 0}, {1.5, 2.8}, {99, 100.0004} };\n</code></pre> <p>You can omit a pair of inner braces if they contain the right number of elements for the sub-value they initialize, so that no elements or fields need to be filled in with zeros. But don\u2019t do that very much, as it gets confusing.</p> <p>An array of <code>char</code> can be initialized using a string constant. Recall that the string constant includes an implicit null character at the end (see String Constants). Using a string constant as initializer means to use its contents as the initial values of the array elements. Here are examples:</p> <pre><code>char text[6] = \"text!\";     /* Includes the null. */\nchar text[5] = \"text!\";     /* Excludes the null. */\nchar text[] = \"text!\";      /* Gets length 6. */\nchar text[]\n  = { 't', 'e', 'x', 't', '!', 0 };  /* same as above. */\nchar text[] = { \"text!\" };  /* Braces are optional. */\n</code></pre> <p>and this kind of initializer can be nested inside braces to initialize structures or arrays that contain a <code>char</code>-array.</p> <p>In like manner, you can use a wide string constant to initialize an array of <code>wchar_t</code>.</p> <p></p> <p>Next: Auto Type, Previous: Initializers, Up: Variables \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#203-designated-initializers","title":"20.3 Designated Initializers","text":"<p>In a complex structure or long array, it\u2019s useful to indicate which field or element we are initializing.</p> <p>To designate specific array elements during initialization, include the array index in brackets, and an assignment operator, for each element:</p> <pre><code>int foo[10] = { [3] = 42, [7] = 58 };\n</code></pre> <p>This does the same thing as:</p> <pre><code>int foo[10] = { 0, 0, 0, 42, 0, 0, 0, 58, 0, 0 };\n</code></pre> <p>The array initialization can include non-designated element values alongside designated indices; these follow the expected ordering of the array initialization, so that</p> <pre><code>int foo[10] = { [3] = 42, 43, 44, [7] = 58 };\n</code></pre> <p>does the same thing as:</p> <pre><code>int foo[10] = { 0, 0, 0, 42, 43, 44, 0, 58, 0, 0 };\n</code></pre> <p>Note that you can only use constant expressions as array index values, not variables.</p> <p>If you need to initialize a subsequence of sequential array elements to the same value, you can specify a range:</p> <pre><code>int foo[100] = { [0 ... 19] = 42, [20 ... 99] = 43 };\n</code></pre> <p>Using a range this way is a GNU C extension.</p> <p>When subsequence ranges overlap, each element is initialized by the last specification that applies to it. Thus, this initialization is equivalent to the previous one.</p> <pre><code>int foo[100] = { [0 ... 99] = 43, [0 ... 19] = 42 };\n</code></pre> <p>as the second overrides the first for elements 0 through 19.</p> <p>The value used to initialize a range of elements is evaluated only once, for the first element in the range. So for example, this code</p> <pre><code>int random_values[100]\n  = { [0 ... 99] = get_random_number() };\n</code></pre> <p>would initialize all 100 elements of the array <code>random_values</code> to the same value\u2014probably not what is intended.</p> <p>Similarly, you can initialize specific fields of a structure variable by specifying the field name prefixed with a dot:</p> <pre><code>struct point { int x; int y; };\n\nstruct point foo = { .y = 42; };\n</code></pre> <p>The same syntax works for union variables as well:</p> <pre><code>union int_double { int i; double d; };\n\nunion int_double foo = { .d = 34 };\n</code></pre> <p>This casts the integer value 34 to a double and stores it in the union variable <code>foo</code>.</p> <p>You can designate both array elements and structure elements in the same initialization; for example, here\u2019s an array of point structures:</p> <pre><code>struct point point_array[10] = { [4].y = 32, [6].y = 39 };\n</code></pre> <p>Along with the capability to specify particular array and structure elements to initialize comes the possibility of initializing the same element more than once:</p> <pre><code>int foo[10] = { [4] = 42, [4] = 98 };\n</code></pre> <p>In such a case, the last initialization value is retained.</p> <p></p> <p>Next: Local Variables, Previous: Designated Inits, Up: Variables \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#204-referring-to-a-type-with-__auto_type","title":"20.4 Referring to a Type with <code>__auto_type</code>","text":"<p>You can declare a variable copying the type from the initializer by using <code>__auto_type</code> instead of a particular type. Here\u2019s an example:</p> <pre><code>#define max(a,b) \\\n  ({ __auto_type _a = (a); \\\n      __auto_type _b = (b); \\\n    _a &gt; _b ? _a : _b })\n</code></pre> <p>This defines <code>_a</code> to be of the same type as <code>a</code>, and <code>_b</code> to be of the same type as <code>b</code>. This is a useful thing to do in a macro that ought to be able to handle any type of data (see Macros and Auto Type).</p> <p>The original GNU C method for obtaining the type of a value is to use <code>typeof</code>, which takes as an argument either a value or the name of a type. The previous example could also be written as:</p> <pre><code>#define max(a,b) \\\n  ({ typeof(a) _a = (a); \\\n      typeof(b) _b = (b); \\\n    _a &gt; _b ? _a : _b })\n</code></pre> <p><code>typeof</code> is more flexible than <code>__auto_type</code>; however, the principal use case for <code>typeof</code> is in variable declarations with initialization, which is exactly what <code>__auto_type</code> handles.</p> <p></p> <p>Next: File-Scope Variables, Previous: Auto Type, Up: Variables \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#205-local-variables","title":"20.5 Local Variables","text":"<p>Declaring a variable inside a function definition (see Function Definitions) makes the variable name local to the containing block\u2014that is, the containing pair of braces. More precisely, the variable\u2019s name is visible starting just after where it appears in the declaration, and its visibility continues until the end of the block.</p> <p>Local variables in C are generally automatic variables: each variable\u2019s storage exists only from the declaration to the end of the block. Execution of the declaration allocates the storage, computes the initial value, and stores it in the variable. The end of the block deallocates the storage.<sup>6</sup></p> <p>Warning: Two declarations for the same local variable in the same scope are an error.</p> <p>Warning: Automatic variables are stored in the run-time stack. The total space for the program\u2019s stack may be limited; therefore, in using very large arrays, it may be necessary to allocate them in some other way to stop the program from crashing.</p> <p>Warning: If the declaration of an automatic variable does not specify an initial value, the variable starts out containing garbage. In this example, the value printed could be anything at all:</p> <pre><code>{\n  int i;\n\n  printf (\"Print junk %d\\n\", i);\n}\n</code></pre> <p>In a simple test program, that statement is likely to print 0, simply because every process starts with memory zeroed. But don\u2019t rely on it to be zero\u2014that is erroneous.</p> <p>Note: Make sure to store a value into each local variable (by assignment, or by initialization) before referring to its value.</p> <p></p> <p>Next: Static Local Variables, Previous: Local Variables, Up: Variables \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#206-file-scope-variables","title":"20.6 File-Scope Variables","text":"<p>A variable declaration at the top level in a file (not inside a function definition) declares a file-scope variable. Loading a program allocates the storage for all the file-scope variables in it, and initializes them too.</p> <p>Each file-scope variable is either static (limited to one compilation module) or global (shared with all compilation modules in the program). To make the variable static, write the keyword <code>static</code> at the start of the declaration. Omitting <code>static</code> makes the variable global.</p> <p>The initial value for a file-scope variable can\u2019t depend on the contents of storage, and can\u2019t call any functions.</p> <pre><code>int foo = 5;         /* Valid. */\nint bar = foo;       /* Invalid! */\nint bar = sin (1.0); /* Invalid! */\n</code></pre> <p>But it can use the address of another file-scope variable:</p> <pre><code>int foo;\nint *bar = &amp;foo;     /* Valid. */\nint arr[5];\nint *bar3 = &amp;arr[3]; /* Valid. */\nint *bar4 = arr + 4; /* Valid. */\n</code></pre> <p>It is valid for a module to have multiple declarations for a file-scope variable, as long as they are all global or all static, but at most one declaration can specify an initial value for it.</p> <p></p> <p>Next: Extern Declarations, Previous: File-Scope Variables, Up: Variables \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#207-static-local-variables","title":"20.7 Static Local Variables","text":"<p>The keyword <code>static</code> in a local variable declaration says to allocate the storage for the variable permanently, just like a file-scope variable, even if the declaration is within a function.</p> <p>Here\u2019s an example:</p> <pre><code>int\nincrement_counter ()\n{\n  static int counter = 0;\n  return ++counter;\n}\n</code></pre> <p>The scope of the name <code>counter</code> runs from the declaration to the end of the containing block, just like an automatic local variable, but its storage is permanent, so the value persists from one call to the next. As a result, each call to <code>increment_counter</code> returns a different, unique value.</p> <p>The initial value of a static local variable has the same limitations as for file-scope variables: it can\u2019t depend on the contents of storage or call any functions. It can use the address of a file-scope variable or a static local variable, because those addresses are determined before the program runs.</p> <p></p> <p>Next: Allocating File-Scope, Previous: Static Local Variables, Up: Variables \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#208-extern-declarations","title":"20.8 <code>extern</code> Declarations","text":"<p>An <code>extern</code> declaration is used to refer to a global variable whose principal declaration comes elsewhere\u2014in the same module, or in another compilation module. It looks like this:</p> <pre><code>extern basetype decorated-variable;\n</code></pre> <p>Its meaning is that, in the current scope, the variable name refers to the file-scope variable of that name\u2014which needs to be declared in a non-<code>extern</code>, non-<code>static</code> way somewhere else.</p> <p>For instance, if one compilation module has this global variable declaration</p> <pre><code>int error_count = 0;\n</code></pre> <p>then other compilation modules can specify this</p> <pre><code>extern int error_count;\n</code></pre> <p>to allow reference to the same variable.</p> <p>The usual place to write an <code>extern</code> declaration is at top level in a source file, but you can write an <code>extern</code> declaration inside a block to make a global or static file-scope variable accessible in that block.</p> <p>Since an <code>extern</code> declaration does not allocate space for the variable, it can omit the size of an array:</p> <pre><code>extern int array[];\n</code></pre> <p>You can use <code>array</code> normally in all contexts where it is converted automatically to a pointer. However, to use it as the operand of <code>sizeof</code> is an error, since the size is unknown.</p> <p>It is valid to have multiple <code>extern</code> declarations for the same variable, even in the same scope, if they give the same type. They do not conflict\u2014they agree. For an array, it is legitimate for some <code>extern</code> declarations can specify the size while others omit it. However, if two declarations give different sizes, that is an error.</p> <p>Likewise, you can use <code>extern</code> declarations at file scope (see File-Scope Variables) followed by an ordinary global (non-static) declaration of the same variable. They do not conflict, because they say compatible things about the same meaning of the variable.</p> <p></p> <p>Next: auto and register, Previous: Extern Declarations, Up: Variables \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#209-allocating-file-scope-variables","title":"20.9 Allocating File-Scope Variables","text":"<p>Some file-scope declarations allocate space for the variable, and some don\u2019t.</p> <p>A file-scope declaration with an initial value must allocate space for the variable; if there are two of such declarations for the same variable, even in different compilation modules, they conflict.</p> <p>An <code>extern</code> declaration never allocates space for the variable. If all the top-level declarations of a certain variable are <code>extern</code>, the variable never gets memory space. If that variable is used anywhere in the program, the use will be reported as an error, saying that the variable is not defined.</p> <p></p> <p>A file-scope declaration without an initial value is called a tentative definition. This is a strange hybrid: it can allocate space for the variable, but does not insist. So it causes no conflict, no error, if the variable has another declaration that allocates space for it, perhaps in another compilation module. But if nothing else allocates space for the variable, the tentative definition will do it. Any number of compilation modules can declare the same variable in this way, and that is sufficient for all of them to use the variable.</p> <p>In programs that are very large or have many contributors, it may be wise to adopt the convention of never using tentative definitions. You can use the compilation option <code>-fno-common</code> to make them an error, or <code>--warn-common</code> to warn about them.</p> <p>If a file-scope variable gets its space through a tentative definition, it starts out containing all zeros.</p> <p></p> <p>Next: Omitting Types, Previous: Allocating File-Scope, Up: Variables \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2010-auto-and-register","title":"20.10 <code>auto</code> and <code>register</code>","text":"<p>For historical reasons, you can write <code>auto</code> or <code>register</code> before a local variable declaration. <code>auto</code> merely emphasizes that the variable isn\u2019t static; it changes nothing.</p> <p><code>register</code> suggests to the compiler storing this variable in a register. However, GNU C ignores this suggestion, since it can choose the best variables to store in registers without any hints.</p> <p>It is an error to take the address of a variable declared <code>register</code>, so you cannot use the unary \u2018<code>&amp;</code>\u2019 operator on it. If the variable is an array, you can\u2019t use it at all (other than as the operand of <code>sizeof</code>), which makes it rather useless.</p> <p></p> <p>Previous: auto and register, Up: Variables \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2011-omitting-types-in-declarations","title":"20.11 Omitting Types in Declarations","text":"<p>The syntax of C traditionally allows omitting the data type in a declaration if it specifies a storage class, a type qualifier (see the next chapter), or <code>auto</code> or <code>register</code>. Then the type defaults to <code>int</code>. For example:</p> <pre><code>auto foo = 42;\n</code></pre> <p>This is bad practice; if you see it, fix it.</p> <p></p> <p>Next: Functions, Previous: Variables, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#21-type-qualifiers","title":"21 Type Qualifiers","text":"<p>A declaration can include type qualifiers to advise the compiler about how the variable will be used. There are three different qualifiers, <code>const</code>, <code>volatile</code> and <code>restrict</code>. They pertain to different issues, so you can use more than one together. For instance, <code>const volatile</code> describes a value that the program is not allowed to change, but might have a different value each time the program examines it. (This might perhaps be a special hardware register, or part of shared memory.)</p> <p>If you are just learning C, you can skip this chapter.</p> \u2022 const Variables whose values don\u2019t change. \u2022 volatile Variables whose values may be accessed or changed outside of the control of this program. \u2022 restrict Pointers Restricted pointers for code optimization. \u2022 restrict Pointer Example Example of how that works. <p></p> <p>Next: volatile, Up: Type Qualifiers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#211-const-variables-and-fields","title":"21.1 <code>const</code> Variables and Fields","text":"<p>You can mark a variable as \u201cconstant\u201d by writing <code>const</code> in front of the declaration. This says to treat any assignment to that variable as an error. It may also permit some compiler optimizations\u2014for instance, to fetch the value only once to satisfy multiple references to it. The construct looks like this:</p> <pre><code>const double pi = 3.14159;\n</code></pre> <p>After this definition, the code can use the variable <code>pi</code> but cannot assign a different value to it.</p> <pre><code>pi = 3.0; /* Error! */\n</code></pre> <p>Simple variables that are constant can be used for the same purposes as enumeration constants, and they are not limited to integers. The constantness of the variable propagates into pointers, too.</p> <p>A pointer type can specify that the target is constant. For example, the pointer type <code>const double *</code> stands for a pointer to a constant <code>double</code>. That\u2019s the type that results from taking the address of <code>pi</code>. Such a pointer can\u2019t be dereferenced in the left side of an assignment.</p> <pre><code>*(&amp;pi) = 3.0; /* Error! */\n</code></pre> <p>Nonconstant pointers can be converted automatically to constant pointers, but not vice versa. For instance,</p> <pre><code>const double *cptr;\ndouble *ptr;\n\ncptr = &amp;pi;    /* Valid. */\ncptr = ptr;    /* Valid. */\nptr = cptr;    /* Error! */\nptr = &amp;pi;     /* Error! */\n</code></pre> <p>This is not an ironclad protection against modifying the value. You can always cast the constant pointer to a nonconstant pointer type:</p> <pre><code>ptr = (double *)cptr;    /* Valid. */\nptr = (double *)&amp;pi;     /* Valid. */\n</code></pre> <p>However, <code>const</code> provides a way to show that a certain function won\u2019t modify the data structure whose address is passed to it. Here\u2019s an example:</p> <pre><code>int\nstring_length (const char *string)\n{\n  int count = 0;\n  while (*string++)\n    count++;\n  return count;\n}\n</code></pre> <p>Using <code>const char *</code> for the parameter is a way of saying this function never modifies the memory of the string itself.</p> <p>In calling <code>string_length</code>, you can specify an ordinary <code>char *</code> since that can be converted automatically to <code>const char *</code>.</p> <p></p> <p>Next: restrict Pointers, Previous: const, Up: Type Qualifiers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#212-volatile-variables-and-fields","title":"21.2 <code>volatile</code> Variables and Fields","text":"<p>The GNU C compiler often performs optimizations that eliminate the need to write or read a variable. For instance,</p> <pre><code>int foo;\nfoo = 1;\nfoo++;\n</code></pre> <p>might simply store the value 2 into <code>foo</code>, without ever storing 1. These optimizations can also apply to structure fields in some cases.</p> <p>If the memory containing <code>foo</code> is shared with another program, or if it is examined asynchronously by hardware, such optimizations could confuse the communication. Using <code>volatile</code> is one way to prevent them.</p> <p>Writing <code>volatile</code> with the type in a variable or field declaration says that the value may be examined or changed for reasons outside the control of the program at any moment. Therefore, the program must execute in a careful way to assure correct interaction with those accesses, whenever they may occur.</p> <p>The simplest use looks like this:</p> <pre><code>volatile int lock;\n</code></pre> <p>This directs the compiler not to do certain common optimizations on use of the variable <code>lock</code>. All the reads and writes for a volatile variable or field are really done, and done in the order specified by the source code. Thus, this code:</p> <pre><code>lock = 1;\nlist = list-&gt;next;\nif (lock)\n  lock_broken (&amp;lock);\nlock = 0;\n</code></pre> <p>really stores the value 1 in <code>lock</code>, even though there is no sign it is really used, and the <code>if</code> statement reads and checks the value of <code>lock</code>, rather than assuming it is still 1.</p> <p>A limited amount of optimization can be done, in principle, on <code>volatile</code> variables and fields: multiple references between two sequence points (see Sequence Points) can be simplified together.</p> <p>Use of <code>volatile</code> does not eliminate the flexibility in ordering the computation of the operands of most operators. For instance, in <code>lock + foo ()</code>, the order of accessing <code>lock</code> and calling <code>foo</code> is not specified, so they may be done in either order; the fact that <code>lock</code> is <code>volatile</code> has no effect on that.</p> <p></p> <p>Next: restrict Pointer Example, Previous: volatile, Up: Type Qualifiers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#213-restrict-qualified-pointers","title":"21.3 <code>restrict</code>-Qualified Pointers","text":"<p>You can declare a pointer as \u201crestricted\u201d using the <code>restrict</code> type qualifier, like this:</p> <pre><code>int *restrict p = x;\n</code></pre> <p>This enables better optimization of code that uses the pointer.</p> <p>If <code>p</code> is declared with <code>restrict</code>, and then the code references the object that <code>p</code> points to (using <code>*p</code> or <code>p[``i``]</code>), the <code>restrict</code> declaration promises that the code will not access that object in any other way\u2014only through <code>p</code>.</p> <p>For instance, it means the code must not use another pointer to access the same space, as shown here:</p> <pre><code>int *restrict p = whatever;\nint *q = p;\nfoo (*p, *q);\n</code></pre> <p>That contradicts the <code>restrict</code> promise by accessing the object that <code>p</code> points to using <code>q</code>, which bypasses <code>p</code>. Likewise, it must not do this:</p> <pre><code>int *restrict p = whatever;\nstruct { int *a, *b; } s;\ns.a = p;\nfoo (*p, *s.a);\n</code></pre> <p>This example uses a structure field instead of the variable <code>q</code> to hold the other pointer, and that contradicts the promise just the same.</p> <p>The keyword <code>restrict</code> also promises that <code>p</code> won\u2019t point to the allocated space of any automatic or static variable. So the code must not do this:</p> <pre><code>int a;\nint *restrict p = &amp;a;\nfoo (*p, a);\n</code></pre> <p>because that does direct access to the object (<code>a</code>) that <code>p</code> points to, which bypasses <code>p</code>.</p> <p>If the code makes such promises with <code>restrict</code> then breaks them, execution is unpredictable.</p> <p></p> <p>Previous: restrict Pointers, Up: Type Qualifiers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#214-restrict-pointer-example","title":"21.4 <code>restrict</code> Pointer Example","text":"<p>Here are examples where <code>restrict</code> enables real optimization.</p> <p>In this example, <code>restrict</code> assures GCC that the array <code>out</code> points to does not overlap with the array <code>in</code> points to.</p> <pre><code>void\nprocess_data (const char *in,\n              char * restrict out,\n              size_t size)\n{\n  for (i = 0; i &lt; size; i++)\n    out[i] = in[i] + in[i + 1];\n}\n</code></pre> <p>Here\u2019s a simple tree structure, where each tree node holds data of type <code>PAYLOAD</code> plus two subtrees.</p> <pre><code>struct foo\n  {\n    PAYLOAD payload;\n    struct foo *left;\n    struct foo *right;\n  };\n</code></pre> <p>Now here\u2019s a function to null out both pointers in the <code>left</code> subtree.</p> <pre><code>void\nnull_left (struct foo *a)\n{\n  a-&gt;left-&gt;left = NULL;\n  a-&gt;left-&gt;right = NULL;\n}\n</code></pre> <p>Since <code>*a</code> and <code>*a-&gt;left</code> have the same data type, they could legitimately alias (see Aliasing). Therefore, the compiled code for <code>null_left</code> must read <code>a-&gt;left</code> again from memory when executing the second assignment statement.</p> <p>We can enable optimization, so that it does not need to read <code>a-&gt;left</code> again, by writing <code>null_left</code> in a less obvious way.</p> <pre><code>void\nnull_left (struct foo *a)\n{\n  struct foo *b = a-&gt;left;\n  b-&gt;left = NULL;\n  b-&gt;right = NULL;\n}\n</code></pre> <p>A more elegant way to fix this is with <code>restrict</code>.</p> <pre><code>void\nnull_left (struct foo *restrict a)\n{\n  a-&gt;left-&gt;left = NULL;\n  a-&gt;left-&gt;right = NULL;\n}\n</code></pre> <p>Declaring <code>a</code> as <code>restrict</code> asserts that other pointers such as <code>a-&gt;left</code> will not point to the same memory space as <code>a</code>. Therefore, the memory location <code>a-&gt;left-&gt;left</code> cannot be the same memory as <code>a-&gt;left</code>. Knowing this, the compiled code may avoid reloading <code>a-&gt;left</code> for the second statement.</p> <p></p> <p>Next: Compatible Types, Previous: Type Qualifiers, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#22-functions","title":"22 Functions","text":"<p>We have already presented many examples of functions, so if you\u2019ve read this far, you basically understand the concept of a function. It is vital, nonetheless, to have a chapter in the manual that collects all the information about functions.</p> \u2022 Function Definitions Writing the body of a function. \u2022 Function Declarations Declaring the interface of a function. \u2022 Function Calls Using functions. \u2022 Function Call Semantics Call-by-value argument passing. \u2022 Function Pointers Using references to functions. \u2022 The main Function Where execution of a GNU C program begins. \u2022 Advanced Definitions Advanced features of function definitions. \u2022 Obsolete Definitions Obsolete features still used in function definitions in old code. <p></p> <p>Next: Function Declarations, Up: Functions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#221-function-definitions","title":"22.1 Function Definitions","text":"<p>We have already presented many examples of function definitions. To summarize the rules, a function definition looks like this:</p> <pre><code>returntype\nfunctionname (parm_declarations\u2026)\n{\n  body\n}\n</code></pre> <p>The part before the open-brace is called the function header.</p> <p>Write <code>void</code> as the <code>returntype</code> if the function does not return a value.</p> \u2022 Function Parameter Variables Syntax and semantics of function parameters. \u2022 Forward Function Declarations Functions can only be called after they have been defined or declared. \u2022 Static Functions Limiting visibility of a function. \u2022 Arrays as Parameters Functions that accept array arguments. \u2022 Structs as Parameters Functions that accept structure arguments. <p></p> <p>Next: Forward Function Declarations, Up: Function Definitions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2211-function-parameter-variables","title":"22.1.1 Function Parameter Variables","text":"<p>A function parameter variable is a local variable (see Local Variables) used within the function to store the value passed as an argument in a call to the function. Usually we say \u201cfunction parameter\u201d or \u201cparameter\u201d for short, not mentioning the fact that it\u2019s a variable.</p> <p>We declare these variables in the beginning of the function definition, in the parameter list. For example,</p> <pre><code>fib (int n)\n</code></pre> <p>has a parameter list with one function parameter <code>n</code>, which has type <code>int</code>.</p> <p>Function parameter declarations differ from ordinary variable declarations in several ways:</p> <ul> <li> <p>Inside the function definition header, commas separate parameter     declarations, and each parameter needs a complete declaration     including the type. For instance, if a function <code>foo</code> has two <code>int</code>     parameters, write this:</p> <pre><code>foo (int a, int b)\n</code></pre> <p>You can\u2019t share the common <code>int</code> between the two declarations:</p> <pre><code>foo (int a, b)      /* Invalid! */\n</code></pre> </li> <li> <p>A function parameter variable is initialized to whatever value is     passed in the function call, so its declaration cannot specify an     initial value.</p> </li> <li> <p>Writing an array type in a function parameter declaration has the     effect of declaring it as a pointer. The size specified for the     array has no effect at all, and we normally omit the size. Thus,</p> <pre><code>foo (int a[5])\nfoo (int a[])\nfoo (int *a)\n</code></pre> <p>are equivalent.</p> </li> <li> <p>The scope of the parameter variables is the entire function body,     notwithstanding the fact that they are written in the function     header, which is just outside the function body.</p> </li> </ul> <p>If a function has no parameters, it would be most natural for the list of parameters in its definition to be empty. But that, in C, has a special meaning for historical reasons: \u201cDo not check that calls to this function have the right number of arguments.\u201d Thus,</p> <pre><code>int\nfoo ()\n{\n  return 5;\n}\n\nint\nbar (int x)\n{\n  return foo (x);\n}\n</code></pre> <p>would not report a compilation error in passing <code>x</code> as an argument to <code>foo</code>. By contrast,</p> <pre><code>int\nfoo (void)\n{\n  return 5;\n}\n\nint\nbar (int x)\n{\n  return foo (x);\n}\n</code></pre> <p>would report an error because <code>foo</code> is supposed to receive no arguments.</p> <p></p> <p>Next: Static Functions, Previous: Function Parameter Variables, Up: Function Definitions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2212-forward-function-declarations","title":"22.1.2 Forward Function Declarations","text":"<p>The order of the function definitions in the source code makes no difference, except that each function needs to be defined or declared before code uses it.</p> <p>The definition of a function also declares its name for the rest of the containing scope. But what if you want to call the function before its definition? To permit that, write a compatible declaration of the same function, before the first call. A declaration that prefigures a subsequent definition in this way is called a forward declaration. The function declaration can be at top level or within a block, and it applies until the end of the containing scope.</p> <p>See Function Declarations, for more information about these declarations.</p> <p></p> <p>Next: Arrays as Parameters, Previous: Forward Function Declarations, Up: Function Definitions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2213-static-functions","title":"22.1.3 Static Functions","text":"<p>The keyword <code>static</code> in a function definition limits the visibility of the name to the current compilation module. (That\u2019s the same thing <code>static</code> does in variable declarations; see File-Scope Variables.) For instance, if one compilation module contains this code:</p> <pre><code>static int\nfoo (void)\n{\n  \u2026\n}\n</code></pre> <p>then the code of that compilation module can call <code>foo</code> anywhere after the definition, but other compilation modules cannot refer to it at all.</p> <p> </p> <p>To call <code>foo</code> before its definition, it needs a forward declaration, which should use <code>static</code> since the function definition does. For this function, it looks like this:</p> <pre><code>static int foo (void);\n</code></pre> <p>It is generally wise to use <code>static</code> on the definitions of functions that won\u2019t be called from outside the same compilation module. This makes sure that calls are not added in other modules. If programmers decide to change the function\u2019s calling convention, or understand all the consequences of its use, they will only have to check for calls in the same compilation module.</p> <p></p> <p>Next: Structs as Parameters, Previous: Static Functions, Up: Function Definitions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2214-arrays-as-parameters","title":"22.1.4 Arrays as Parameters","text":"<p>Arrays in C are not first-class objects: it is impossible to copy them. So they cannot be passed as arguments like other values. See Limitations of C Arrays. Rather, array parameters work in a special way.</p> \u2022 Array Parm Pointer \u2022 Passing Array Args \u2022 Array Parm Qualifiers <p></p> <p>Next: Passing Array Args, Up: Arrays as Parameters \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#22141-array-parameters-are-pointers","title":"22.1.4.1 Array parameters are pointers","text":"<p>Declaring a function parameter variable as an array really gives it a pointer type. C does this because an expression with array type, if used as an argument in a function call, is converted automatically to a pointer (to the zeroth element of the array). If you declare the corresponding parameter as an \u201carray\u201d, it will work correctly with the pointer value that really gets passed.</p> <p>This relates to the fact that C does not check array bounds in access to elements of the array (see Accessing Array Elements).</p> <p>For example, in this function,</p> <pre><code>void\nclobber4 (int array[20])\n{\n  array[4] = 0;\n}\n</code></pre> <p>the parameter <code>array</code>\u2019s real type is <code>int *</code>; the specified length, 20, has no effect on the program. You can leave out the length and write this:</p> <pre><code>void\nclobber4 (int array[])\n{\n  array[4] = 0;\n}\n</code></pre> <p>or write the parameter declaration explicitly as a pointer:</p> <pre><code>void\nclobber4 (int *array)\n{\n  array[4] = 0;\n}\n</code></pre> <p>They are all equivalent.</p> <p></p> <p>Next: Array Parm Qualifiers, Previous: Array Parm Pointer, Up: Arrays as Parameters \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#22142-passing-array-arguments","title":"22.1.4.2 Passing array arguments","text":"<p>The function call passes this pointer by value, like all argument values in C. However, the result is paradoxical in that the array itself is passed by reference: its contents are treated as shared memory\u2014shared between the caller and the called function, that is. When <code>clobber4</code> assigns to element 4 of <code>array</code>, the effect is to alter element 4 of the array specified in the call.</p> <pre><code>#include &lt;stddef.h&gt;  /* Defines NULL. */\n#include &lt;stdlib.h&gt;  /* Declares malloc, */\n                     /* Defines EXIT_SUCCESS. */\n\nint\nmain (void)\n{\n  int data[] = {1, 2, 3, 4, 5, 6};\n  int i;\n\n  /* Show the initial value of element 4. */\n  for (i = 0; i &lt; 6; i++)\n    printf (\"data[%d] = %d\\n\", i, data[i]);\n\n  printf (\"\\n\");\n\n  clobber4 (data);\n\n  /* Show that element 4 has been changed. */\n  for (i = 0; i &lt; 6; i++)\n    printf (\"data[%d] = %d\\n\", i, data[i]);\n\n  printf (\"\\n\");\n\n  return EXIT_SUCCESS;\n}\n</code></pre> <p>shows that <code>data[4]</code> has become zero after the call to <code>clobber4</code>.</p> <p>The array <code>data</code> has 6 elements, but passing it to a function whose argument type is written as <code>int [20]</code> is not an error, because that really stands for <code>int *</code>. The pointer that is the real argument carries no indication of the length of the array it points into. It is not required to point to the beginning of the array, either. For instance,</p> <pre><code>clobber4 (data+1);\n</code></pre> <p>passes an \u201carray\u201d that starts at element 1 of <code>data</code>, and the effect is to zero <code>data[5]</code> instead of <code>data[4]</code>.</p> <p>If all calls to the function will provide an array of a particular size, you can specify the size of the array to be <code>static</code>:</p> <pre><code>void\nclobber4 (int array[static 20])\n\u2026\n</code></pre> <p>This is a promise to the compiler that the function will always be called with an array of 20 elements, so that the compiler can optimize code accordingly. If the code breaks this promise and calls the function with, for example, a shorter array, unpredictable things may happen.</p> <p></p> <p>Previous: Passing Array Args, Up: Arrays as Parameters \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#22143-type-qualifiers-on-array-parameters","title":"22.1.4.3 Type qualifiers on array parameters","text":"<p>You can use the type qualifiers <code>const</code>, <code>restrict</code>, and <code>volatile</code> with array parameters; for example:</p> <pre><code>void\nclobber4 (volatile int array[20])\n\u2026\n</code></pre> <p>denotes that <code>array</code> is equivalent to a pointer to a volatile <code>int</code>. Alternatively:</p> <pre><code>void\nclobber4 (int array[const 20])\n\u2026\n</code></pre> <p>makes the array parameter equivalent to a constant pointer to an <code>int</code>. If we want the <code>clobber4</code> function to succeed, it would not make sense to write</p> <pre><code>void\nclobber4 (const int array[20])\n\u2026\n</code></pre> <p>as this would tell the compiler that the parameter should point to an array of constant <code>int</code> values, and then we would not be able to store zeros in them.</p> <p>In a function with multiple array parameters, you can use <code>restrict</code> to tell the compiler that each array parameter passed in will be distinct:</p> <pre><code>void\nfoo (int array1[restrict 10], int array2[restrict 10])\n\u2026\n</code></pre> <p>Using <code>restrict</code> promises the compiler that callers will not pass in the same array for more than one <code>restrict</code> array parameter. Knowing this enables the compiler to perform better code optimization. This is the same effect as using <code>restrict</code> pointers (see restrict Pointers), but makes it clear when reading the code that an array of a specific size is expected.</p> <p></p> <p>Previous: Arrays as Parameters, Up: Function Definitions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2215-functions-that-accept-structure-arguments","title":"22.1.5 Functions That Accept Structure Arguments","text":"<p>Structures in GNU C are first-class objects, so using them as function parameters and arguments works in the natural way. This function <code>swapfoo</code> takes a <code>struct foo</code> with two fields as argument, and returns a structure of the same type but with the fields exchanged.</p> <pre><code>struct foo { int a, b; };\n\nstruct foo x;\n\nstruct foo\nswapfoo (struct foo inval)\n{\n  struct foo outval;\n  outval.a = inval.b;\n  outval.b = inval.a;\n  return outval;\n}\n</code></pre> <p>This simpler definition of <code>swapfoo</code> avoids using a local variable to hold the result about to be return, by using a structure constructor (see Structure Constructors), like this:</p> <pre><code>struct foo\nswapfoo (struct foo inval)\n{\n  return (struct foo) { inval.b, inval.a };\n}\n</code></pre> <p>It is valid to define a structure type in a function\u2019s parameter list, as in</p> <pre><code>int\nfrob_bar (struct bar { int a, b; } inval)\n{\n  body\n}\n</code></pre> <p>and <code>body</code> can access the fields of <code>inval</code> since the structure type <code>struct bar</code> is defined for the whole function body. However, there is no way to create a <code>struct bar</code> argument to pass to <code>frob_bar</code>, except with kludges. As a result, defining a structure type in a parameter list is useless in practice.</p> <p></p> <p>Next: Function Calls, Previous: Function Definitions, Up: Functions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#222-function-declarations","title":"22.2 Function Declarations","text":"<p>To call a function, or use its name as a pointer, a function declaration for the function name must be in effect at that point in the code. The function\u2019s definition serves as a declaration of that function for the rest of the containing scope, but to use the function in code before the definition, or from another compilation module, a separate function declaration must precede the use.</p> <p>A function declaration looks like the start of a function definition. It begins with the return value type (<code>void</code> if none) and the function name, followed by argument declarations in parentheses (though these can sometimes be omitted). But that\u2019s as far as the similarity goes: instead of the function body, the declaration uses a semicolon.</p> <p> </p> <p>A declaration that specifies argument types is called a function prototype. You can include the argument names or omit them. The names, if included in the declaration, have no effect, but they may serve as documentation.</p> <p>This form of prototype specifies fixed argument types:</p> <pre><code>rettype function (argtypes\u2026);\n</code></pre> <p>This form says the function takes no arguments:</p> <pre><code>rettype function (void);\n</code></pre> <p>This form declares types for some arguments, and allows additional arguments whose types are not specified:</p> <pre><code>rettype function (argtypes\u2026, ...);\n</code></pre> <p>For a parameter that\u2019s an array of variable length, you can write its declaration with \u2018<code>*</code>\u2019 where the \u201clength\u201d of the array would normally go; for example, these are all equivalent.</p> <pre><code>double maximum (int n, int m, double a[n][m]);\ndouble maximum (int n, int m, double a[*][*]);\ndouble maximum (int n, int m, double a[ ][*]);\ndouble maximum (int n, int m, double a[ ][m]);\n</code></pre> <p>The old-fashioned form of declaration, which is not a prototype, says nothing about the types of arguments or how many they should be:</p> <pre><code>rettype function ();\n</code></pre> <p>Warning: Arguments passed to a function declared without a prototype are converted with the default argument promotions (see Argument Promotions. Likewise for additional arguments whose types are unspecified.</p> <p>Function declarations are usually written at the top level in a source file, but you can also put them inside code blocks. Then the function name is visible for the rest of the containing scope. For example:</p> <pre><code>void\nfoo (char *file_name)\n{\n  void save_file (char *);\n  save_file (file_name);\n}\n</code></pre> <p>If another part of the code tries to call the function <code>save_file</code>, this declaration won\u2019t be in effect there. So the function will get an implicit declaration of the form <code>extern int save_file ();</code>. That conflicts with the explicit declaration here, and the discrepancy generates a warning.</p> <p>The syntax of C traditionally allows omitting the data type in a function declaration if it specifies a storage class or a qualifier. Then the type defaults to <code>int</code>. For example:</p> <pre><code>static foo (double x);\n</code></pre> <p>defaults the return type to <code>int</code>. This is bad practice; if you see it, fix it.</p> <p>Calling a function that is undeclared has the effect of an creating implicit declaration in the innermost containing scope, equivalent to this:</p> <pre><code>extern int function ();\n</code></pre> <p>This declaration says that the function returns <code>int</code> but leaves its argument types unspecified. If that does not accurately fit the function, then the program needs an explicit declaration of the function with argument types in order to call it correctly.</p> <p>Implicit declarations are deprecated, and a function call that creates one causes a warning.</p> <p></p> <p>Next: Function Call Semantics, Previous: Function Declarations, Up: Functions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#223-function-calls","title":"22.3 Function Calls","text":"<p>Starting a program automatically calls the function named <code>main</code> (see The main Function). Aside from that, a function does nothing except when it is called. That occurs during the execution of a function-call expression specifying that function.</p> <p>A function-call expression looks like this:</p> <pre><code>function (arguments\u2026)\n</code></pre> <p>Most of the time, <code>function</code> is a function name. However, it can also be an expression with a function pointer value; that way, the program can determine at run time which function to call.</p> <p>The <code>arguments</code> are a series of expressions separated by commas. Each expression specifies one argument to pass to the function.</p> <p>The list of arguments in a function call looks just like use of the comma operator (see Comma Operator), but the fact that it fills the parentheses of a function call gives it a different meaning.</p> <p>Here\u2019s an example of a function call, taken from an example near the beginning (see Complete Program).</p> <pre><code>printf (\"Fibonacci series item %d is %d\\n\",\n        19, fib (19));\n</code></pre> <p>The three arguments given to <code>printf</code> are a constant string, the integer 19, and the integer returned by <code>fib (19)</code>.</p> <p></p> <p>Next: Function Pointers, Previous: Function Calls, Up: Functions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#224-function-call-semantics","title":"22.4 Function Call Semantics","text":"<p>The meaning of a function call is to compute the specified argument expressions, convert their values according to the function\u2019s declaration, then run the function giving it copies of the converted values. (This method of argument passing is known as call-by-value.) When the function finishes, the value it returns becomes the value of the function-call expression.</p> <p>Call-by-value implies that an assignment to the function argument variable has no direct effect on the caller. For instance,</p> <pre><code>#include &lt;stdlib.h&gt;  /* Defines EXIT_SUCCESS. */\n#include &lt;stdio.h&gt;   /* Declares printf. */\n\nvoid\nsubroutine (int x)\n{\n  x = 5;\n}\n\nvoid\nmain (void)\n{\n  int y = 20;\n  subroutine (y);\n  printf (\"y is %d\\n\", y);\n  return EXIT_SUCCESS;\n}\n</code></pre> <p>prints \u2018<code>y is 20</code>\u2019. Calling <code>subroutine</code> initializes <code>x</code> from the value of <code>y</code>, but this does not establish any other relationship between the two variables. Thus, the assignment to <code>x</code>, inside <code>subroutine</code>, changes only that <code>x</code>.</p> <p>If an argument\u2019s type is specified by the function\u2019s declaration, the function call converts the argument expression to that type if possible. If the conversion is impossible, that is an error.</p> <p>If the function\u2019s declaration doesn\u2019t specify the type of that argument, then the default argument promotions apply. See Argument Promotions.</p> <p></p> <p>Next: The main Function, Previous: Function Call Semantics, Up: Functions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#225-function-pointers","title":"22.5 Function Pointers","text":"<p>A function name refers to a fixed function. Sometimes it is useful to call a function to be determined at run time; to do this, you can use a function pointer value that points to the chosen function (see Pointers).</p> <p>Pointer-to-function types can be used to declare variables and other data, including array elements, structure fields, and union alternatives. They can also be used for function arguments and return values. These types have the peculiarity that they are never converted automatically to <code>void *</code> or vice versa. However, you can do that conversion with a cast.</p> \u2022 Declaring Function Pointers How to declare a pointer to a function. \u2022 Assigning Function Pointers How to assign values to function pointers. \u2022 Calling Function Pointers How to call functions through pointers. <p></p> <p>Next: Assigning Function Pointers, Up: Function Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2251-declaring-function-pointers","title":"22.5.1 Declaring Function Pointers","text":"<p>The declaration of a function pointer variable (or structure field) looks almost like a function declaration, except it has an additional \u2018<code>*</code>\u2019 just before the variable name. Proper nesting requires a pair of parentheses around the two of them. For instance, <code>int (*a) ();</code> says, \u201cDeclare <code>a</code> as a pointer such that <code>*a</code> is an <code>int</code>-returning function.\u201d</p> <p>Contrast these three declarations:</p> <pre><code>/* Declare a function returning char *.  */\nchar *a (char *);\n/* Declare a pointer to a function returning char.  */\nchar (*a) (char *);\n/* Declare a pointer to a function returning char *.  */\nchar *(*a) (char *);\n</code></pre> <p>The possible argument types of the function pointed to are the same as in a function declaration. You can write a prototype that specifies all the argument types:</p> <pre><code>rettype (*function) (arguments\u2026);\n</code></pre> <p>or one that specifies some and leaves the rest unspecified:</p> <pre><code>rettype (*function) (arguments\u2026, ...);\n</code></pre> <p>or one that says there are no arguments:</p> <pre><code>rettype (*function) (void);\n</code></pre> <p>You can also write a non-prototype declaration that says nothing about the argument types:</p> <pre><code>rettype (*function) ();\n</code></pre> <p>For example, here\u2019s a declaration for a variable that should point to some arithmetic function that operates on two <code>double</code>s:</p> <pre><code>double (*binary_op) (double, double);\n</code></pre> <p>Structure fields, union alternatives, and array elements can be function pointers; so can parameter variables. The function pointer declaration construct can also be combined with other operators allowed in declarations. For instance,</p> <pre><code>int **(*foo)();\n</code></pre> <p>declares <code>foo</code> as a pointer to a function that returns type <code>int **</code>, and</p> <pre><code>int **(*foo[30])();\n</code></pre> <p>declares <code>foo</code> as an array of 30 pointers to functions that return type <code>int **</code>.</p> <pre><code>int **(**foo)();\n</code></pre> <p>declares <code>foo</code> as a pointer to a pointer to a function that returns type <code>int **</code>.</p> <p></p> <p>Next: Calling Function Pointers, Previous: Declaring Function Pointers, Up: Function Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2252-assigning-function-pointers","title":"22.5.2 Assigning Function Pointers","text":"<p>Assuming we have declared the variable <code>binary_op</code> as in the previous section, giving it a value requires a suitable function to use. So let\u2019s define a function suitable for the variable to point to. Here\u2019s one:</p> <pre><code>double\ndouble_add (double a, double b)\n{\n  return a+b;\n}\n</code></pre> <p>Now we can give it a value:</p> <pre><code>binary_op = double_add;\n</code></pre> <p>The target type of the function pointer must be upward compatible with the type of the function (see Compatible Types).</p> <p>There is no need for \u2018<code>&amp;</code>\u2019 in front of <code>double_add</code>. Using a function name such as <code>double_add</code> as an expression automatically converts it to the function\u2019s address, with the appropriate function pointer type. However, it is ok to use \u2018<code>&amp;</code>\u2019 if you feel that is clearer:</p> <pre><code>binary_op = &amp;double_add;\n</code></pre> <p></p> <p>Previous: Assigning Function Pointers, Up: Function Pointers \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2253-calling-function-pointers","title":"22.5.3 Calling Function Pointers","text":"<p>To call the function specified by a function pointer, just write the function pointer value in a function call. For instance, here\u2019s a call to the function <code>binary_op</code> points to:</p> <pre><code>binary_op (x, 5)\n</code></pre> <p>Since the data type of <code>binary_op</code> explicitly specifies type <code>double</code> for the arguments, the call converts <code>x</code> and 5 to <code>double</code>.</p> <p>The call conceptually dereferences the pointer <code>binary_op</code> to \u201cget\u201d the function it points to, and calls that function. If you wish, you can explicitly represent the dereference by writing the <code>*</code> operator:</p> <pre><code>(*binary_op) (x, 5)\n</code></pre> <p>The \u2018<code>*</code>\u2019 reminds people reading the code that <code>binary_op</code> is a function pointer rather than the name of a specific function.</p> <p></p> <p>Next: Advanced Definitions, Previous: Function Pointers, Up: Functions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#226-the-main-function","title":"22.6 The <code>main</code> Function","text":"<p>Every complete executable program requires at least one function, called <code>main</code>, which is where execution begins. You do not have to explicitly declare <code>main</code>, though GNU C permits you to do so. Conventionally, <code>main</code> should be defined to follow one of these calling conventions:</p> <pre><code>int main (void) {\u2026}\nint main (int argc, char *argv[]) {\u2026}\nint main (int argc, char *argv[], char *envp[]) {\u2026}\n</code></pre> <p>Using <code>void</code> as the parameter list means that <code>main</code> does not use the arguments. You can write <code>char **argv</code> instead of <code>char *argv[]</code>, and likewise for <code>envp</code>, as the two constructs are equivalent.</p> <p>You can call <code>main</code> from C code, as you can call any other function, though that is an unusual thing to do. When you do that, you must write the call to pass arguments that match the parameters in the definition of <code>main</code>.</p> <p>The <code>main</code> function is not actually the first code that runs when a program starts. In fact, the first code that runs is system code from the file <code>crt0.o</code>. In Unix, this was hand-written assembler code, but in GNU we replaced it with C code. Its job is to find the arguments for <code>main</code> and call that.</p> \u2022 Values from main Returning values from the main function. \u2022 Command-line Parameters Accessing command-line parameters provided to the program. \u2022 Environment Variables Accessing system environment variables. <p></p> <p>Next: Command-line Parameters, Up: The main Function \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2261-returning-values-from-main","title":"22.6.1 Returning Values from <code>main</code>","text":"<p>When <code>main</code> returns, the process terminates. Whatever value <code>main</code> returns becomes the exit status which is reported to the parent process. While nominally the return value is of type <code>int</code>, in fact the exit status gets truncated to eight bits; if <code>main</code> returns the value 256, the exit status is 0.</p> <p>Normally, programs return only one of two values: 0 for success, and 1 for failure. For maximum portability, use the macro values <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code> defined in <code>stdlib.h</code>. Here\u2019s an example:</p> <p> </p> <pre><code>#include &lt;stdlib.h&gt;  /* Defines EXIT_SUCCESS */\n                     /* and EXIT_FAILURE. */\n\nint\nmain (void)\n{\n  \u2026\n  if (foo)\n    return EXIT_SUCCESS;\n  else\n    return EXIT_FAILURE;\n}\n</code></pre> <p>Some types of programs maintain special conventions for various return values; for example, comparison programs including <code>cmp</code> and <code>diff</code> return 1 to indicate a mismatch, and 2 to indicate that the comparison couldn\u2019t be performed.</p> <p></p> <p>Next: Environment Variables, Previous: Values from main, Up: The main Function \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2262-accessing-command-line-parameters","title":"22.6.2 Accessing Command-line Parameters","text":"<p>If the program was invoked with any command-line arguments, it can access them through the arguments of <code>main</code>, <code>argc</code> and <code>argv</code>. (You can give these arguments any names, but the names <code>argc</code> and <code>argv</code> are customary.)</p> <p>The value of <code>argv</code> is an array containing all of the command-line arguments as strings, with the name of the command invoked as the first string. <code>argc</code> is an integer that says how many strings <code>argv</code> contains. Here is an example of accessing the command-line parameters, retrieving the program\u2019s name and checking for the standard <code>--version</code> and <code>--help</code> options:</p> <pre><code>#include &lt;string.h&gt; /* Declare strcmp. */\n\nint\nmain (int argc, char *argv[])\n{\n  char *program_name = argv[0];\n\n  for (int i = 1; i &lt; argc; i++)\n    {\n      if (!strcmp (argv[i], \"--version\"))\n        {\n          /* Print version information and exit. */\n          \u2026\n        }\n      else if (!strcmp (argv[i], \"--help\"))\n        {\n          /* Print help information and exit. */\n          \u2026\n        }\n    }\n  \u2026\n}\n</code></pre> <p></p> <p>Previous: Command-line Parameters, Up: The main Function \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2263-accessing-environment-variables","title":"22.6.3 Accessing Environment Variables","text":"<p>You can optionally include a third parameter to <code>main</code>, another array of strings, to capture the environment variables available to the program. Unlike what happens with <code>argv</code>, there is no additional parameter for the count of environment variables; rather, the array of environment variables concludes with a null pointer.</p> <pre><code>#include &lt;stdio.h&gt;   /* Declares printf. */\n\nint\nmain (int argc, char *argv[], char *envp[])\n{\n  /* Print out all environment variables. */\n  int i = 0;\n  while (envp[i])\n    {\n      printf (\"%s\\n\", envp[i]);\n      i++;\n    }\n}\n</code></pre> <p>Another method of retrieving environment variables is to use the library function <code>getenv</code>, which is defined in <code>stdlib.h</code>. Using <code>getenv</code> does not require defining <code>main</code> to accept the <code>envp</code> pointer. For example, here is a program that fetches and prints the user\u2019s home directory (if defined):</p> <pre><code>#include &lt;stdlib.h&gt;  /* Declares getenv. */\n#include &lt;stdio.h&gt;   /* Declares printf. */\n\nint\nmain (void)\n{\n  char *home_directory = getenv (\"HOME\");\n  if (home_directory)\n    printf (\"My home directory is: %s\\n\", home_directory);\n  else\n    printf (\"My home directory is not defined!\\n\");\n}\n</code></pre> <p></p> <p>Next: Obsolete Definitions, Previous: The main Function, Up: Functions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#227-advanced-function-features","title":"22.7 Advanced Function Features","text":"<p>This section describes some advanced or obscure features for GNU C function definitions. If you are just learning C, you can skip the rest of this chapter.</p> \u2022 Variable-Length Array Parameters Functions that accept arrays of variable length. \u2022 Variable Number of Arguments Variadic functions. \u2022 Nested Functions Defining functions within functions. \u2022 Inline Function Definitions A function call optimization technique. <p></p> <p>Next: Variable Number of Arguments, Up: Advanced Definitions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2271-variable-length-array-parameters","title":"22.7.1 Variable-Length Array Parameters","text":"<p>An array parameter can have variable length: simply declare the array type with a size that isn\u2019t constant. In a nested function, the length can refer to a variable defined in a containing scope. In any function, it can refer to a previous parameter, like this:</p> <pre><code>struct entry\ntester (int len, char data[len][len])\n{\n  \u2026\n}\n</code></pre> <p>Alternatively, in function declarations (but not in function definitions), you can use <code>[*]</code> to denote that the array parameter is of a variable length, such that these two declarations mean the same thing:</p> <pre><code>struct entry\ntester (int len, char data[len][len]);\n\nstruct entry\ntester (int len, char data[*][*]);\n</code></pre> <p>The two forms of input are equivalent in GNU C, but emphasizing that the array parameter is variable-length may be helpful to those studying the code.</p> <p>You can also omit the length parameter, and instead use some other in-scope variable for the length in the function definition:</p> <pre><code>struct entry\ntester (char data[*][*]);\n\u2026\nint dataLength = 20;\n\u2026\nstruct entry\ntester (char data[dataLength][dataLength])\n{\n  \u2026\n}\n</code></pre> <p></p> <p>In GNU C, to pass the array first and the length afterward, you can use a parameter forward declaration, like this:</p> <pre><code>struct entry\ntester (int len; char data[len][len], int len)\n{\n  \u2026\n}\n</code></pre> <p>The \u2018<code>int len</code>\u2019 before the semicolon is the parameter forward declaration; it serves the purpose of making the name <code>len</code> known when the declaration of <code>data</code> is parsed.</p> <p>You can write any number of such parameter forward declarations in the parameter list. They can be separated by commas or semicolons, but the last one must end with a semicolon, which is followed by the \u201creal\u201d parameter declarations. Each forward declaration must match a subsequent \u201creal\u201d declaration in parameter name and data type.</p> <p>Standard C does not support parameter forward declarations.</p> <p></p> <p>Next: Nested Functions, Previous: Variable-Length Array Parameters, Up: Advanced Definitions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2272-variable-length-parameter-lists","title":"22.7.2 Variable-Length Parameter Lists","text":"<p>A function that takes a variable number of arguments is called a variadic function. In C, a variadic function must specify at least one fixed argument with an explicitly declared data type. Additional arguments can follow, and can vary in both quantity and data type.</p> <p>In the function header, declare the fixed parameters in the normal way, then write a comma and an ellipsis: \u2018<code>, ...</code>\u2019. Here is an example of a variadic function header:</p> <pre><code>int add_multiple_values (int number, ...)\n</code></pre> <p> </p> <p>The function body can refer to fixed arguments by their parameter names, but the additional arguments have no names. Accessing them in the function body uses certain standard macros. They are defined in the library header file <code>stdarg.h</code>, so the code must <code>#include</code> that file.</p> <p>In the body, write</p> <pre><code>va_list ap;\nva_start (ap, last_fixed_parameter);\n</code></pre> <p>This declares the variable <code>ap</code> (you can use any name for it) and then sets it up to point before the first additional argument.</p> <p>Then, to fetch the next consecutive additional argument, write this:</p> <pre><code>va_arg (ap, type)\n</code></pre> <p>After fetching all the additional arguments (or as many as need to be used), write this:</p> <pre><code>va_end (ap);\n</code></pre> <p>Here\u2019s an example of a variadic function definition that adds any number of <code>int</code> arguments. The first (fixed) argument says how many more arguments follow.</p> <pre><code>#include &lt;stdarg.h&gt; /* Defines va\u2026 macros. */\n\u2026\n\nint\nadd_multiple_values (int argcount, ...)\n{\n  int counter, total = 0;\n\n  /* Declare a variable of type va_list. */\n  va_list argptr;\n\n  /* Initialize that variable.. */\n  va_start (argptr, argcount);\n\n  for (counter = 0; counter &lt; argcount; counter++)\n    {\n      /* Get the next additional argument. */\n      total += va_arg (argptr, int);\n    }\n\n  /* End use of the argptr variable. */\n  va_end (argptr);\n\n  return total;\n}\n</code></pre> <p>With GNU C, <code>va_end</code> is superfluous, but some other compilers might make <code>va_start</code> allocate memory so that calling <code>va_end</code> is necessary to avoid a memory leak. Before doing <code>va_start</code> again with the same variable, do <code>va_end</code> first.</p> <p></p> <p>Because of this possible memory allocation, it is risky (in principle) to copy one <code>va_list</code> variable to another with assignment. Instead, use <code>va_copy</code>, which copies the substance but allocates separate memory in the variable you copy to. The call looks like <code>va_copy (``to``, ``from``)</code>, where both <code>to</code> and <code>from</code> should be variables of type <code>va_list</code>. In principle, do <code>va_end</code> on each of these variables before its scope ends.</p> <p>Since the additional arguments\u2019 types are not specified in the function\u2019s definition, the default argument promotions (see Argument Promotions) apply to them in function calls. The function definition must take account of this; thus, if an argument was passed as <code>short</code>, the function should get it as <code>int</code>. If an argument was passed as <code>float</code>, the function should get it as <code>double</code>.</p> <p>C has no mechanism to tell the variadic function how many arguments were passed to it, so its calling convention must give it a way to determine this. That\u2019s why <code>add_multiple_values</code> takes a fixed argument that says how many more arguments follow. Thus, you can call the function like this:</p> <pre><code>sum = add_multiple_values (3, 12, 34, 190);\n/* Value is 12+34+190. */\n</code></pre> <p>In GNU C, there is no actual need to use the <code>va_end</code> function. In fact, it does nothing. It\u2019s used for compatibility with other compilers, when that matters.</p> <p>It is a mistake to access variables declared as <code>va_list</code> except in the specific ways described here. Just what that type consists of is an implementation detail, which could vary from one platform to another.</p> <p></p> <p>Next: Inline Function Definitions, Previous: Variable Number of Arguments, Up: Advanced Definitions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2273-nested-functions","title":"22.7.3 Nested Functions","text":"<p>A nested function is a function defined inside another function. (The ability to do this is indispensable for automatic translation of certain programming languages into C.) The nested function\u2019s name is local to the block where it is defined. For example, here we define a nested function named <code>square</code>, then call it twice:</p> <pre><code>foo (double a, double b)\n{\n  double square (double z) { return z * z; }\n\n  return square (a) + square (b);\n}\n</code></pre> <p>The nested function definition can access all the variables of the containing function that are visible at the point of its definition. This is called lexical scoping. For example, here we show a nested function that uses an inherited variable named <code>offset</code>:</p> <pre><code>bar (int *array, int offset, int size)\n{\n  int access (int *array, int index)\n    { return array[index + offset]; }\n  int i;\n  \u2026\n  for (i = 0; i &lt; size; i++)\n    \u2026 access (array, i) \u2026\n}\n</code></pre> <p>Nested function definitions can appear wherever automatic variable declarations are allowed; that is, in any block, interspersed with the other declarations and statements in the block.</p> <p>The nested function\u2019s name is visible only within the parent block; the name\u2019s scope starts from its definition and continues to the end of the containing block. If the nested function\u2019s name is the same as the parent function\u2019s name, there will be no way to refer to the parent function inside the scope of the name of the nested function.</p> <p>Using <code>extern</code> or <code>static</code> on a nested function definition is an error.</p> <p>It is possible to call the nested function from outside the scope of its name by storing its address or passing the address to another function. You can do this safely, but you must be careful:</p> <pre><code>hack (int *array, int size, int addition)\n{\n  void store (int index, int value)\n    { array[index] = value + addition; }\n\n  intermediate (store, size);\n}\n</code></pre> <p>Here, the function <code>intermediate</code> receives the address of <code>store</code> as an argument. If <code>intermediate</code> calls <code>store</code>, the arguments given to <code>store</code> are used to store into <code>array</code>. <code>store</code> also accesses <code>hack</code>\u2019s local variable <code>addition</code>.</p> <p>It is safe for <code>intermediate</code> to call <code>store</code> because <code>hack</code>\u2019s stack frame, with its arguments and local variables, continues to exist during the call to <code>intermediate</code>.</p> <p>Calling the nested function through its address after the containing function has exited is asking for trouble. If it is called after a containing scope level has exited, and if it refers to some of the variables that are no longer in scope, it will refer to memory containing junk or other data. It\u2019s not wise to take the risk.</p> <p>The GNU C Compiler implements taking the address of a nested function using a technique called trampolines. This technique was described in Lexical Closures for C<code>++</code> (Thomas M. Breuel, USENIX C<code>++</code> Conference Proceedings, October 17\u201321, 1988).</p> <p>A nested function can jump to a label inherited from a containing function, provided the label was explicitly declared in the containing function (see Local Labels). Such a jump returns instantly to the containing function, exiting the nested function that did the <code>goto</code> and any intermediate function invocations as well. Here is an example:</p> <pre><code>bar (int *array, int offset, int size)\n{\n  /* Explicitly declare the label failure. */\n  __label__ failure;\n  int access (int *array, int index)\n    {\n      if (index &gt; size)\n        /* Exit this function,\n           and return to bar. */\n        goto failure;\n      return array[index + offset];\n    }\n\n  int i;\n  \u2026\n  for (i = 0; i &lt; size; i++)\n    \u2026 access (array, i) \u2026\n  \u2026\n  return 0;\n\n /* Control comes here from access\n    if it does the goto.  */\n failure:\n  return -1;\n}\n</code></pre> <p>To declare the nested function before its definition, use <code>auto</code> (which is otherwise meaningless for function declarations; see auto and register). For example,</p> <pre><code>bar (int *array, int offset, int size)\n{\n  auto int access (int *, int);\n  \u2026\n  \u2026 access (array, i) \u2026\n  \u2026\n  int access (int *array, int index)\n    {\n      \u2026\n    }\n  \u2026\n}\n</code></pre> <p></p> <p>Previous: Nested Functions, Up: Advanced Definitions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2274-inline-function-definitions","title":"22.7.4 Inline Function Definitions","text":"<p>To declare a function inline, use the <code>inline</code> keyword in its definition. Here\u2019s a simple function that takes a pointer-to-<code>int</code> and increments the integer stored there\u2014declared inline.</p> <pre><code>struct list\n{\n  struct list *first, *second;\n};\n\ninline struct list *\nlist_first (struct list *p)\n{\n  return p-&gt;first;\n}\n\ninline struct list *\nlist_second (struct list *p)\n{\n  return p-&gt;second;\n}\n</code></pre> <p>optimized compilation can substitute the inline function\u2019s body for any call to it. This is called inlining the function. It makes the code that contains the call run faster, significantly so if the inline function is small.</p> <p>Here\u2019s a function that uses <code>list_second</code>:</p> <pre><code>int\npairlist_length (struct list *l)\n{\n  int length = 0;\n  while (l)\n    {\n      length++;\n      l = list_second (l);\n    }\n  return length;\n}\n</code></pre> <p>Substituting the code of <code>list_second</code> into the definition of <code>pairlist_length</code> results in this code, in effect:</p> <pre><code>int\npairlist_length (struct list *l)\n{\n  int length = 0;\n  while (l)\n    {\n      length++;\n      l = l-&gt;second;\n    }\n  return length;\n}\n</code></pre> <p>Since the definition of <code>list_second</code> does not say <code>extern</code> or <code>static</code>, that definition is used only for inlining. It doesn\u2019t generate code that can be called at run time. If not all the calls to the function are inlined, there must be a definition of the same function name in another module for them to call.</p> <p></p> <p>Adding <code>static</code> to an inline function definition means the function definition is limited to this compilation module. Also, it generates run-time code if necessary for the sake of any calls that were not inlined. If all calls are inlined then the function definition does not generate run-time code, but you can force generation of run-time code with the option <code>-fkeep-inline-functions</code>.</p> <p></p> <p>Specifying <code>extern</code> along with <code>inline</code> means the function is external and generates run-time code to be called from other separately compiled modules, as well as inlined. You can define the function as <code>inline</code> without <code>extern</code> in other modules so as to inline calls to the same function in those modules.</p> <p>Why are some calls not inlined? First of all, inlining is an optimization, so non-optimized compilation does not inline.</p> <p>Some calls cannot be inlined for technical reasons. Also, certain usages in a function definition can make it unsuitable for inline substitution. Among these usages are: variadic functions, use of <code>alloca</code>, use of computed goto (see Labels as Values), and use of nonlocal goto. The option <code>-Winline</code> requests a warning when a function marked <code>inline</code> is unsuitable to be inlined. The warning explains what obstacle makes it unsuitable.</p> <p>Just because a call can be inlined does not mean it should be inlined. The GNU C compiler weighs costs and benefits to decide whether inlining a particular call is advantageous.</p> <p>You can force inlining of all calls to a given function that can be inlined, even in a non-optimized compilation. by specifying the \u2018<code>always_inline</code>\u2019 attribute for the function, like this:</p> <pre><code>/* Prototype.  */\ninline void foo (const char) __attribute__((always_inline));\n</code></pre> <p>This is a GNU C extension. See Attributes.</p> <p>A function call may be inlined even if not declared <code>inline</code> in special cases where the compiler can determine this is correct and desirable. For instance, when a static function is called only once, it will very likely be inlined. With <code>-flto</code>, link-time optimization, any function might be inlined. To absolutely prevent inlining of a specific function, specify <code>__attribute__((__noinline__))</code> in the function\u2019s definition.</p> <p></p> <p>Previous: Advanced Definitions, Up: Functions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#228-obsolete-function-features","title":"22.8 Obsolete Function Features","text":"<p>These features of function definitions are still used in old programs, but you shouldn\u2019t write code this way today. If you are just learning C, you can skip this section.</p> \u2022 Old GNU Inlining An older inlining technique. \u2022 Old-Style Function Definitions Original K&amp;R style functions. <p></p> <p>Next: Old-Style Function Definitions, Up: Obsolete Definitions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2281-older-gnu-c-inlining","title":"22.8.1 Older GNU C Inlining","text":"<p>The GNU C spec for inline functions, before GCC version 5, defined <code>extern inline</code> on a function definition to mean to inline calls to it but not generate code for the function that could be called at run time. By contrast, <code>inline</code> without <code>extern</code> specified to generate run-time code for the function. In effect, ISO incompatibly flipped the meanings of these two cases. We changed GCC in version 5 to adopt the ISO specification.</p> <p>Many programs still use these cases with the previous GNU C meanings. You can specify use of those meanings with the option <code>-fgnu89-inline</code>. You can also specify this for a single function with <code>__attribute__ ((gnu_inline))</code>. Here\u2019s an example:</p> <pre><code>inline __attribute__ ((gnu_inline))\nint\ninc (int *a)\n{\n  (*a)++;\n}\n</code></pre> <p></p> <p>Previous: Old GNU Inlining, Up: Obsolete Definitions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2282-old-style-function-definitions","title":"22.8.2 Old-Style Function Definitions","text":"<p>The syntax of C traditionally allows omitting the data type in a function declaration if it specifies a storage class or a qualifier. Then the type defaults to <code>int</code>. For example:</p> <pre><code>static foo (double x);\n</code></pre> <p>defaults the return type to <code>int</code>. This is bad practice; if you see it, fix it.</p> <p>An old-style (or \u201cK&amp;R\u201d) function definition is the way function definitions were written in the 1980s. It looks like this:</p> <pre><code>rettype\nfunction (parmnames)\n  parm_declarations\n{\n  body\n}\n</code></pre> <p>In <code>parmnames</code>, only the parameter names are listed, separated by commas. Then <code>parm_declarations</code> declares their data types; these declarations look just like variable declarations. If a parameter is listed in <code>parmnames</code> but has no declaration, it is implicitly declared <code>int</code>.</p> <p>There is no reason to write a definition this way nowadays, but they can still be seen in older GNU programs.</p> <p>An old-style variadic function definition looks like this:</p> <pre><code>#include &lt;varargs.h&gt;\n\nint\nadd_multiple_values (va_alist)\n    va_dcl\n{\n  int argcount;\n  int counter, total = 0;\n\n  /* Declare a variable of type va_list. */\n  va_list argptr;\n\n  /* Initialize that variable. */\n  va_start (argptr);\n\n  /* Get the first argument (fixed). */\n  argcount = va_arg (int);\n\n  for (counter = 0; counter &lt; argcount; counter++)\n    {\n      /* Get the next additional argument. */\n      total += va_arg (argptr, int);\n    }\n\n  /* End use of the argptr variable. */\n  va_end (argptr);\n\n  return total;\n}\n</code></pre> <p>Note that the old-style variadic function definition has no fixed parameter variables; all arguments must be obtained with <code>va_arg</code>.</p> <p></p> <p>Next: Type Conversions, Previous: Functions, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#23-compatible-types","title":"23 Compatible Types","text":"<p>Declaring a function or variable twice is valid in C only if the two declarations specify compatible types. In addition, some operations on pointers require operands to have compatible target types.</p> <p>In C, two different primitive types are never compatible. Likewise for the defined types <code>struct</code>, <code>union</code> and <code>enum</code>: two separately defined types are incompatible unless they are defined exactly the same way.</p> <p>However, there are a few cases where different types can be compatible:</p> <ul> <li>Every enumeration type is compatible with some integer type. In GNU     C, the choice of integer type depends on the largest enumeration     value.</li> <li>Array types are compatible if the element types are compatible and     the sizes (when specified) match.</li> <li>Pointer types are compatible if the pointer target types are     compatible.</li> <li>Function types that specify argument types are compatible if the     return types are compatible and the argument types are compatible,     argument by argument. In addition, they must all agree in whether     they use <code>...</code> to allow additional arguments.</li> <li>Function types that don\u2019t specify argument types are compatible if     the return types are.</li> <li>Function types that specify the argument types are compatible with     function types that omit them, if the return types are compatible     and the specified argument types are unaltered by the argument     promotions (see Argument Promotions).</li> </ul> <p>In order for types to be compatible, they must agree in their type qualifiers. Thus, <code>const int</code> and <code>int</code> are incompatible. It follows that <code>const int *</code> and <code>int *</code> are incompatible too (they are pointers to types that are not compatible).</p> <p>If two types are compatible ignoring the qualifiers, we call them nearly compatible. (If they are array types, we ignore qualifiers on the element types.<sup>7</sup>) Comparison of pointers is valid if the pointers\u2019 target types are nearly compatible. Likewise, the two branches of a conditional expression may be pointers to nearly compatible target types.</p> <p>If two types are compatible ignoring the qualifiers, and the first type has all the qualifiers of the second type, we say the first is upward compatible with the second. Assignment of pointers requires the assigned pointer\u2019s target type to be upward compatible with the right operand (the new value)\u2019s target type.</p> <p></p> <p>Next: Scope, Previous: Compatible Types, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#24-type-conversions","title":"24 Type Conversions","text":"<p>C converts between data types automatically when that seems clearly necessary. In addition, you can convert explicitly with a cast.</p> \u2022 Explicit Type Conversion Casting a value from one type to another. \u2022 Assignment Type Conversions Automatic conversion by assignment operation. \u2022 Argument Promotions Automatic conversion of function parameters. \u2022 Operand Promotions Automatic conversion of arithmetic operands. \u2022 Common Type When operand types differ, which one is used? <p></p> <p>Next: Assignment Type Conversions, Up: Type Conversions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#241-explicit-type-conversion","title":"24.1 Explicit Type Conversion","text":"<p>You can do explicit conversions using the unary cast operator, which is written as a type designator (see Type Designators) in parentheses. For example, <code>(int)</code> is the operator to cast to type <code>int</code>. Here\u2019s an example of using it:</p> <pre><code>{\n  double d = 5.5;\n\n  printf (\"Floating point value: %f\\n\", d);\n  printf (\"Rounded to integer: %d\\n\", (int) d);\n}\n</code></pre> <p>Using <code>(int) d</code> passes an <code>int</code> value as argument to <code>printf</code>, so you can print it with \u2018<code>%d</code>\u2019. Using just <code>d</code> without the cast would pass the value as <code>double</code>. That won\u2019t work at all with \u2018<code>%d</code>\u2019; the results would be gibberish.</p> <p>To divide one integer by another without rounding, cast either of the integers to <code>double</code> first:</p> <pre><code>(double) dividend / divisor\ndividend / (double) divisor\n</code></pre> <p>It is enough to cast one of them, because that forces the common type to <code>double</code> so the other will be converted automatically.</p> <p>The valid cast conversions are:</p> <ul> <li>One numerical type to another.</li> <li>One pointer type to another. (Converting between pointers that point     to functions and pointers that point to data is not standard C.)</li> <li>A pointer type to an integer type.</li> <li>An integer type to a pointer type.</li> <li>To a union type, from the type of any alternative in the union (see     Unions). (This is a GNU extension.)</li> <li>Anything, to <code>void</code>.</li> </ul> <p></p> <p>Next: Argument Promotions, Previous: Explicit Type Conversion, Up: Type Conversions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#242-assignment-type-conversions","title":"24.2 Assignment Type Conversions","text":"<p>Certain type conversions occur automatically in assignments and certain other contexts. These are the conversions assignments can do:</p> <ul> <li>Converting any numeric type to any other numeric type.</li> <li>Converting <code>void *</code> to any other pointer type (except     pointer-to-function types).</li> <li>Converting any other pointer type to <code>void *</code>. (except     pointer-to-function types).</li> <li>Converting 0 (a null pointer constant) to any pointer type.</li> <li>Converting any pointer type to <code>bool</code>. (The result is 1 if the     pointer is not null.)</li> <li>Converting between pointer types when the left-hand target type is     upward compatible with the right-hand target type. See Compatible     Types.</li> </ul> <p>These type conversions occur automatically in certain contexts, which are:</p> <ul> <li> <p>An assignment converts the type of the right-hand expression to the     type wanted by the left-hand expression. For example,</p> <pre><code>double i;\ni = 5;\n</code></pre> <p>converts 5 to <code>double</code>.</p> </li> <li> <p>A function call, when the function specifies the type for that     argument, converts the argument value to that type. For example,</p> <pre><code>void foo (double);\nfoo (5);\n</code></pre> <p>converts 5 to <code>double</code>.</p> </li> <li> <p>A <code>return</code> statement converts the specified value to the type that     the function is declared to return. For example,</p> <pre><code>double\nfoo ()\n{\n  return 5;\n}\n</code></pre> <p>also converts 5 to <code>double</code>.</p> </li> </ul> <p>In all three contexts, if the conversion is impossible, that constitutes an error.</p> <p></p> <p>Next: Operand Promotions, Previous: Assignment Type Conversions, Up: Type Conversions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#243-argument-promotions","title":"24.3 Argument Promotions","text":"<p>When a function\u2019s definition or declaration does not specify the type of an argument, that argument is passed without conversion in whatever type it has, with these exceptions:</p> <ul> <li> <p>Some narrow numeric values are promoted to a wider type. If the     expression is a narrow integer, such as <code>char</code> or <code>short</code>, the call     converts it automatically to <code>int</code> (see Integer     Types).<sup>8</sup></p> <p>In this example, the expression <code>c</code> is passed as an <code>int</code>:</p> <pre><code>char c = '$';\n\nprintf (\"Character c is '%c'\\n\", c);\n</code></pre> </li> <li> <p>If the expression has type <code>float</code>, the call converts it     automatically to <code>double</code>.</p> </li> <li> <p>An array as argument is converted to a pointer to its zeroth     element.</p> </li> <li> <p>A function name as argument is converted to a pointer to that     function.</p> </li> </ul> <p></p> <p>Next: Common Type, Previous: Argument Promotions, Up: Type Conversions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#244-operand-promotions","title":"24.4 Operand Promotions","text":"<p>The operands in arithmetic operations undergo type conversion automatically. These operand promotions are the same as the argument promotions except without converting <code>float</code> to <code>double</code>. In other words, the operand promotions convert</p> <ul> <li><code>char</code> or <code>short</code> (whether signed or not) to <code>int</code>.</li> <li>an array to a pointer to its zeroth element, and</li> <li>a function name to a pointer to that function.</li> </ul> <p></p> <p>Previous: Operand Promotions, Up: Type Conversions \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#245-common-type","title":"24.5 Common Type","text":"<p>Arithmetic binary operators (except the shift operators) convert their operands to the common type before operating on them. Conditional expressions also convert the two possible results to their common type. Here are the rules for determining the common type.</p> <p>If one of the numbers has a floating-point type and the other is an integer, the common type is that floating-point type. For instance,</p> <pre><code>5.6 * 2   \u21d2 11.2 /* a double value */\n</code></pre> <p>If both are floating point, the type with the larger range is the common type.</p> <p>If both are integers but of different widths, the common type is the wider of the two.</p> <p>If they are integer types of the same width, the common type is unsigned if either operand is unsigned, and it\u2019s <code>long</code> if either operand is <code>long</code>. It\u2019s <code>long long</code> if either operand is <code>long long</code>.</p> <p>These rules apply to addition, subtraction, multiplication, division, remainder, comparisons, and bitwise operations. They also apply to the two branches of a conditional expression, and to the arithmetic done in a modifying assignment operation.</p> <p></p> <p>Next: Preprocessing, Previous: Type Conversions, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#25-scope","title":"25 Scope","text":"<p>Each definition or declaration of an identifier is visible in certain parts of the program, which is typically less than the whole of the program. The parts where it is visible are called its scope.</p> <p>Normally, declarations made at the top-level in the source\u2014that is, not within any blocks and function definitions\u2014are visible for the entire contents of the source file after that point. This is called file scope (see File-Scope Variables).</p> <p>Declarations made within blocks of code, including within function definitions, are visible only within those blocks. This is called block scope. Here is an example:</p> <pre><code>void\nfoo (void)\n{\n  int x = 42;\n}\n</code></pre> <p>In this example, the variable <code>x</code> has block scope; it is visible only within the <code>foo</code> function definition block. Thus, other blocks could have their own variables, also named <code>x</code>, without any conflict between those variables.</p> <p>A variable declared inside a subblock has a scope limited to that subblock,</p> <pre><code>void\nfoo (void)\n{\n  {\n    int x = 42;\n  }\n  // x is out of scope here.\n}\n</code></pre> <p>If a variable declared within a block has the same name as a variable declared outside of that block, the definition within the block takes precedence during its scope:</p> <pre><code>int x = 42;\n\nvoid\nfoo (void)\n{\n  int x = 17;\n  printf (\"%d\\n\", x);\n}\n</code></pre> <p>This prints 17, the value of the variable <code>x</code> declared in the function body block, rather than the value of the variable <code>x</code> at file scope. We say that the inner declaration of <code>x</code> shadows the outer declaration, for the extent of the inner declaration\u2019s scope.</p> <p>A declaration with block scope can be shadowed by another declaration with the same name in a subblock.</p> <pre><code>void\nfoo (void)\n{\n  char *x = \"foo\";\n  {\n    int x = 42;\n    \u2026\n    exit (x / 6);\n  }\n}\n</code></pre> <p>A function parameter\u2019s scope is the entire function body, but it can be shadowed. For example:</p> <pre><code>int x = 42;\n\nvoid\nfoo (int x)\n{\n  printf (\"%d\\n\", x);\n}\n</code></pre> <p>This prints the value of <code>x</code> the function parameter, rather than the value of the file-scope variable <code>x</code>.</p> <p>Labels (see goto Statement) have function scope: each label is visible for the whole of the containing function body, both before and after the label declaration:</p> <pre><code>void\nfoo (void)\n{\n  \u2026\n  goto bar;\n  \u2026\n  {  // Subblock does not affect labels.\n    bar:\n    \u2026\n  }\n  goto bar;\n}\n</code></pre> <p>Except for labels, a declared identifier is not visible to code before its declaration. For example:</p> <pre><code>int x = 5;\nint y = x + 10;\n</code></pre> <p>will work, but:</p> <pre><code>int x = y + 10;\nint y = 5;\n</code></pre> <p>cannot refer to the variable <code>y</code> before its declaration.</p> <p>This is part of the GNU C Intro and Reference Manual and covered by its license.</p> <p></p> <p>Next: Integers in Depth, Previous: Scope, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#26-preprocessing","title":"26 Preprocessing","text":"<p>As the first stage of compiling a C source module, GCC transforms the text with text substitutions and file inclusions. This is called preprocessing.</p> \u2022 Preproc Overview \u2022 Directives \u2022 Preprocessing Tokens \u2022 Header Files \u2022 Macros \u2022 Conditionals \u2022 Diagnostics \u2022 Line Control \u2022 Null Directive <p></p> <p>Next: Directives, Up: Preprocessing \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#261-preprocessing-overview","title":"26.1 Preprocessing Overview","text":"<p>GNU C performs preprocessing on each line of a C program as the first stage of compilation. Preprocessing operates on a line only when it contains a preprocessing directive or uses a macro\u2014all other lines pass through preprocessing unchanged.</p> <p>Here are some jobs that preprocessing does. The rest of this chapter gives the details.</p> <ul> <li>Inclusion of header files. These are files (usually containing     declarations and macro definitions) that can be substituted into     your program.</li> <li>Macro expansion. You can define macros, which are abbreviations     for arbitrary fragments of C code. Preprocessing replaces the macros     with their definitions. Some macros are automatically predefined.</li> <li>Conditional compilation. You can include or exclude parts of the     program according to various conditions.</li> <li>Line control. If you use a program to combine or rearrange source     files into an intermediate file that is then compiled, you can use     line control to inform the compiler where each source line     originally came from.</li> <li>Compilation control. <code>#pragma</code> and <code>_Pragma</code> invoke some special     compiler features in how to handle certain constructs.</li> <li>Diagnostics. You can detect problems at compile time and issue     errors or warnings.</li> </ul> <p>Except for expansion of predefined macros, all these operations happen only if you use preprocessing directives to request them.</p> <p></p> <p>Next: Preprocessing Tokens, Previous: Preproc Overview, Up: Preprocessing \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#262-directives","title":"26.2 Directives","text":"<p>Preprocessing directives are lines in the program that start with \u2018<code>#</code>\u2019. Whitespace is allowed before and after the \u2018<code>#</code>\u2019. The \u2018<code>#</code>\u2019 is followed by an identifier, the directive name. It specifies the operation to perform. Here are a couple of examples:</p> <pre><code>#define LIMIT 51\n  #   undef LIMIT\n# error You screwed up!\n</code></pre> <p>We usually refer to a directive as <code>#``name</code> where <code>name</code> is the directive name. For example, <code>#define</code> means the directive that defines a macro.</p> <p>The \u2018<code>#</code>\u2019 that begins a directive cannot come from a macro expansion. Also, the directive name is not macro expanded. Thus, if <code>foo</code> is defined as a macro expanding to <code>define</code>, that does not make <code>#foo</code> a valid preprocessing directive.</p> <p>The set of valid directive names is fixed. Programs cannot define new preprocessing directives.</p> <p>Some directives require arguments; these make up the rest of the directive line and must be separated from the directive name by whitespace. For example, <code>#define</code> must be followed by a macro name and the intended expansion of the macro.</p> <p>A preprocessing directive cannot cover more than one line. The line can, however, be continued with backslash-newline, or by a \u2018<code>/*</code><code>\u2026</code><code>*/</code>\u2019-style comment that extends past the end of the line. These will be replaced (by nothing, or by whitespace) before the directive is processed.</p> <p></p> <p>Next: Header Files, Previous: Directives, Up: Preprocessing \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#263-preprocessing-tokens","title":"26.3 Preprocessing Tokens","text":"<p>Preprocessing divides C code (minus its comments) into tokens that are similar to C tokens, but not exactly the same. Here are the quirks of preprocessing tokens.</p> <p>The main classes of preprocessing tokens are identifiers, preprocessing numbers, string constants, character constants, and punctuators; there are a few others too.</p> <p>identifier </p> <p>An identifier preprocessing token is syntactically like an identifier in C: any sequence of letters, digits, or underscores, as well as non-ASCII characters represented using \u2018<code>\\U</code>\u2019 or \u2018<code>\\u</code>\u2019, that doesn\u2019t begin with a digit.</p> <p>During preprocessing, the keywords of C have no special significance; at that stage, they are simply identifiers. Thus, you can define a macro whose name is a keyword. The only identifier that is special during preprocessing is <code>defined</code> (see defined).</p> <p>preprocessing number </p> <p>A preprocessing number is something that preprocessing treats textually as a number, including C numeric constants, and other sequences of characters which resemble numeric constants. Preprocessing does not try to verify that a preprocessing number is a valid number in C, and indeed it need not be one.</p> <p>More precisely, preprocessing numbers begin with an optional period, a required decimal digit, and then continue with any sequence of letters, digits, underscores, periods, and exponents. Exponents are the two-character sequences \u2018<code>e+</code>\u2019, \u2018<code>e-</code>\u2019, \u2018<code>E+</code>\u2019, \u2018<code>E-</code>\u2019, \u2018<code>p+</code>\u2019, \u2018<code>p-</code>\u2019, \u2018<code>P+</code>\u2019, and \u2018<code>P-</code>\u2019. (The exponents that begin with \u2018<code>p</code>\u2019 or \u2018<code>P</code>\u2019 are new to C99. They are used for hexadecimal floating-point constants.)</p> <p>The reason behind this unusual syntactic class is that the full complexity of numeric constants is irrelevant during preprocessing. The distinction between lexically valid and invalid floating-point numbers, for example, doesn\u2019t matter at this stage. The use of preprocessing numbers makes it possible to split an identifier at any position and get exactly two tokens, and reliably paste them together using the <code>##</code> operator (see Concatenation).</p> <p>punctuator A punctuator is syntactically like an operator. These are the valid punctuators:</p> <pre><code>[  ]   (  )  {  }  .  -&gt;\n++ --  &amp;  *  +  -  ~  !\n/  %   &lt;&lt; &gt;&gt; &lt;  &gt;  &lt;= &gt;=  ==  !=  ^  |  &amp;&amp;  ||\n?  :   ;  ...\n=  *=  /=  %=  +=  -=  &lt;&lt;=  &gt;&gt;=  &amp;=  ^=  |=\n,  #   ##\n&lt;: :&gt;  &lt;% %&gt;  %:  %:%:\n</code></pre> <p>string constant A string constant in the source code is recognized by preprocessing as a single preprocessing token.</p> <p>character constant A character constant in the source code is recognized by preprocessing as a single preprocessing token.</p> <p>header name Within the <code>#include</code> directive, preprocessing recognizes a header name token. It consists of \u2018<code>\"``name``\"</code>\u2019, where <code>name</code> is a sequence of source characters other than newline and \u2018<code>\"</code>\u2019, or \u2018<code>&lt;``name``&gt;</code>\u2019, where <code>name</code> is a sequence of source characters other than newline and \u2018<code>&gt;</code>\u2019.</p> <p>In practice, it is more convenient to think that the <code>#include</code> line is exempt from tokenization.</p> <p>other Any other character that\u2019s valid in a C source program is treated as a separate preprocessing token.</p> <p>Once the program is broken into preprocessing tokens, they remain separate until the end of preprocessing. Macros that generate two consecutive tokens insert whitespace to keep them separate, if necessary. For example,</p> <pre><code>#define foo() bar\nfoo()baz\n     \u2192 bar baz\nnot\n     \u2192 barbaz\n</code></pre> <p>The only exception is with the <code>##</code> preprocessing operator, which pastes tokens together (see Concatenation).</p> <p>Preprocessing treats the null character (code 0) as whitespace, but generates a warning for it because it may be invisible to the user (many terminals do not display it at all) and its presence in the file is probably a mistake.</p> <p></p> <p>Next: Macros, Previous: Preprocessing Tokens, Up: Preprocessing \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#264-header-files","title":"26.4 Header Files","text":"<p>A header file is a file of C code, typically containing C declarations and macro definitions (see Macros), to be shared between several source files. You request the use of a header file in your program by including it, with the C preprocessing directive <code>#include</code>.</p> <p>Header files serve two purposes.</p> <ul> <li> System header files     declare the interfaces to parts of the operating system. You include     them in your program to supply the definitions and declarations that     you need to invoke system calls and libraries.</li> <li>Program-specific header files contain declarations for interfaces     between the source files of a particular program. It is a good idea     to create a header file for related declarations and macro     definitions if all or most of them are needed in several different     source files.</li> </ul> <p>Including a header file produces the same results as copying the header file into each source file that needs it. Such copying would be time-consuming and error-prone. With a header file, the related declarations appear in only one place. If they need to be changed, you can change them in one place, and programs that include the header file will then automatically use the new version when next recompiled. The header file eliminates the labor of finding and changing all the copies as well as the risk that a failure to change one copy will result in inconsistencies within a program.</p> <p>In C, the usual convention is to give header files names that end with <code>.h</code>. It is most portable to use only letters, digits, dashes, and underscores in header file names, and at most one dot.</p> <p>The operation of including another source file isn\u2019t actually limited to the sort of code we put into header files. You can put any sort of C code into a separate file, then use <code>#include</code> to copy it virtually into other C source files. But that is a strange thing to do.</p> \u2022 include Syntax \u2022 include Operation \u2022 Search Path \u2022 Once-Only Headers \u2022 Computed Includes <p></p> <p>Next: include Operation, Up: Header Files \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2641-include-syntax","title":"26.4.1 <code>#include</code> Syntax","text":"<p>You can specify inclusion of user and system header files with the preprocessing directive <code>#include</code>. It has two variants:</p> <p><code>#include &lt;``file``&gt;</code> This variant is used for system header files. It searches for a file named <code>file</code> in a standard list of system directories. You can prepend directories to this list with the <code>-I</code> option (see Invoking GCC in Using the GNU Compiler Collection).</p> <p><code>#include \"``file``\"</code> This variant is used for header files of your own program. It searches for a file named <code>file</code> first in the directory containing the current file, then in the quote directories, then the same directories used for <code>&lt;``file``&gt;</code>. You can prepend directories to the list of quote directories with the <code>-iquote</code> option.</p> <p>The argument of <code>#include</code>, whether delimited with quote marks or angle brackets, behaves like a string constant in that comments are not recognized, and macro names are not expanded. Thus, <code>#include\u00a0&lt;x/*y&gt;</code> specifies inclusion of a system header file named <code>x/*y</code>.</p> <p>However, if backslashes occur within <code>file</code>, they are considered ordinary text characters, not escape characters: character escape sequences such as used in string constants in C are not meaningful here. Thus, <code>#include\u00a0\"x\\n\\\\y\"</code> specifies a filename containing three backslashes. By the same token, there is no way to escape \u2018<code>\"</code>\u2019 or \u2018<code>&gt;</code>\u2019 to include it in the header file name if it would instead end the file name.</p> <p>Some systems interpret \u2018<code>\\</code>\u2019 as a file name component separator. All these systems also interpret \u2018<code>/</code>\u2019 the same way. It is most portable to use only \u2018<code>/</code>\u2019.</p> <p>It is an error to put anything other than comments on the <code>#include</code> line after the file name.</p> <p></p> <p>Next: Search Path, Previous: include Syntax, Up: Header Files \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2642-include-operation","title":"26.4.2 <code>#include</code> Operation","text":"<p>The <code>#include</code> directive works by scanning the specified header file as input before continuing with the rest of the current file. The result of preprocessing consists of the text already generated, followed by the result of preprocessing the included file, followed by whatever results from the text after the <code>#include</code> directive. For example, if you have a header file <code>header.h</code> as follows,</p> <pre><code>char *test (void);\n</code></pre> <p>and a main program called <code>program.c</code> that uses the header file, like this,</p> <pre><code>int x;\n#include \"header.h\"\n\nint\nmain (void)\n{\n  puts (test ());\n}\n</code></pre> <p>the result is equivalent to putting this text in <code>program.c</code>:</p> <pre><code>int x;\nchar *test (void);\n\nint\nmain (void)\n{\n  puts (test ());\n}\n</code></pre> <p>Included files are not limited to declarations and macro definitions; those are merely the typical uses. Any fragment of a C program can be included from another file. The include file could even contain the beginning of a statement that is concluded in the containing file, or the end of a statement that was started in the including file. However, an included file must consist of complete tokens. Comments and string literals that have not been closed by the end of an included file are invalid. For error recovery, the compiler terminates them at the end of the file.</p> <p>To avoid confusion, it is best if header files contain only complete syntactic units\u2014function declarations or definitions, type declarations, etc.</p> <p>The line following the <code>#include</code> directive is always treated as a separate line, even if the included file lacks a final newline. There is no problem putting a preprocessing directive there.</p> <p></p> <p>Next: Once-Only Headers, Previous: include Operation, Up: Header Files \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2643-search-path","title":"26.4.3 Search Path","text":"<p>GCC looks in several different places for header files to be included. On the GNU system, and Unix systems, the default directories for system header files are:</p> <pre><code>libdir/gcc/target/version/include\n/usr/local/include\nlibdir/gcc/target/version/include-fixed\nlibdir/target/include\n/usr/include/target\n/usr/include\n</code></pre> <p>The list may be different in some operating systems. Other directories are added for C++.</p> <p>In the above, <code>target</code> is the canonical name of the system GCC was configured to compile code for; often but not always the same as the canonical name of the system it runs on. <code>version</code> is the version of GCC in use.</p> <p>You can add to this list with the <code>-I``dir</code> command-line option. All the directories named by <code>-I</code> are searched, in left-to-right order, before the default directories. The only exception is when <code>dir</code> is already searched by default. In this case, the option is ignored and the search order for system directories remains unchanged.</p> <p>Duplicate directories are removed from the quote and bracket search chains before the two chains are merged to make the final search chain. Thus, it is possible for a directory to occur twice in the final search chain if it was specified in both the quote and bracket chains.</p> <p>You can prevent GCC from searching any of the default directories with the <code>-nostdinc</code> option. This is useful when you are compiling an operating system kernel or some other program that does not use the standard C library facilities, or the standard C library itself. <code>-I</code> options are not ignored as described above when <code>-nostdinc</code> is in effect.</p> <p>GCC looks for headers requested with <code>#include\u00a0\"``file``\"</code> first in the directory containing the current file, then in the quote directories specified by <code>-iquote</code> options, then in the same places it looks for a system header. For example, if <code>/usr/include/sys/stat.h</code> contains <code>#include\u00a0\"types.h\"</code>, GCC looks for <code>types.h</code> first in <code>/usr/include/sys</code>, then in the quote directories and then in its usual search path.</p> <p><code>#line</code> (see Line Control) does not change GCC\u2019s idea of the directory containing the current file.</p> <p></p> <p>The <code>-I-</code> is an old-fashioned, deprecated way to specify the quote directories. To look for headers in a directory named <code>-</code>, specify <code>-I./-</code>. There are several more ways to adjust the header search path. See Invoking GCC in Using the GNU Compiler Collection.</p> <p></p> <p>Next: Computed Includes, Previous: Search Path, Up: Header Files \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2644-once-only-headers","title":"26.4.4 Once-Only Headers","text":"<p>If a header file happens to be included twice, the compiler will process its contents twice. This is very likely to cause an error, e.g. when the compiler sees the same structure definition twice.</p> <p>The standard way to prevent this is to enclose the entire real contents of the file in a conditional, like this:</p> <pre><code>/* File foo.  */\n#ifndef FILE_FOO_SEEN\n#define FILE_FOO_SEEN\n\nthe entire file\n\n#endif /* !FILE_FOO_SEEN */\n</code></pre> <p>This construct is commonly known as a wrapper #ifndef. When the header is included again, the conditional will be false, because <code>FILE_FOO_SEEN</code> is defined. Preprocessing skips over the entire contents of the file, so that compilation will never \u201csee\u201d the file contents twice in one module.</p> <p>GCC optimizes this case even further. It remembers when a header file has a wrapper <code>#ifndef</code>. If a subsequent <code>#include</code> specifies that header, and the macro in the <code>#ifndef</code> is still defined, it does not bother to rescan the file at all.</p> <p>You can put comments in the header file outside the wrapper. They do not interfere with this optimization.</p> <p> </p> <p>The macro <code>FILE_FOO_SEEN</code> is called the controlling macro or guard macro. In a user header file, the macro name should not begin with \u2018<code>_</code>\u2019. In a system header file, it should begin with \u2018<code>__</code>\u2019 (or \u2018<code>_</code>\u2019 followed by an upper-case letter) to avoid conflicts with user programs. In any kind of header file, the macro name should contain the name of the file and some additional text, to avoid conflicts with other header files.</p> <p></p> <p>Previous: Once-Only Headers, Up: Header Files \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2645-computed-includes","title":"26.4.5 Computed Includes","text":"<p>Sometimes it is necessary to select one of several different header files to be included into your program. They might specify configuration parameters to be used on different sorts of operating systems, for instance. You could do this with a series of conditionals,</p> <pre><code>#if SYSTEM_1\n# include \"system_1.h\"\n#elif SYSTEM_2\n# include \"system_2.h\"\n#elif SYSTEM_3\n/* \u2026 */\n#endif\n</code></pre> <p>That rapidly becomes tedious. Instead, GNU C offers the ability to use a macro for the header name. This is called a computed include. Instead of writing a header name as the direct argument of <code>#include</code>, you simply put a macro name there instead:</p> <pre><code>#define SYSTEM_H \"system_1.h\"\n/* \u2026 */\n#include SYSTEM_H\n</code></pre> <p><code>SYSTEM_H</code> is expanded, then <code>system_1.h</code> is included as if the <code>#include</code> had been written with that name. <code>SYSTEM_H</code> could be defined by your Makefile with a <code>-D</code> option.</p> <p>You must be careful when you define such a macro. <code>#define</code> saves tokens, not text. GCC has no way of knowing that the macro will be used as the argument of <code>#include</code>, so it generates ordinary tokens, not a header name. This is unlikely to cause problems if you use double-quote includes, which are syntactically similar to string constants. If you use angle brackets, however, you may have trouble.</p> <p>The syntax of a computed include is actually a bit more general than the above. If the first non-whitespace character after <code>#include</code> is not \u2018<code>\"</code>\u2019 or \u2018<code>&lt;</code>\u2019, then the entire line is macro-expanded like running text would be.</p> <p>If the line expands to a single string constant, the contents of that string constant are the file to be included. Preprocessing does not re-examine the string for embedded quotes, but neither does it process backslash escapes in the string. Therefore</p> <pre><code>#define HEADER \"a\\\"b\"\n#include HEADER\n</code></pre> <p>looks for a file named <code>a\\\"b</code>. Preprocessing searches for the file according to the rules for double-quoted includes.</p> <p>If the line expands to a token stream beginning with a \u2018<code>&lt;</code>\u2019 token and including a \u2018<code>&gt;</code>\u2019 token, then the tokens between the \u2018<code>&lt;</code>\u2019 and the first \u2018<code>&gt;</code>\u2019 are combined to form the filename to be included. Any whitespace between tokens is reduced to a single space; then any space after the initial \u2018<code>&lt;</code>\u2019 is retained, but a trailing space before the closing \u2018<code>&gt;</code>\u2019 is ignored. Preprocessing searches for the file according to the rules for angle-bracket includes.</p> <p>In either case, if there are any tokens on the line after the file name, an error occurs and the directive is not processed. It is also an error if the result of expansion does not match either of the two expected forms.</p> <p>These rules are implementation-defined behavior according to the C standard. To minimize the risk of different compilers interpreting your computed includes differently, we recommend you use only a single object-like macro that expands to a string constant. That also makes it clear to people reading your program.</p> <p></p> <p>Next: Conditionals, Previous: Header Files, Up: Preprocessing \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#265-macros","title":"26.5 Macros","text":"<p>A macro is a fragment of code that has been given a name. Whenever the name is used, it is replaced by the contents of the macro. There are two kinds of macros. They differ mostly in what they look like when they are used. Object-like macros resemble data objects when used, function-like macros resemble function calls.</p> <p>You may define any valid identifier as a macro, even if it is a C keyword. In the preprocessing stage, GCC does not know anything about keywords. This can be useful if you wish to hide a keyword such as <code>const</code> from an older compiler that does not understand it. However, the preprocessing operator <code>defined</code> (see defined) can never be defined as a macro.</p> <p>The operator <code>#</code> is used in macros for stringification of an argument (see Stringification), and <code>##</code> is used for concatenation of arguments into larger tokens (see Concatenation)</p> \u2022 Object-like Macros \u2022 Function-like Macros \u2022 Macro Arguments \u2022 Stringification \u2022 Concatenation \u2022 Variadic Macros \u2022 Predefined Macros \u2022 Undefining and Redefining Macros \u2022 Directives Within Macro Arguments \u2022 Macro Pitfalls <p></p> <p>Next: Function-like Macros, Up: Macros \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2651-object-like-macros","title":"26.5.1 Object-like Macros","text":"<p>An object-like macro is a simple identifier that will be replaced by a code fragment. It is called object-like because in most cases the use of the macro looks like reference to a data object in code that uses it. These macros are most commonly used to give symbolic names to numeric constants.</p> <p></p> <p>The way to define macros with the <code>#define</code> directive. <code>#define</code> is followed by the name of the macro and then the token sequence it should be an abbreviation for, which is variously referred to as the macro\u2019s body, expansion or replacement list. For example,</p> <pre><code>#define BUFFER_SIZE 1024\n</code></pre> <p>defines a macro named <code>BUFFER_SIZE</code> as an abbreviation for the token <code>1024</code>. If somewhere after this <code>#define</code> directive there comes a C statement of the form</p> <pre><code>foo = (char *) malloc (BUFFER_SIZE);\n</code></pre> <p>then preprocessing will recognize and expand the macro <code>BUFFER_SIZE</code>, so that compilation will see the tokens:</p> <pre><code>foo = (char *) malloc (1024);\n</code></pre> <p>By convention, macro names are written in upper case. Programs are easier to read when it is possible to tell at a glance which names are macros. Macro names that start with \u2018<code>__</code>\u2019 are reserved for internal uses, and many of them are defined automatically, so don\u2019t define such macro names unless you really know what you\u2019re doing. Likewise for macro names that start with \u2018<code>_</code>\u2019 and an upper-case letter.</p> <p>The macro\u2019s body ends at the end of the <code>#define</code> line. You may continue the definition onto multiple lines, if necessary, using backslash-newline. When the macro is expanded, however, it will all come out on one line. For example,</p> <pre><code>#define NUMBERS 1, \\\n                2, \\\n                3\nint x[] = { NUMBERS };\n     \u2192 int x[] = { 1, 2, 3 };\n</code></pre> <p>The most common visible consequence of this is surprising line numbers in error messages.</p> <p>There is no restriction on what can go in a macro body provided it decomposes into valid preprocessing tokens. Parentheses need not balance, and the body need not resemble valid C code. (If it does not, you may get error messages from the C compiler when you use the macro.)</p> <p>Preprocessing scans the program sequentially. A macro definition takes effect right after its appearance. Therefore, the following input</p> <pre><code>foo = X;\n#define X 4\nbar = X;\n</code></pre> <p>produces</p> <pre><code>foo = X;\nbar = 4;\n</code></pre> <p>When preprocessing expands a macro name, the macro\u2019s expansion replaces the macro invocation, then the expansion is examined for more macros to expand. For example,</p> <pre><code>#define TABLESIZE BUFSIZE\n#define BUFSIZE 1024\nTABLESIZE\n     \u2192 BUFSIZE\n     \u2192 1024\n</code></pre> <p><code>TABLESIZE</code> is expanded first to produce <code>BUFSIZE</code>, then that macro is expanded to produce the final result, <code>1024</code>.</p> <p>Notice that <code>BUFSIZE</code> was not defined when <code>TABLESIZE</code> was defined. The <code>#define</code> for <code>TABLESIZE</code> uses exactly the expansion you specify\u2014in this case, <code>BUFSIZE</code>\u2014and does not check to see whether it too contains macro names. Only when you use <code>TABLESIZE</code> is the result of its expansion scanned for more macro names.</p> <p>This makes a difference if you change the definition of <code>BUFSIZE</code> at some point in the source file. <code>TABLESIZE</code>, defined as shown, will always expand using the definition of <code>BUFSIZE</code> that is currently in effect:</p> <pre><code>#define BUFSIZE 1020\n#define TABLESIZE BUFSIZE\n#undef BUFSIZE\n#define BUFSIZE 37\n</code></pre> <p>Now <code>TABLESIZE</code> expands (in two stages) to <code>37</code>.</p> <p>If the expansion of a macro contains its own name, either directly or via intermediate macros, it is not expanded again when the expansion is examined for more macros. This prevents infinite recursion. See Self-Referential Macros, for the precise details.</p> <p></p> <p>Next: Macro Arguments, Previous: Object-like Macros, Up: Macros \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2652-function-like-macros","title":"26.5.2 Function-like Macros","text":"<p>You can also define macros whose use looks like a function call. These are called function-like macros. To define one, use the <code>#define</code> directive with a pair of parentheses immediately after the macro name. For example,</p> <pre><code>#define lang_init()  c_init ()\nlang_init ()\n     \u2192 c_init ()\nlang_init     ()\n     \u2192 c_init ()\nlang_init()\n     \u2192 c_init ()\n</code></pre> <p>There must be no space between the macro name and the following open-parenthesis in the the <code>#define</code> directive; that\u2019s what indicates you\u2019re defining a function-like macro. However, you can add unnecessary whitespace around the open-parenthesis (and around the close-parenthesis) when you call the macro; they don\u2019t change anything.</p> <p>A function-like macro is expanded only when its name appears with a pair of parentheses after it. If you write just the name, without parentheses, it is left alone. This can be useful when you have a function and a macro of the same name, and you wish to use the function sometimes. Whitespace and line breaks before or between the parentheses are ignored when the macro is called.</p> <pre><code>extern void foo(void);\n#define foo() /* optimized inline version */\n/* \u2026 */\n  foo();\n  funcptr = foo;\n</code></pre> <p>Here the call to <code>foo()</code> expands the macro, but the function pointer <code>funcptr</code> gets the address of the real function <code>foo</code>. If the macro were to be expanded there, it would cause a syntax error.</p> <p>If you put spaces between the macro name and the parentheses in the macro definition, that does not define a function-like macro, it defines an object-like macro whose expansion happens to begin with a pair of parentheses. Here is an example:</p> <pre><code>#define lang_init ()    c_init()\nlang_init()\n     \u2192 () c_init()()\n</code></pre> <p>The first two pairs of parentheses in this expansion come from the macro. The third is the pair that was originally after the macro invocation. Since <code>lang_init</code> is an object-like macro, it does not consume those parentheses.</p> <p>Any name can have at most one macro definition at a time. Thus, you can\u2019t define the same name as an object-like macro and a function-like macro at once.</p> <p></p> <p>Next: Stringification, Previous: Function-like Macros, Up: Macros \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2653-macro-arguments","title":"26.5.3 Macro Arguments","text":"<p>Function-like macros can take arguments, just like true functions. To define a macro that uses arguments, you insert parameters between the pair of parentheses in the macro definition that make the macro function-like. The parameters must be valid C identifiers, separated by commas and optionally whitespace.</p> <p>To invoke a macro that takes arguments, you write the name of the macro followed by a list of actual arguments in parentheses, separated by commas. The invocation of the macro need not be restricted to a single logical line\u2014it can cross as many lines in the source file as you wish. The number of arguments you give must match the number of parameters in the macro definition. When the macro is expanded, each use of a parameter in its body is replaced by the tokens of the corresponding argument. (The macro body is not required to use all of the parameters.)</p> <p>As an example, here is a macro that computes the minimum of two numeric values, as it is defined in many C programs, and some uses.</p> <pre><code>#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))\n  x = min(a, b);      \u2192 x = ((a) &lt; (b) ? (a) : (b));\n  y = min(1, 2);      \u2192 y = ((1) &lt; (2) ? (1) : (2));\n  z = min(a+28, *p);  \u2192 z = ((a+28) &lt; (*p) ? (a+28) : (*p));\n</code></pre> <p>In this small example you can already see several of the dangers of macro arguments. See Macro Pitfalls, for detailed explanations.</p> <p>Leading and trailing whitespace in each argument is dropped, and all whitespace between the tokens of an argument is reduced to a single space. Parentheses within each argument must balance; a comma within such parentheses does not end the argument. However, there is no requirement for square brackets or braces to balance, and they do not prevent a comma from separating arguments. Thus,</p> <pre><code>macro (array[x = y, x + 1])\n</code></pre> <p>passes two arguments to <code>macro</code>: <code>array[x = y</code> and <code>x + 1]</code>. If you want to supply <code>array[x = y, x + 1]</code> as an argument, you can write it as <code>array[(x = y, x + 1)]</code>, which is equivalent C code. However, putting an assignment inside an array subscript is to be avoided anyway.</p> <p>All arguments to a macro are completely macro-expanded before they are substituted into the macro body. After substitution, the complete text is scanned again for macros to expand, including the arguments. This rule may seem strange, but it is carefully designed so you need not worry about whether any function call is actually a macro invocation. You can run into trouble if you try to be too clever, though. See Argument Prescan, for detailed discussion.</p> <p>For example, <code>min (min (a, b), c)</code> is first expanded to</p> <pre><code>  min (((a) &lt; (b) ? (a) : (b)), (c))\n</code></pre> <p>and then to</p> <pre><code>((((a) &lt; (b) ? (a) : (b))) &lt; (c)\n ? (((a) &lt; (b) ? (a) : (b)))\n : (c))\n</code></pre> <p>(The line breaks shown here for clarity are not actually generated.)</p> <p></p> <p>You can leave macro arguments empty without error, but many macros will then expand to invalid code. You cannot leave out arguments entirely; if a macro takes two arguments, there must be exactly one comma at the top level of its argument list. Here are some silly examples using <code>min</code>:</p> <pre><code>min(, b)        \u2192 ((   ) &lt; (b) ? (   ) : (b))\nmin(a, )        \u2192 ((a  ) &lt; ( ) ? (a  ) : ( ))\nmin(,)          \u2192 ((   ) &lt; ( ) ? (   ) : ( ))\nmin((,),)       \u2192 (((,)) &lt; ( ) ? ((,)) : ( ))\n\nmin()      error\u2192 macro \"min\" requires 2 arguments, but only 1 given\nmin(,,)    error\u2192 macro \"min\" passed 3 arguments, but takes just 2\n</code></pre> <p>Whitespace is not a preprocessing token, so if a macro <code>foo</code> takes one argument, <code>foo\u00a0()</code> and <code>foo\u00a0(\u00a0)</code> both supply it an empty argument.</p> <p>Macro parameters appearing inside string literals are not replaced by their corresponding actual arguments.</p> <pre><code>#define foo(x) x, \"x\"\nfoo(bar)        \u2192 bar, \"x\"\n</code></pre> <p>See the next subsection for how to insert macro arguments into a string literal.</p> <p>The token following the macro call and the last token of the macro expansion do not become one token even if it looks like they could:</p> <pre><code>#define foo()  abc\nfoo()def        \u2192 abc def\n</code></pre> <p></p> <p>Next: Concatenation, Previous: Macro Arguments, Up: Macros \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2654-stringification","title":"26.5.4 Stringification","text":"<p>Sometimes you may want to convert a macro argument into a string constant. Parameters are not replaced inside string constants, but you can use the <code>#</code> preprocessing operator instead. When a macro parameter is used with a leading <code>#</code>, preprocessing replaces it with the literal text of the actual argument, converted to a string constant. Unlike normal parameter replacement, the argument is not macro-expanded first. This is called stringification.</p> <p>There is no way to combine an argument with surrounding text and stringify it all together. But you can write a series of string constants and stringified arguments. After preprocessing replaces the stringified arguments with string constants, the consecutive string constants will be concatenated into one long string constant (see String Constants).</p> <p>Here is an example that uses stringification and concatenation of string constants:</p> <pre><code>#define WARN_IF(EXP) \\\n  do { if (EXP) \\\n          fprintf (stderr, \"Warning: \" #EXP \"\\n\"); } \\\n  while (0)\n\nWARN_IF (x == 0);\n     \u2192\n  do { if (x == 0)\n          fprintf (stderr, \"Warning: \" \"x == 0\" \"\\n\"); }\n  while (0);\n</code></pre> <p>The argument for <code>EXP</code> is substituted once, as is, into the <code>if</code> statement, and once, stringified, into the argument to <code>fprintf</code>. If <code>x</code> were a macro, it would be expanded in the <code>if</code> statement but not in the string.</p> <p>The <code>do</code> and <code>while (0)</code> are a kludge to make it possible to write <code>WARN_IF (``arg``);</code>. The resemblance of <code>WARN_IF</code> to a function makes that a natural way to write it. See Swallowing the Semicolon.</p> <p>Stringification in C involves more than putting double-quote characters around the fragment. It also backslash-escapes the quotes surrounding embedded string constants, and all backslashes within string and character constants, in order to get a valid C string constant with the proper contents. Thus, stringifying <code>p\u00a0=\u00a0\"foo\\n\";</code> results in <code>\"p\u00a0=\u00a0\\\"foo\\\\n\\\";\"</code>. However, backslashes that are not inside string or character constants are not duplicated: \u2018<code>\\n</code>\u2019 by itself stringifies to <code>\"\\n\"</code>.</p> <p>All leading and trailing whitespace in text being stringified is ignored. Any sequence of whitespace in the middle of the text is converted to a single space in the stringified result. Comments are replaced by whitespace long before stringification happens, so they never appear in stringified text.</p> <p>There is no way to convert a macro argument into a character constant.</p> <p>To stringify the result of expansion of a macro argument, you have to use two levels of macros, like this:</p> <pre><code>#define xstr(S) str(S)\n#define str(s) #s\n#define foo 4\nstr (foo)\n     \u2192 \"foo\"\nxstr (foo)\n     \u2192 xstr (4)\n     \u2192 str (4)\n     \u2192 \"4\"\n</code></pre> <p><code>s</code> is stringified when it is used in <code>str</code>, so it is not macro-expanded first. But <code>S</code> is an ordinary argument to <code>xstr</code>, so it is completely macro-expanded before <code>xstr</code> itself is expanded (see Argument Prescan). Therefore, by the time <code>str</code> gets to its argument text, that text already been macro-expanded.</p> <p></p> <p>Next: Variadic Macros, Previous: Stringification, Up: Macros \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2655-concatenation","title":"26.5.5 Concatenation","text":"<p>It is often useful to merge two tokens into one while expanding macros. This is called token pasting or token concatenation. The <code>##</code> preprocessing operator performs token pasting. When a macro is expanded, the two tokens on either side of each <code>##</code> operator are combined into a single token, which then replaces the <code>##</code> and the two original tokens in the macro expansion. Usually both will be identifiers, or one will be an identifier and the other a preprocessing number. When pasted, they make a longer identifier.</p> <p>Concatenation into an identifier isn\u2019t the only valid case. It is also possible to concatenate two numbers (or a number and a name, such as <code>1.5</code> and <code>e3</code>) into a number. Also, multi-character operators such as <code>+=</code> can be formed by token pasting.</p> <p>However, two tokens that don\u2019t together form a valid token cannot be pasted together. For example, you cannot concatenate <code>x</code> with <code>+</code>, not in either order. Trying this issues a warning and keeps the two tokens separate. Whether it puts white space between the tokens is undefined. It is common to find unnecessary uses of <code>##</code> in complex macros. If you get this warning, it is likely that you can simply remove the <code>##</code>.</p> <p>The tokens combined by <code>##</code> could both come from the macro body, but then you could just as well write them as one token in the first place. Token pasting is useful when one or both of the tokens comes from a macro argument. If either of the tokens next to an <code>##</code> is a parameter name, it is replaced by its actual argument before <code>##</code> executes. As with stringification, the actual argument is not macro-expanded first. If the argument is empty, that <code>##</code> has no effect.</p> <p>Keep in mind that preprocessing converts comments to whitespace before it looks for uses of macros. Therefore, you cannot create a comment by concatenating \u2018<code>/</code>\u2019 and \u2018<code>*</code>\u2019. You can put as much whitespace between <code>##</code> and its operands as you like, including comments, and you can put comments in arguments that will be concatenated.</p> <p>It is an error to use <code>##</code> at the beginning or end of a macro body.</p> <p>Multiple <code>##</code> operators are handled left-to-right, so that \u2018<code>1 ## e ## -2</code>\u2019 pastes into \u2018<code>1e-2</code>\u2019. (Right-to-left processing would first generate \u2018<code>e-2</code>\u2019, which is an invalid token.) When <code>#</code> and <code>##</code> are used together, they are all handled left-to-right.</p> <p>Consider a C program that interprets named commands. There probably needs to be a table of commands, perhaps an array of structures declared as follows:</p> <pre><code>struct command\n{\n  char *name;\n  void (*function) (void);\n};\n\nstruct command commands[] =\n{\n  { \"quit\", quit_command },\n  { \"help\", help_command },\n  /* \u2026 */\n};\n</code></pre> <p>It would be cleaner not to have to write each command name twice, once in the string constant and once in the function name. A macro that takes the name of a command as an argument can make this unnecessary. It can create the string constant with stringification, and the function name by concatenating the argument with \u2018<code>_command</code>\u2019. Here is how it is done:</p> <pre><code>#define COMMAND(NAME)  { #NAME, NAME ## _command }\n\nstruct command commands[] =\n{\n  COMMAND (quit),\n  COMMAND (help),\n  /* \u2026 */\n};\n</code></pre> <p></p> <p>Next: Predefined Macros, Previous: Concatenation, Up: Macros \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2656-variadic-macros","title":"26.5.6 Variadic Macros","text":"<p>A macro can be declared to accept a variable number of arguments much as a function can. The syntax for defining the macro is similar to that of a function. Here is an example:</p> <pre><code>#define eprintf(\u2026) fprintf (stderr, __VA_ARGS__)\n</code></pre> <p>This kind of macro is called variadic. When the macro is invoked, all the tokens in its argument list after the last named argument (this macro has none), including any commas, become the variable argument. This sequence of tokens replaces the identifier <code>__VA_ARGS__</code> in the macro body wherever it appears. Thus, we have this expansion:</p> <pre><code>eprintf (\"%s:%d: \", input_file, lineno)\n     \u2192  fprintf (stderr, \"%s:%d: \", input_file, lineno)\n</code></pre> <p>The variable argument is completely macro-expanded before it is inserted into the macro expansion, just like an ordinary argument. You may use the <code>#</code> and <code>##</code> operators to stringify the variable argument or to paste its leading or trailing token with another token. (But see below for an important special case for <code>##</code>.)</p> <p>Warning: don\u2019t use the identifier <code>__VA_ARGS__</code> for anything other than this.</p> <p>If your macro is complicated, you may want a more descriptive name for the variable argument than <code>__VA_ARGS__</code>. You can write an argument name immediately before the \u2018<code>\u2026</code>\u2019; that name is used for the variable argument.<sup>9</sup> The <code>eprintf</code> macro above could be written thus:</p> <pre><code>#define eprintf(args\u2026) fprintf (stderr, args)\n</code></pre> <p>A variadic macro can have named arguments as well as variable arguments, so <code>eprintf</code> can be defined like this, instead:</p> <pre><code>#define eprintf(format, \u2026) \\\n  fprintf (stderr, format, __VA_ARGS__)\n</code></pre> <p>This formulation is more descriptive, but what if you want to specify a format string that takes no arguments? In GNU C, you can omit the comma before the variable arguments if they are empty, but that puts an extra comma in the expansion:</p> <pre><code>eprintf (\"success!\\n\")\n     \u2192 fprintf(stderr, \"success!\\n\", )\n</code></pre> <p>That\u2019s an error in the call to <code>fprintf</code>.</p> <p>To get rid of that comma, the <code>##</code> token paste operator has a special meaning when placed between a comma and a variable argument.<sup>10</sup> If you write</p> <pre><code>#define eprintf(format, \u2026) \\\n  fprintf (stderr, format, ##__VA_ARGS__)\n</code></pre> <p>then use the macro <code>eprintf</code> with empty variable arguments, <code>##</code> deletes the preceding comma.</p> <pre><code>eprintf (\"success!\\n\")\n     \u2192 fprintf(stderr, \"success!\\n\")\n</code></pre> <p>This does not happen if you pass an empty argument, nor does it happen if the token preceding <code>##</code> is anything other than a comma.</p> <p>When the only macro parameter is a variable arguments parameter, and the macro call has no argument at all, it is not obvious whether that means an empty argument or a missing argument. Should the comma be kept, or deleted? The C standard says to keep the comma, but the preexisting GNU C extension deleted the comma. Nowadays, GNU C retains the comma when implementing a specific C standard, and deletes it otherwise.</p> <p>C99 mandates that the only place the identifier <code>__VA_ARGS__</code> can appear is in the replacement list of a variadic macro. It may not be used as a macro name, macro parameter name, or within a different type of macro. It may also be forbidden in open text; the standard is ambiguous. We recommend you avoid using that name except for its special purpose.</p> <p>Variadic macros where you specify the parameter name is a GNU C feature that has been supported for a long time. Standard C, as of C99, supports only the form where the parameter is called <code>__VA_ARGS__</code>. For portability to previous versions of GNU C you should use only named variable argument parameters. On the other hand, for portability to other C99 compilers, you should use only <code>__VA_ARGS__</code>.</p> <p></p> <p>Next: Undefining and Redefining Macros, Previous: Variadic Macros, Up: Macros \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2657-predefined-macros","title":"26.5.7 Predefined Macros","text":"<p>Several object-like macros are predefined; you use them without supplying their definitions. Here we explain the ones user programs often need to use. Many other macro names starting with \u2018<code>__</code>\u2019 are predefined; in general, you should not define such macro names yourself.</p> <p><code>__FILE__</code> This macro expands to the name of the current input file, in the form of a C string constant. This is the full name by which the GCC opened the file, not the short name specified in <code>#include</code> or as the input file name argument. For example, <code>\"/usr/local/include/myheader.h\"</code> is a possible expansion of this macro.</p> <p><code>__LINE__</code> This macro expands to the current input line number, in the form of a decimal integer constant. While we call it a predefined macro, it\u2019s a pretty strange macro, since its \u201cdefinition\u201d changes with each new line of source code.</p> <p><code>__func__</code> <code>__FUNCTION__</code> These names are like variables that have as value a string containing the name of the current function definition. They are not really macros, but this is the best place to mention them.</p> <p><code>__FUNCTION__</code> is the name that has been defined in GNU C since time immemorial; <code>__func__</code> is defined by the C standard. With the following conditionals, you can use whichever one is defined.</p> <pre><code>#if __STDC_VERSION__ &lt; 199901L\n# if __GNUC__ &gt;= 2\n#  define __func__ __FUNCTION__\n# else\n#  define __func__ \"&lt;unknown&gt;\"\n# endif\n#endif\n</code></pre> <p><code>__PRETTY_FUNCTION__</code> This is equivalent to <code>__FUNCTION__</code> in C, but in C<code>++</code> the string includes argument type information as well. It is a GNU C extension.</p> <p>Those features are useful in generating an error message to report an inconsistency detected by the program; the message can state the source line where the inconsistency was detected. For example,</p> <pre><code>fprintf (stderr, \"Internal error: \"\n                 \"negative string length \"\n                 \"in function %s \"\n                 \"%d at %s, line %d.\",\n         __func__, length, __FILE__, __LINE__);\n</code></pre> <p>A <code>#line</code> directive changes <code>__LINE__</code>, and may change <code>__FILE__</code> as well. See Line Control.</p> <p><code>__DATE__</code> This macro expands to a string constant that describes the date of compilation. The string constant contains eleven characters and looks like <code>\"Feb\u00a012\u00a01996\"</code>. If the day of the month is just one digit, an extra space precedes it so that the date is always eleven characters.</p> <p>If the compiler cannot determine the current date, it emits a warning messages (once per compilation) and <code>__DATE__</code> expands to <code>\"???\u00a0??\u00a0????\"</code>.</p> <p>We deprecate the use of <code>__DATE__</code> for the sake of reproducible compilation.</p> <p><code>__TIME__</code> This macro expands to a string constant that describes the time of compilation. The string constant contains eight characters and looks like <code>\"23:59:01\"</code>.</p> <p>If the compiler cannot determine the current time, it emits a warning message (once per compilation) and <code>__TIME__</code> expands to <code>\"??:??:??\"</code>.</p> <p>We deprecate the use of <code>__TIME__</code> for the sake of reproducible compilation.</p> <p><code>__STDC__</code> In normal operation, this macro expands to the constant 1, to signify that this compiler implements ISO Standard C.</p> <p><code>__STDC_VERSION__</code> This macro expands to the C Standard\u2019s version number, a long integer constant of the form <code>yyyy``mm``L</code> where <code>yyyy</code> and <code>mm</code> are the year and month of the Standard version. This states which version of the C Standard the compiler implements.</p> <p>The current default value is <code>201112L</code>, which signifies the C 2011 standard.</p> <p><code>__STDC_HOSTED__</code> This macro is defined, with value 1, if the compiler\u2019s target is a hosted environment. A hosted environment provides the full facilities of the standard C library.</p> <p>The rest of the predefined macros are GNU C extensions.</p> <p><code>__COUNTER__</code> This macro expands to sequential integral values starting from 0. In other words, each time the program uses this macro, it generates the next successive integer. This, with the <code>##</code> operator, provides a convenient means for macros to generate unique identifiers.</p> <p><code>__GNUC__</code> <code>__GNUC_MINOR__</code> <code>__GNUC_PATCHLEVEL__</code> These macros expand to the major version, minor version, and patch level of the compiler, as integer constants. For example, GCC 3.2.1 expands <code>__GNUC__</code> to 3, <code>__GNUC_MINOR__</code> to 2, and <code>__GNUC_PATCHLEVEL__</code> to 1.</p> <p>If all you need to know is whether or not your program is being compiled by GCC, or a non-GCC compiler that claims to accept the GNU C extensions, you can simply test <code>__GNUC__</code>. If you need to write code that depends on a specific version, you must check more carefully. Each change in the minor version resets the patch level to zero; each change in the major version (which happens rarely) resets the minor version and the patch level to zero. To use the predefined macros directly in the conditional, write it like this:</p> <pre><code>/* Test for version 3.2.0 or later. */\n#if __GNUC__ &gt; 3 || \\\n    (__GNUC__ == 3 &amp;&amp; (__GNUC_MINOR__ &gt; 2 || \\\n                       (__GNUC_MINOR__ == 2 &amp;&amp; \\\n                        __GNUC_PATCHLEVEL__ &gt; 0))\n</code></pre> <p>Another approach is to use the predefined macros to calculate a single number, then compare that against a threshold:</p> <pre><code>#define GCC_VERSION (__GNUC__ * 10000 \\\n                     + __GNUC_MINOR__ * 100 \\\n                     + __GNUC_PATCHLEVEL__)\n/* \u2026 */\n/* Test for GCC &gt; 3.2.0 */\n#if GCC_VERSION &gt; 30200\n</code></pre> <p>Many people find this form easier to understand.</p> <p><code>__VERSION__</code> This macro expands to a string constant that describes the version of the compiler in use. You should not rely on its contents\u2019 having any particular form, but you can count on it to contain at least the release number.</p> <p><code>__TIMESTAMP__</code> This macro expands to a string constant that describes the date and time of the last modification of the current source file. The string constant contains abbreviated day of the week, month, day of the month, time in hh:mm:ss form, and the year, in the format <code>\"Sun\u00a0Sep\u00a016\u00a001:03:52\u00a01973\"</code>. If the day of the month is less than 10, it is padded with a space on the left.</p> <p>If GCC cannot determine that information date, it emits a warning message (once per compilation) and <code>__TIMESTAMP__</code> expands to <code>\"???\u00a0???\u00a0??\u00a0??:??:??\u00a0????\"</code>.</p> <p>We deprecate the use of this macro for the sake of reproducible compilation.</p> <p></p> <p>Next: Directives Within Macro Arguments, Previous: Predefined Macros, Up: Macros \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2658-undefining-and-redefining-macros","title":"26.5.8 Undefining and Redefining Macros","text":"<p>You can undefine a macro with the <code>#undef</code> directive. <code>#undef</code> takes a single argument, the name of the macro to undefine. You use the bare macro name, even if the macro is function-like. It is an error if anything appears on the line after the macro name. <code>#undef</code> has no effect if the name is not a macro.</p> <pre><code>#define FOO 4\nx = FOO;        \u2192 x = 4;\n#undef FOO\nx = FOO;        \u2192 x = FOO;\n</code></pre> <p>Once a macro has been undefined, that identifier may be redefined as a macro by a subsequent <code>#define</code> directive. The new definition need not have any resemblance to the old definition.</p> <p>You can define a macro again without first undefining it only if the new definition is effectively the same as the old one. Two macro definitions are effectively the same if:</p> <ul> <li>Both are the same type of macro (object- or function-like).</li> <li>All the tokens of the replacement list are the same.</li> <li>If there are any parameters, they are the same.</li> <li>Whitespace appears in the same places in both. It need not be     exactly the same amount of whitespace, though. Remember that     comments count as whitespace.</li> </ul> <p>These definitions are effectively the same:</p> <pre><code>#define FOUR (2 + 2)\n#define FOUR         (2    +    2)\n#define FOUR (2 /* two */ + 2)\n</code></pre> <p>but these are not:</p> <pre><code>#define FOUR (2 + 2)\n#define FOUR ( 2+2 )\n#define FOUR (2 * 2)\n#define FOUR(score,and,seven,years,ago) (2 + 2)\n</code></pre> <p>This allows two different header files to define a common macro.</p> <p>You can redefine an existing macro with #define, but redefining an existing macro name with a different definition results in a warning.</p> <p></p> <p>Next: Macro Pitfalls, Previous: Undefining and Redefining Macros, Up: Macros \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2659-directives-within-macro-arguments","title":"26.5.9 Directives Within Macro Arguments","text":"<p>GNU C permits and handles preprocessing directives in the text provided as arguments for a macro. That case is undefined in the C standard. but in GNU C\u00a0conditional directives in macro arguments are clear and valid.</p> <p>A paradoxical case is to redefine a macro within the call to that same macro. What happens is, the new definition takes effect in time for pre-expansion of all the arguments, then the original definition is expanded to replace the call. Here is a pathological example:</p> <pre><code>#define f(x) x x\nf (first f second\n#undef f\n#define f 2\nf)\n</code></pre> <p>which expands to</p> <pre><code>first 2 second 2 first 2 second 2\n</code></pre> <p>with the semantics described above. We suggest you avoid writing code which does this sort of thing.</p> <p></p> <p>Previous: Directives Within Macro Arguments, Up: Macros \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#26510-macro-pitfalls","title":"26.5.10 Macro Pitfalls","text":"<p>In this section we describe some special rules that apply to macros and macro expansion, and point out certain cases in which the rules have counter-intuitive consequences that you must watch out for.</p> \u2022 Misnesting \u2022 Operator Precedence Problems \u2022 Swallowing the Semicolon \u2022 Duplication of Side Effects \u2022 Macros and Auto Type \u2022 Self-Referential Macros \u2022 Argument Prescan <p></p> <p>Next: Operator Precedence Problems, Up: Macro Pitfalls \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#265101-misnesting","title":"26.5.10.1 Misnesting","text":"<p>When a macro is called with arguments, the arguments are substituted into the macro body and the result is checked, together with the rest of the input file, for more macro calls. It is possible to piece together a macro call coming partially from the macro body and partially from the arguments. For example,</p> <pre><code>#define twice(x) (2*(x))\n#define call_with_1(x) x(1)\ncall_with_1 (twice)\n     \u2192 twice(1)\n     \u2192 (2*(1))\n</code></pre> <p>Macro definitions do not have to have balanced parentheses. By writing an unbalanced open parenthesis in a macro body, it is possible to create a macro call that begins inside the macro body but ends outside of it. For example,</p> <pre><code>#define strange(file) fprintf (file, \"%s %d\",\n/* \u2026 */\nstrange(stderr) p, 35)\n     \u2192 fprintf (stderr, \"%s %d\", p, 35)\n</code></pre> <p>The ability to piece together a macro call can be useful, but the use of unbalanced open parentheses in a macro body is just confusing, and should be avoided.</p> <p></p> <p>Next: Swallowing the Semicolon, Previous: Misnesting, Up: Macro Pitfalls \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#265102-operator-precedence-problems","title":"26.5.10.2 Operator Precedence Problems","text":"<p>You may have noticed that in most of the macro definition examples shown above, each occurrence of a macro parameter name had parentheses around it. In addition, another pair of parentheses usually surrounds the entire macro definition. Here is why it is best to write macros that way.</p> <p>Suppose you define a macro as follows,</p> <pre><code>#define ceil_div(x, y) (x + y - 1) / y\n</code></pre> <p>whose purpose is to divide, rounding up. (One use for this operation is to compute how many <code>int</code> objects are needed to hold a certain number of <code>char</code> objects.) Then suppose it is used as follows:</p> <pre><code>a = ceil_div (b &amp; c, sizeof (int));\n     \u2192 a = (b &amp; c + sizeof (int) - 1) / sizeof (int);\n</code></pre> <p>This does not do what is intended. The operator-precedence rules of C make it equivalent to this:</p> <pre><code>a = (b &amp; (c + sizeof (int) - 1)) / sizeof (int);\n</code></pre> <p>What we want is this:</p> <pre><code>a = ((b &amp; c) + sizeof (int) - 1)) / sizeof (int);\n</code></pre> <p>Defining the macro as</p> <pre><code>#define ceil_div(x, y) ((x) + (y) - 1) / (y)\n</code></pre> <p>provides the desired result.</p> <p>Unintended grouping can result in another way. Consider <code>sizeof ceil_div(1, 2)</code>. That has the appearance of a C expression that would compute the size of the type of <code>ceil_div (1, 2)</code>, but in fact it means something very different. Here is what it expands to:</p> <pre><code>sizeof ((1) + (2) - 1) / (2)\n</code></pre> <p>This would take the size of an integer and divide it by two. The precedence rules have put the division outside the <code>sizeof</code> when it was intended to be inside.</p> <p>Parentheses around the entire macro definition prevent such problems. Here, then, is the recommended way to define <code>ceil_div</code>:</p> <pre><code>#define ceil_div(x, y) (((x) + (y) - 1) / (y))\n</code></pre> <p></p> <p>Next: Duplication of Side Effects, Previous: Operator Precedence Problems, Up: Macro Pitfalls \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#265103-swallowing-the-semicolon","title":"26.5.10.3 Swallowing the Semicolon","text":"<p>Often it is desirable to define a macro that expands into a compound statement. Consider, for example, the following macro, that advances a pointer (the parameter <code>p</code> says where to find it) across whitespace characters:</p> <pre><code>#define SKIP_SPACES(p, limit)  \\\n{ char *lim = (limit);         \\\n  while (p &lt; lim) {            \\\n    if (*p++ != ' ') {         \\\n      p--; break; }}}\n</code></pre> <p>Here backslash-newline is used to split the macro definition, which must be a single logical line, so that it resembles the way such code would be laid out if not part of a macro definition.</p> <p>A call to this macro might be <code>SKIP_SPACES (p, lim)</code>. Strictly speaking, the call expands to a compound statement, which is a complete statement with no need for a semicolon to end it. However, since it looks like a function call, it minimizes confusion if you can use it like a function call, writing a semicolon afterward, as in <code>SKIP_SPACES (p, lim);</code></p> <p>This can cause trouble before <code>else</code> statements, because the semicolon is actually a null statement. Suppose you write</p> <pre><code>if (*p != 0)\n  SKIP_SPACES (p, lim);\nelse /* \u2026 */\n</code></pre> <p>The presence of two statements\u2014the compound statement and a null statement\u2014in between the <code>if</code> condition and the <code>else</code> makes invalid C code.</p> <p>The definition of the macro <code>SKIP_SPACES</code> can be altered to solve this problem, using a <code>do</code><code>\u2026</code><code>while</code> statement. Here is how:</p> <pre><code>#define SKIP_SPACES(p, limit)     \\\ndo { char *lim = (limit);         \\\n     while (p &lt; lim) {            \\\n       if (*p++ != ' ') {         \\\n         p--; break; }}}          \\\nwhile (0)\n</code></pre> <p>Now <code>SKIP_SPACES (p, lim);</code> expands into</p> <pre><code>do { /* \u2026 */ } while (0);\n</code></pre> <p>which is one statement. The loop executes exactly once; most compilers generate no extra code for it.</p> <p></p> <p>Next: Macros and Auto Type, Previous: Swallowing the Semicolon, Up: Macro Pitfalls \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#265104-duplication-of-side-effects","title":"26.5.10.4 Duplication of Side Effects","text":"<p>Many C programs define a macro <code>min</code>, for \u201cminimum\u201d, like this:</p> <pre><code>#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))\n</code></pre> <p>When you use this macro with an argument containing a side effect, as shown here,</p> <pre><code>next = min (x + y, foo (z));\n</code></pre> <p>it expands as follows:</p> <pre><code>next = ((x + y) &lt; (foo (z)) ? (x + y) : (foo (z)));\n</code></pre> <p>where <code>x + y</code> has been substituted for <code>X</code> and <code>foo (z)</code> for <code>Y</code>.</p> <p>The function <code>foo</code> is used only once in the statement as it appears in the program, but the expression <code>foo (z)</code> has been substituted twice into the macro expansion. As a result, <code>foo</code> might be called twice when the statement is executed. If it has side effects or if it takes a long time to compute, that may be undesirable. We say that <code>min</code> is an unsafe macro.</p> <p>The best solution to this problem is to define <code>min</code> in a way that computes the value of <code>foo (z)</code> only once. In general, that requires using <code>__auto_type</code> (see Auto Type). How to use it for this is described in the following section. See Macros and Auto Type.</p> <p>Otherwise, you will need to be careful when using the macro <code>min</code>. For example, you can calculate the value of <code>foo (z)</code>, save it in a variable, and use that variable in <code>min</code>:</p> <pre><code>#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))\n/* \u2026 */\n{\n  int tem = foo (z);\n  next = min (x + y, tem);\n}\n</code></pre> <p>(where we assume that <code>foo</code> returns type <code>int</code>).</p> <p>When the repeated value appears as the condition of the <code>?:</code> operator and again as its <code>iftrue</code> expression, you can avoid repeated execution by omitting the <code>iftrue</code> expression, like this:</p> <pre><code>#define x_or_y(X, Y)  ((X) ? : (Y))\n</code></pre> <p>In GNU C, this expands to use the first macro argument\u2019s value if that isn\u2019t zero. If that\u2019s zero, it compiles the second argument and uses that value. See Conditional Expression.</p> <p></p> <p>Next: Self-Referential Macros, Previous: Duplication of Side Effects, Up: Macro Pitfalls \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#265105-using-__auto_type-for-local-variables","title":"26.5.10.5 Using <code>__auto_type</code> for Local Variables","text":"<p>The operator <code>__auto_type</code> makes it possible to define macros that can work on any data type even though they need to generate local variable declarations. See Auto Type.</p> <p>For instance, here\u2019s how to define a safe \u201cmaximum\u201d macro that operates on any arithmetic type and computes each of its arguments exactly once:</p> <pre><code>#define max(a,b) \\\n  ({ __auto_type _a = (a); \\\n      __auto_type _b = (b); \\\n    _a &gt; _b ? _a : _b; })\n</code></pre> <p>The \u2018<code>({ \u2026 })</code>\u2019 notation produces statement expression\u2014a statement that can be used as an expression (see Statement Exprs). Its value is the value of its last statement. This permits us to define local variables and store each argument value into one.</p> <p> </p> <p>The reason for using names that start with underscores for the local variables is to avoid conflicts with variable names that occur within the expressions that are substituted for <code>a</code> and <code>b</code>. Underscore followed by a lower case letter won\u2019t be predefined by the system in any way.</p> <p></p> <p>Next: Argument Prescan, Previous: Macros and Auto Type, Up: Macro Pitfalls \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#265106-self-referential-macros","title":"26.5.10.6 Self-Referential Macros","text":"<p>A self-referential macro is one whose name appears in its definition. Recall that all macro definitions are rescanned for more macros to replace. If the self-reference were considered a use of the macro, it would produce an infinitely large expansion. To prevent this, the self-reference is not considered a macro call: preprocessing leaves it unchanged. Consider an example:</p> <pre><code>#define foo (4 + foo)\n</code></pre> <p>where <code>foo</code> is also a variable in your program.</p> <p>Following the ordinary rules, each reference to <code>foo</code> will expand into <code>(4 + foo)</code>; then this will be rescanned and will expand into <code>(4 + (4 + foo))</code>; and so on until the computer runs out of memory.</p> <p>The self-reference rule cuts this process short after one step, at <code>(4 + foo)</code>. Therefore, this macro definition has the possibly useful effect of causing the program to add 4 to the value of <code>foo</code> wherever <code>foo</code> is referred to.</p> <p>In most cases, it is a bad idea to take advantage of this feature. A person reading the program who sees that <code>foo</code> is a variable will not expect that it is a macro as well. The reader will come across the identifier <code>foo</code> in the program and think its value should be that of the variable <code>foo</code>, whereas in fact the value is four greater.</p> <p>It is useful to make a macro definition that expands to the macro name itself. If you write</p> <pre><code>#define EPERM EPERM\n</code></pre> <p>then the macro <code>EPERM</code> expands to <code>EPERM</code>. Effectively, preprocessing leaves it unchanged in the source code. You can tell that it\u2019s a macro with <code>#ifdef</code>. You might do this if you want to define numeric constants with an <code>enum</code>, but have <code>#ifdef</code> be true for each constant.</p> <p>If a macro <code>x</code> expands to use a macro <code>y</code>, and the expansion of <code>y</code> refers to the macro <code>x</code>, that is an indirect self-reference of <code>x</code>. <code>x</code> is not expanded in this case either. Thus, if we have</p> <pre><code>#define x (4 + y)\n#define y (2 * x)\n</code></pre> <p>then <code>x</code> and <code>y</code> expand as follows:</p> <pre><code>x    \u2192 (4 + y)\n     \u2192 (4 + (2 * x))\n\ny    \u2192 (2 * x)\n     \u2192 (2 * (4 + y))\n</code></pre> <p>Each macro is expanded when it appears in the definition of the other macro, but not when it indirectly appears in its own definition.</p> <p></p> <p>Previous: Self-Referential Macros, Up: Macro Pitfalls \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#265107-argument-prescan","title":"26.5.10.7 Argument Prescan","text":"<p>Macro arguments are completely macro-expanded before they are substituted into a macro body, unless they are stringified or pasted with other tokens. After substitution, the entire macro body, including the substituted arguments, is scanned again for macros to be expanded. The result is that the arguments are scanned twice to expand macro calls in them.</p> <p>Most of the time, this has no effect. If the argument contained any macro calls, they were expanded during the first scan. The result therefore contains no macro calls, so the second scan does not change it. If the argument were substituted as given, with no prescan, the single remaining scan would find the same macro calls and produce the same results.</p> <p>You might expect the double scan to change the results when a self-referential macro is used in an argument of another macro (see Self-Referential Macros): the self-referential macro would be expanded once in the first scan, and a second time in the second scan. However, this is not what happens. The self-references that do not expand in the first scan are marked so that they will not expand in the second scan either.</p> <p>You might wonder, \u201cWhy mention the prescan, if it makes no difference? And why not skip it and make preprocessing go faster?\u201d The answer is that the prescan does make a difference in three special cases:</p> <ul> <li> <p>Nested calls to a macro.</p> <p>We say that nested calls to a macro occur when a macro\u2019s argument contains a call to that very macro. For example, if <code>f</code> is a macro that expects one argument, <code>f (f (1))</code> is a nested pair of calls to <code>f</code>. The desired expansion is made by expanding <code>f (1)</code> and substituting that into the definition of <code>f</code>. The prescan causes the expected result to happen. Without the prescan, <code>f (1)</code> itself would be substituted as an argument, and the inner use of <code>f</code> would appear during the main scan as an indirect self-reference and would not be expanded.</p> </li> <li> <p>Macros that call other macros that stringify or concatenate.</p> <p>If an argument is stringified or concatenated, the prescan does not occur. If you want to expand a macro, then stringify or concatenate its expansion, you can do that by causing one macro to call another macro that does the stringification or concatenation. For instance, if you have</p> <pre><code>#define AFTERX(x) X_ ## x\n#define XAFTERX(x) AFTERX(x)\n#define TABLESIZE 1024\n#define BUFSIZE TABLESIZE\n</code></pre> <p>then <code>AFTERX(BUFSIZE)</code> expands to <code>X_BUFSIZE</code>, and <code>XAFTERX(BUFSIZE)</code> expands to <code>X_1024</code>. (Not to <code>X_TABLESIZE</code>. Prescan always does a complete expansion.)</p> </li> <li> <p>Macros used in arguments, whose expansions contain unshielded     commas.</p> <p>This can cause a macro expanded on the second scan to be called with the wrong number of arguments. Here is an example:</p> <pre><code>#define foo  a,b\n#define bar(x) lose(x)\n#define lose(x) (1 + (x))\n</code></pre> <p>We would like <code>bar(foo)</code> to turn into <code>(1 + (foo))</code>, which would then turn into <code>(1 + (a,b))</code>. Instead, <code>bar(foo)</code> expands into <code>lose(a,b)</code>, which gives an error because <code>lose</code> requires a single argument. In this case, the problem is easily solved by the same parentheses that ought to be used to prevent misnesting of arithmetic operations:</p> <pre><code>#define foo (a,b)\n\nor\n\n#define bar(x) lose((x))\n</code></pre> <p>The extra pair of parentheses prevents the comma in <code>foo</code>\u2019s definition from being interpreted as an argument separator.</p> </li> </ul> <p></p> <p>Next: Diagnostics, Previous: Macros, Up: Preprocessing \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#266-conditionals","title":"26.6 Conditionals","text":"<p>A conditional is a preprocessing directive that controls whether or not to include a chunk of code in the final token stream that is compiled. Preprocessing conditionals can test arithmetic expressions, or whether a name is defined as a macro, or both together using the special <code>defined</code> operator.</p> <p>A preprocessing conditional in C resembles in some ways an <code>if</code> statement in C, but it is important to understand the difference between them. The condition in an <code>if</code> statement is tested during the execution of your program. Its purpose is to allow your program to behave differently from run to run, depending on the data it is operating on. The condition in a preprocessing conditional directive is tested when your program is compiled. Its purpose is to allow different code to be included in the program depending on the situation at the time of compilation.</p> <p>Sometimes this distinction makes no practical difference. GCC and other modern compilers often do test <code>if</code> statements when a program is compiled, if their conditions are known not to vary at run time, and eliminate code that can never be executed. If you can count on your compiler to do this, you may find that your program is more readable if you use <code>if</code> statements with constant conditions (perhaps determined by macros). Of course, you can only use this to exclude code, not type definitions or other preprocessing directives, and you can only do it if the file remains syntactically valid when that code is not used.</p> \u2022 Conditional Uses \u2022 Conditional Syntax \u2022 Deleted Code <p></p> <p>Next: Conditional Syntax, Up: Conditionals \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2661-uses-of-conditional-directives","title":"26.6.1 Uses of Conditional Directives","text":"<p>There are three usual reasons to use a preprocessing conditional.</p> <ul> <li>A program may need to use different code depending on the machine or     operating system it is to run on. In some cases the code for one     operating system may be erroneous on another operating system; for     example, it might refer to data types or constants that do not exist     on the other system. When this happens, it is not enough to avoid     executing the invalid code. Its mere presence will cause the     compiler to reject the program. With a preprocessing conditional,     the offending code can be effectively excised from the program when     it is not valid.</li> <li>You may want to be able to compile the same source file into two     different programs. One version might make frequent time-consuming     consistency checks on its intermediate data, or print the values of     those data for debugging, and the other not.</li> <li>A conditional whose condition is always false is one way to exclude     code from the program but keep it as a sort of comment for future     reference.</li> </ul> <p>Simple programs that do not need system-specific logic or complex debugging hooks generally will not need to use preprocessing conditionals.</p> <p></p> <p>Next: Deleted Code, Previous: Conditional Uses, Up: Conditionals \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2662-syntax-of-preprocessing-conditionals","title":"26.6.2 Syntax of Preprocessing Conditionals","text":"<p>A preprocessing conditional begins with a conditional directive: <code>#if</code>, <code>#ifdef</code> or <code>#ifndef</code>.</p> \u2022 ifdef \u2022 if \u2022 defined \u2022 else \u2022 elif <p></p> <p>Next: if, Up: Conditional Syntax \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#26621-the-ifdef-directive","title":"26.6.2.1 The <code>#ifdef</code> directive","text":"<p>The simplest sort of conditional is</p> <pre><code>#ifdef MACRO\n\ncontrolled text\n\n#endif /* MACRO */\n</code></pre> <p></p> <p>This block is called a conditional group. The body, <code>controlled text</code>, will be included in compilation if and only if <code>MACRO</code> is defined. We say that the conditional succeeds if <code>MACRO</code> is defined, fails if it is not.</p> <p>The <code>controlled text</code> inside a conditional can include preprocessing directives. They are executed only if the conditional succeeds. You can nest conditional groups inside other conditional groups, but they must be completely nested. In other words, <code>#endif</code> always matches the nearest <code>#ifdef</code> (or <code>#ifndef</code>, or <code>#if</code>). Also, you cannot start a conditional group in one file and end it in another.</p> <p>Even if a conditional fails, the <code>controlled text</code> inside it is still run through initial transformations and tokenization. Therefore, it must all be lexically valid C. Normally the only way this matters is that all comments and string literals inside a failing conditional group must still be properly ended.</p> <p>The comment following the <code>#endif</code> is not required, but it is a good practice if there is a lot of <code>controlled text</code>, because it helps people match the <code>#endif</code> to the corresponding <code>#ifdef</code>.</p> <p>Older programs sometimes put <code>macro</code> directly after the <code>#endif</code> without enclosing it in a comment. This is invalid code according to the C standard, but it only causes a warning in GNU C. It never affects which <code>#ifndef</code> the <code>#endif</code> matches.</p> <p></p> <p>Sometimes you wish to use some code if a macro is not defined. You can do this by writing <code>#ifndef</code> instead of <code>#ifdef</code>. One common use of <code>#ifndef</code> is to include code only the first time a header file is included. See Once-Only Headers.</p> <p>Macro definitions can vary between compilations for several reasons. Here are some samples.</p> <ul> <li>Some macros are predefined on each kind of machine (see     System-specific Predefined     Macros     in The C Preprocessor). This allows you to provide code specially     tuned for a particular machine.</li> <li>System header files define more macros, associated with the features     they implement. You can test these macros with conditionals to avoid     using a system feature on a machine where it is not implemented.</li> <li>Macros can be defined or undefined with the <code>-D</code> and <code>-U</code>     command-line options when you compile the program. You can arrange     to compile the same source file into two different programs by     choosing a macro name to specify which program you want, writing     conditionals to test whether or how this macro is defined, and then     controlling the state of the macro with command-line options,     perhaps set in the file <code>Makefile</code>. See Invoking     GCC     in Using the GNU Compiler Collection.</li> <li>Your program might have a special header file (often called     <code>config.h</code>) that is adjusted when the program is compiled. It can     define or not define macros depending on the features of the system     and the desired capabilities of the program. The adjustment can be     automated by a tool such as <code>autoconf</code>, or done by hand.</li> </ul> <p></p> <p>Next: defined, Previous: ifdef, Up: Conditional Syntax \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#26622-the-if-directive","title":"26.6.2.2 The <code>#if</code> directive","text":"<p>The <code>#if</code> directive allows you to test the value of an integer arithmetic expression, rather than the mere existence of one macro. Its syntax is</p> <pre><code>#if expression\n\ncontrolled text\n\n#endif /* expression */\n</code></pre> <p><code>expression</code> is a C expression of integer type, subject to stringent restrictions so its value can be computed at compile time. It may contain</p> <ul> <li> <p>Integer constants.</p> </li> <li> <p>Character constants, which are interpreted as they would be in     normal code.</p> </li> <li> <p>Arithmetic operators for addition, subtraction, multiplication,     division, bitwise operations, shifts, comparisons, and logical     operations (<code>&amp;&amp;</code> and <code>||</code>). The latter two obey the usual     short-circuiting rules of standard C.</p> </li> <li> <p>Macros. All macros in the expression are expanded before actual     computation of the expression\u2019s value begins.</p> </li> <li> <p>Uses of the <code>defined</code> operator, which lets you check whether macros     are defined in the middle of an <code>#if</code>.</p> </li> <li> <p>Identifiers that are not macros, which are all considered to be the     number zero. This allows you to write <code>#if\u00a0MACRO</code> instead of     <code>#ifdef\u00a0MACRO</code>, if you know that MACRO, when defined, will always     have a nonzero value. Function-like macros used without their     function call parentheses are also treated as zero.</p> <p>In some contexts this shortcut is undesirable. The <code>-Wundef</code> requests warnings for any identifier in an <code>#if</code> that is not defined as a macro.</p> </li> </ul> <p>Preprocessing does not know anything about the data types of C. Therefore, <code>sizeof</code> operators are not recognized in <code>#if</code>; <code>sizeof</code> is simply an identifier, and if it is not a macro, it stands for zero. This is likely to make the expression invalid. Preprocessing does not recognize <code>enum</code> constants; they too are simply identifiers, so if they are not macros, they stand for zero.</p> <p>Preprocessing calculates the value of <code>expression</code>, and carries out all calculations in the widest integer type known to the compiler; on most machines supported by GNU C this is 64 bits. This is not the same rule as the compiler uses to calculate the value of a constant expression, and may give different results in some cases. If the value comes out to be nonzero, the <code>#if</code> succeeds and the <code>controlled text</code> is compiled; otherwise it is skipped.</p> <p></p> <p>Next: else, Previous: if, Up: Conditional Syntax \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#26623-the-defined-test","title":"26.6.2.3 The <code>defined</code> test","text":"<p>The special operator <code>defined</code> is used in <code>#if</code> and <code>#elif</code> expressions to test whether a certain name is defined as a macro. <code>defined ``name</code> and <code>defined (``name``)</code> are both expressions whose value is 1 if <code>name</code> is defined as a macro at the current point in the program, and 0 otherwise. Thus, <code>#if\u00a0defined\u00a0MACRO</code> is precisely equivalent to <code>#ifdef\u00a0MACRO</code>.</p> <p><code>defined</code> is useful when you wish to test more than one macro for existence at once. For example,</p> <pre><code>#if defined (__arm__) || defined (__PPC__)\n</code></pre> <p>would succeed if either of the names <code>__arm__</code> or <code>__PPC__</code> is defined as a macro\u2014in other words, when compiling for ARM processors or PowerPC processors.</p> <p>Conditionals written like this:</p> <pre><code>#if defined BUFSIZE &amp;&amp; BUFSIZE &gt;= 1024\n</code></pre> <p>can generally be simplified to just <code>#if\u00a0BUFSIZE\u00a0&gt;=\u00a01024</code>, since if <code>BUFSIZE</code> is not defined, it will be interpreted as having the value zero.</p> <p>In GCC, you can include <code>defined</code> as part of another macro definition, like this:</p> <pre><code>#define MACRO_DEFINED(X) defined X\n\n#if MACRO_DEFINED(BUFSIZE)\n</code></pre> <p>which would expand the <code>#if</code> expression to:</p> <pre><code>#if defined BUFSIZE\n</code></pre> <p>Generating <code>defined</code> in this way is a GNU C extension.</p> <p></p> <p>Next: elif, Previous: defined, Up: Conditional Syntax \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#26624-the-else-directive","title":"26.6.2.4 The <code>#else</code> directive","text":"<p>The <code>#else</code> directive can be added to a conditional to provide alternative text to be used if the condition fails. This is what it looks like:</p> <pre><code>#if expression\ntext-if-true\n#else /* Not expression */\ntext-if-false\n#endif /* Not expression */\n</code></pre> <p>If <code>expression</code> is nonzero, the <code>text-if-true</code> is included and the <code>text-if-false</code> is skipped. If <code>expression</code> is zero, the opposite happens.</p> <p>You can use <code>#else</code> with <code>#ifdef</code> and <code>#ifndef</code>, too.</p> <p></p> <p>Previous: else, Up: Conditional Syntax \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#26625-the-elif-directive","title":"26.6.2.5 The <code>#elif</code> directive","text":"<p>One common case of nested conditionals is used to check for more than two possible alternatives. For example, you might have</p> <pre><code>#if X == 1\n/* \u2026 */\n#else /* X != 1 */\n#if X == 2\n/* \u2026 */\n#else /* X != 2 */\n/* \u2026 */\n#endif /* X != 2 */\n#endif /* X != 1 */\n</code></pre> <p>Another conditional directive, <code>#elif</code>, allows this to be abbreviated as follows:</p> <pre><code>#if X == 1\n/* \u2026 */\n#elif X == 2\n/* \u2026 */\n#else /* X != 2 and X != 1*/\n/* \u2026 */\n#endif /* X != 2 and X != 1*/\n</code></pre> <p><code>#elif</code> stands for \u201celse if\u201d. Like <code>#else</code>, it goes in the middle of a conditional group and subdivides it; it does not require a matching <code>#endif</code> of its own. Like <code>#if</code>, the <code>#elif</code> directive includes an expression to be tested. The text following the <code>#elif</code> is processed only if the original <code>#if</code>-condition failed and the <code>#elif</code> condition succeeds.</p> <p>More than one <code>#elif</code> can go in the same conditional group. Then the text after each <code>#elif</code> is processed only if the <code>#elif</code> condition succeeds after the original <code>#if</code> and all previous <code>#elif</code> directives within it have failed.</p> <p><code>#else</code> is allowed after any number of <code>#elif</code> directives, but <code>#elif</code> may not follow <code>#else</code>.</p> <p></p> <p>Previous: Conditional Syntax, Up: Conditionals \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2663-deleted-code","title":"26.6.3 Deleted Code","text":"<p>If you replace or delete a part of the program but want to keep the old code in the file for future reference, commenting it out is not so straightforward in C. Block comments do not nest, so the first comment inside the old code will end the commenting-out. The probable result is a flood of syntax errors.</p> <p>One way to avoid this problem is to use an always-false conditional instead. For instance, put <code>#if 0</code> before the deleted code and <code>#endif</code> after it. This works even if the code being turned off contains conditionals, but they must be entire conditionals (balanced <code>#if</code> and <code>#endif</code>).</p> <p>Some people use <code>#ifdef notdef</code> instead. This is risky, because <code>notdef</code> might be accidentally defined as a macro, and then the conditional would succeed. <code>#if 0</code> can be counted on to fail.</p> <p>Do not use <code>#if 0</code> around text that is not C code. Use a real comment, instead. The interior of <code>#if 0</code> must consist of complete tokens; in particular, single-quote characters must balance. Comments often contain unbalanced single-quote characters (known in English as apostrophes). These confuse <code>#if 0</code>. They don\u2019t confuse \u2018<code>/*</code>\u2019.</p> <p></p> <p>Next: Line Control, Previous: Conditionals, Up: Preprocessing \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#267-diagnostics","title":"26.7 Diagnostics","text":"<p>The directive <code>#error</code> reports a fatal error. The tokens forming the rest of the line following <code>#error</code> are used as the error message.</p> <p>The usual place to use <code>#error</code> is inside a conditional that detects a combination of parameters that you know the program does not properly support. For example,</p> <pre><code>#if !defined(UNALIGNED_INT_ASM_OP) &amp;&amp; defined(DWARF2_DEBUGGING_INFO)\n#error \"DWARF2_DEBUGGING_INFO requires UNALIGNED_INT_ASM_OP.\"\n#endif\n</code></pre> <p></p> <p>The directive <code>#warning</code> is like <code>#error</code>, but it reports a warning instead of an error. The tokens following <code>#warning</code> are used as the warning message.</p> <p>You might use <code>#warning</code> in obsolete header files, with a message saying which header file to use instead.</p> <p>Neither <code>#error</code> nor <code>#warning</code> macro-expands its argument. Internal whitespace sequences are each replaced with a single space. The line must consist of complete tokens. It is wisest to make the argument of these directives be a single string constant; this avoids problems with apostrophes and the like.</p> <p></p> <p>Next: Null Directive, Previous: Diagnostics, Up: Preprocessing \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#268-line-control","title":"26.8 Line Control","text":"<p>Due to C\u2019s widespread availability and low-level nature, it is often used as the target language for translation of other languages, or for the output of lexical analyzers and parsers (e.g., lex/flex and yacc/bison). Line control enables the user to track diagnostics back to the location in the original language.</p> <p>The C compiler knows the location in the source file where each token came from: file name, starting line and column, and final line and column. (Column numbers are used only for error messages.)</p> <p>When a program generates C source code, as the Bison parser generator does, often it copies some of that C code from another file. For instance parts of the output from Bison are generated from scratch or come from a standard parser file, but Bison copies the rest from Bison\u2019s input file. Errors in that code, at compile time or run time, should refer to that file, which is the real source code. To make that happen, Bison generates line-control directives that the C compiler understands.</p> <p></p> <p><code>#line</code> is a directive that specifies the original line number and source file name for subsequent code. <code>#line</code> has three variants:</p> <p><code>#line ``linenum</code> <code>linenum</code> is a non-negative decimal integer constant. It specifies the line number that should be reported for the following line of input. Subsequent lines are counted from <code>linenum</code>.</p> <p><code>#line ``linenum`` ``filename</code> <code>linenum</code> is the same as for the first form, and has the same effect. In addition, <code>filename</code> is a string constant that specifies the source file name. Subsequent source lines are recorded as coming from that file, until something else happens to change that. <code>filename</code> is interpreted according to the normal rules for a string constant. Backslash escapes are interpreted, in contrast to <code>#include</code>.</p> <p><code>#line ``anything else</code> <code>anything else</code> is checked for macro calls, which are expanded. The result should match one of the above two forms.</p> <p><code>#line</code> directives alter the results of the <code>__FILE__</code> and <code>__LINE__</code> symbols from that point on. See Predefined Macros.</p> <p></p> <p>Previous: Line Control, Up: Preprocessing \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#269-null-directive","title":"26.9 Null Directive","text":"<p>The null directive consists of a <code>#</code> followed by a newline, with only whitespace and comments in between. It has no effect on the output of the compiler.</p> <p></p> <p>Next: Floating Point in Depth, Previous: Preprocessing, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#27-integers-in-depth","title":"27 Integers in Depth","text":"<p>This chapter explains the machine-level details of integer types: how they are represented as bits in memory, and the range of possible values for each integer type.</p> \u2022 Integer Representations How integer values appear in memory. \u2022 Maximum and Minimum Values Value ranges of integer types. <p></p> <p>Next: Maximum and Minimum Values, Up: Integers in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#271-integer-representations","title":"27.1 Integer Representations","text":"<p>Modern computers store integer values as binary (base-2) numbers that occupy a single unit of storage, typically either as an 8-bit <code>char</code>, a 16-bit <code>short int</code>, a 32-bit <code>int</code>, or possibly, a 64-bit <code>long long int</code>. Whether a <code>long int</code> is a 32-bit or a 64-bit value is system dependent.<sup>11</sup></p> <p></p> <p>The macro <code>CHAR_BIT</code>, defined in <code>limits.h</code>, gives the number of bits in type <code>char</code>. On any real operating system, the value is 8.</p> <p>The fixed sizes of numeric types necessarily limits their range of values, and the particular encoding of integers decides what that range is.</p> <p></p> <p>For unsigned integers, the entire space is used to represent a nonnegative value. Signed integers are stored using two\u2019s-complement representation: a signed integer with <code>n</code> bits has a range from -2<sup>(<code>n</code>\\ -\\ 1)</sup> to -1 to 0 to 1 to +2<sup>(<code>n</code>\\ -\\ 1)</sup> - 1, inclusive. The leftmost, or high-order, bit is called the sign bit.</p> <p>In two\u2019s-complement representation, there is only one value that means zero, and the most negative number lacks a positive counterpart. As a result, negating that number causes overflow; in practice, its result is that number back again. We will revisit that peculiarity shortly.</p> <p>For example, a two\u2019s-complement signed 8-bit integer can represent all decimal numbers from -128 to +127. Negating -128 ought to give +128, but that value won\u2019t fit in 8 bits, so the operation yields -128.</p> <p>Decades ago, there were computers that used other representations for signed integers, but they are long gone and not worth any effort to support. The GNU C language does not support them.</p> <p>When an arithmetic operation produces a value that is too big to represent, the operation is said to overflow. In C, integer overflow does not interrupt the control flow or signal an error. What it does depends on signedness.</p> <p>For unsigned arithmetic, the result of an operation that overflows is the <code>n</code> low-order bits of the correct value. If the correct value is representable in <code>n</code> bits, that is always the result; thus we often say that \u201cinteger arithmetic is exact,\u201d omitting the crucial qualifying phrase \u201cas long as the exact result is representable.\u201d</p> <p>In principle, a C program should be written so that overflow never occurs for signed integers, but in GNU C you can specify various ways of handling such overflow (see Integer Overflow).</p> <p>Integer representations are best understood by looking at a table for a tiny integer size; here are the possible values for an integer with three bits:</p> Unsigned Signed Bits 2s Complement 0 0 000 000 (0) 1 1 001 111 (-1) 2 2 010 110 (-2) 3 3 011 101 (-3) 4 -4 100 100 (-4) 5 -3 101 011 (3) 6 -2 110 010 (2) 7 -1 111 001 (1) <p>The parenthesized decimal numbers in the last column represent the signed meanings of the two\u2019s-complement of the line\u2019s value. Recall that, in two\u2019s-complement encoding, the high-order bit is 0 when the number is nonnegative.</p> <p>We can now understand the peculiar behavior of negation of the most negative two\u2019s-complement integer: start with 0b100, invert the bits to get 0b011, and add 1: we get 0b100, the value we started with.</p> <p>We can also see overflow behavior in two\u2019s-complement:</p> <pre><code>3 + 1 = 0b011 + 0b001 = 0b100 = (-4)\n3 + 2 = 0b011 + 0b010 = 0b101 = (-3)\n3 + 3 = 0b011 + 0b011 = 0b110 = (-2)\n</code></pre> <p>A sum of two nonnegative signed values that overflows has a 1 in the sign bit, so the exact positive result is truncated to a negative value.</p> <p></p> <p>Previous: Integer Representations, Up: Integers in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#272-maximum-and-minimum-values","title":"27.2 Maximum and Minimum Values","text":"<p>For each primitive integer type, there is a standard macro defined in <code>limits.h</code> that gives the largest value that type can hold. For instance, for type <code>int</code>, the maximum value is <code>INT_MAX</code>. On a 32-bit computer, that is equal to 2,147,483,647. The maximum value for <code>unsigned int</code> is <code>UINT_MAX</code>, which on a 32-bit computer is equal to 4,294,967,295. Likewise, there are <code>SHRT_MAX</code>, <code>LONG_MAX</code>, and <code>LLONG_MAX</code>, and corresponding unsigned limits <code>USHRT_MAX</code>, <code>ULONG_MAX</code>, and <code>ULLONG_MAX</code>.</p> <p>Since there are three ways to specify a <code>char</code> type, there are also three limits: <code>CHAR_MAX</code>, <code>SCHAR_MAX</code>, and <code>UCHAR_MAX</code>.</p> <p>For each type that is or might be signed, there is another symbol that gives the minimum value it can hold. (Just replace <code>MAX</code> with <code>MIN</code> in the names listed above.) There is no minimum limit symbol for types specified with <code>unsigned</code> because the minimum for them is universally zero.</p> <p><code>INT_MIN</code> is not the negative of <code>INT_MAX</code>. In two\u2019s-complement representation, the most negative number is 1 less than the negative of the most positive number. Thus, <code>INT_MIN</code> on a 32-bit computer has the value -2,147,483,648. You can\u2019t actually write the value that way in C, since it would overflow. That\u2019s a good reason to use <code>INT_MIN</code> to specify that value. Its definition is written to avoid overflow.</p> <p>This is part of the GNU C Intro and Reference Manual and covered by its license.</p> <p></p> <p>Next: Compilation, Previous: Integers in Depth, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#28-floating-point-in-depth","title":"28 Floating Point in Depth","text":"\u2022 Floating Representations \u2022 Floating Type Specs \u2022 Special Float Values \u2022 Invalid Optimizations \u2022 Exception Flags \u2022 Exact Floating-Point \u2022 Rounding \u2022 Rounding Issues \u2022 Significance Loss \u2022 Fused Multiply-Add \u2022 Error Recovery \u2022 Exact Floating Constants \u2022 Handling Infinity \u2022 Handling NaN \u2022 Signed Zeros \u2022 Scaling by the Base \u2022 Rounding Control \u2022 Machine Epsilon \u2022 Complex Arithmetic \u2022 Round-Trip Base Conversion \u2022 Further Reading <p>Next: Floating Type Specs, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#281-floating-point-representations","title":"28.1 Floating-Point Representations","text":"<p>Storing numbers as floating point allows representation of numbers with fractional values, in a range larger than that of hardware integers. A floating-point number consists of a sign bit, a significand (also called the mantissa), and a power of a fixed base. GNU C uses the floating-point representations specified by the IEEE 754-2008 Standard for Floating-Point Arithmetic.</p> <p>The IEEE 754-2008 specification defines basic binary floating-point formats of five different sizes: 16-bit, 32-bit, 64-bit, 128-bit, and 256-bit. The formats of 32, 64, and 128 bits are used for the standard C types <code>float</code>, <code>double</code>, and <code>long double</code>. GNU C supports the 16-bit floating point type <code>_Float16</code> on some platforms, but does not support the 256-bit floating point type.</p> <p>Each of the formats encodes the floating-point number as a sign bit. After this comes an exponent that specifies a power of 2 (with a fixed offset). Then comes the significand.</p> <p>The first bit of the significand, before the binary point, is always 1, so there is no need to store it in memory. It is called the hidden bit because it doesn\u2019t appear in the floating-point number as used in the computer itself.</p> <p>All of those floating-point formats are sign-magnitude representations, so +0 and -0 are different values.</p> <p>Besides the IEEE 754 format 128-bit float, GNU C also offers a format consisting of a pair of 64-bit floating point numbers. This lacks the full exponent range of the IEEE 128-bit format, but is useful when the underlying hardware platform does not support that.</p> <p></p> <p>Next: Special Float Values, Previous: Floating Representations, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#282-floating-point-type-specifications","title":"28.2 Floating-Point Type Specifications","text":"<p>The standard library header file <code>float.h</code> defines a number of constants that describe the platform\u2019s implementation of floating-point types <code>float</code>, <code>double</code> and <code>long double</code>. They include:</p> <p> </p> <p><code>FLT_MIN</code> <code>DBL_MIN</code> <code>LDBL_MIN</code> Defines the minimum normalized positive floating-point values that can be represented with the type.</p> <p><code>FLT_HAS_SUBNORM</code> <code>DBL_HAS_SUBNORM</code> <code>LDBL_HAS_SUBNORM</code> Defines if the floating-point type supports subnormal (or \u201cdenormalized\u201d) numbers or not (see subnormal numbers).</p> <p><code>FLT_TRUE_MIN</code> <code>DBL_TRUE_MIN</code> <code>LDBL_TRUE_MIN</code> Defines the minimum positive values (including subnormal values) that can be represented with the type.</p> <p><code>FLT_MAX</code> <code>DBL_MAX</code> <code>LDBL_MAX</code> Defines the largest values that can be represented with the type.</p> <p><code>FLT_DECIMAL_DIG</code> <code>DBL_DECIMAL_DIG</code> <code>LDBL_DECIMAL_DIG</code> Defines the number of decimal digits <code>n</code> such that any floating-point number that can be represented in the type can be rounded to a floating-point number with <code>n</code> decimal digits, and back again, without losing any precision of the value.</p> <p></p> <p>Next: Invalid Optimizations, Previous: Floating Type Specs, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#283-special-floating-point-values","title":"28.3 Special Floating-Point Values","text":"<p>IEEE floating point provides for special values that are not ordinary numbers.</p> <p>infinities <code>+Infinity</code> and <code>-Infinity</code> are two different infinite values, one positive and one negative. These result from operations such as <code>1 / 0</code>, <code>Infinity + Infinity</code>, <code>Infinity * Infinity</code>, and <code>Infinity + ``finite</code>, and also from a result that is finite, but larger than the most positive possible value or smaller than the most negative possible value.</p> <p>See Handling Infinity, for more about working with infinities.</p> <p>NaNs (not a number) </p> <p>There are two special values, called Not-a-Number (NaN): a quiet NaN (QNaN), and a signaling NaN (SNaN).</p> <p>A QNaN is produced by operations for which the value is undefined in real arithmetic, such as <code>0 / 0</code>, <code>sqrt (-1)</code>, <code>Infinity - Infinity</code>, and any basic operation in which an operand is a QNaN.</p> <p>The signaling NaN is intended for initializing otherwise-unassigned storage, and the goal is that unlike a QNaN, an SNaN does cause an interrupt that can be caught by a software handler, diagnosed, and reported. In practice, little use has been made of signaling NaNs, because the most common CPUs in desktop and portable computers fail to implement the full IEEE 754 Standard, and supply only one kind of NaN, the quiet one. Also, programming-language standards have taken decades to catch up to the IEEE 754 standard, and implementations of those language standards make an additional delay before programmers become willing to use these features.</p> <p>To enable support for signaling NaNs, use the GCC command-line option <code>-fsignaling-nans</code>, but this is an experimental feature and may not work as expected in every situation.</p> <p>A NaN has a sign bit, but its value means nothing.</p> <p>See Handling NaN, for more about working with NaNs.</p> <p>subnormal numbers </p> <p>It can happen that a computed floating-point value is too small to represent, such as when two tiny numbers are multiplied. The result is then said to underflow. The traditional behavior before the IEEE 754 Standard was to use zero as the result, and possibly to report the underflow in some sort of program output.</p> <p>The IEEE 754 Standard is vague about whether rounding happens before detection of floating underflow and overflow, or after, and CPU designers may choose either.</p> <p>However, the Standard does something unusual compared to earlier designs, and that is that when the result is smaller than the smallest normalized representable value (i.e., one in which the leading significand bit is <code>1</code>), the normalization requirement is relaxed, leading zero bits are permitted, and precision is gradually lost until there are no more bits in the significand. That phenomenon is called gradual underflow, and it serves important numerical purposes, although it does reduce the precision of the final result. Some floating-point designs allow you to choose at compile time, or even at run time, whether underflows are gradual, or are flushed abruptly to zero. Numbers that have entered the region of gradual underflow are called subnormal.</p> <p>You can use the library functions <code>fesetround</code> and <code>fegetround</code> to set and get the rounding mode. Rounding modes are defined (if supported by the platform) in <code>fenv.h</code> as: <code>FE_UPWARD</code> to round toward positive infinity; <code>FE_DOWNWARD</code> to round toward negative infinity; <code>FE_TOWARDZERO</code> to round toward zero; and <code>FE_TONEAREST</code> to round to the nearest representable value, the default mode. It is best to use <code>FE_TONEAREST</code> except when there is a special need for some other mode.</p> <p></p> <p>Next: Exception Flags, Previous: Special Float Values, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#284-invalid-optimizations","title":"28.4 Invalid Optimizations","text":"<p>Signed zeros, Infinity, and NaN invalidate some optimizations by programmers and compilers that might otherwise have seemed obvious:</p> <ul> <li><code>x + 0</code> and <code>x - 0</code> are not the same as <code>x</code> when <code>x</code> is zero,     because the result depends on the rounding rule. See     Rounding, for more about rounding rules.</li> <li><code>x * 0.0</code> is not the same as <code>0.0</code> when <code>x</code> is Infinity, a NaN, or     negative zero.</li> <li><code>x / x</code> is not the same as <code>1.0</code> when <code>x</code> is Infinity, a NaN, or     zero.</li> <li><code>(x - y)</code> is not the same as <code>-(y - x)</code> because when the operands     are finite and equal, one evaluates to <code>+0</code> and the other to <code>-0</code>.</li> <li><code>x - x</code> is not the same as <code>0.0</code> when <code>x</code> is Infinity or a NaN.</li> <li><code>x == x</code> and <code>x != x</code> are not equivalent to <code>1</code> and <code>0</code> when <code>x</code> is     a NaN.</li> <li><code>x &lt; y</code> and <code>isless (x, y)</code> are not equivalent, because the first     sets a sticky exception flag (see Exception     Flags) when an operand is a NaN, whereas the     second does not affect that flag. The same holds for the other     <code>isxxx</code> functions that are companions to relational operators. See     FP Comparison     Functions     in The GNU C Library Reference Manual.</li> </ul> <p>The <code>-funsafe-math-optimizations</code> option enables these optimizations.</p> <p></p> <p>Next: Exact Floating-Point, Previous: Invalid Optimizations, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#285-floating-arithmetic-exception-flags","title":"28.5 Floating Arithmetic Exception Flags","text":"<p>Sticky exception flags record the occurrence of particular conditions: once set, they remain set until the program explicitly clears them.</p> <p>The conditions include invalid operand, division-by_zero, inexact result (i.e., one that required rounding), underflow, and overflow. Some extended floating-point designs offer several additional exception flags. The functions <code>feclearexcept</code>, <code>feraiseexcept</code>, <code>fetestexcept</code>, <code>fegetexceptflags</code>, and <code>fesetexceptflags</code> provide a standardized interface to those flags. See Status bit operations in The GNU C Library Reference Manual.</p> <p>One important use of those flags is to do a computation that is normally expected to be exact in floating-point arithmetic, but occasionally might not be, in which case, corrective action is needed. You can clear the inexact result flag with a call to <code>feclearexcept (FE_INEXACT)</code>, do the computation, and then test the flag with <code>fetestexcept (FE_INEXACT)</code>; the result of that call is 0 if the flag is not set (there was no rounding), and 1 when there was rounding (which, we presume, implies the program has to correct for that).</p> <p></p> <p>Next: Rounding, Previous: Exception Flags, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#286-exact-floating-point-arithmetic","title":"28.6 Exact Floating-Point Arithmetic","text":"<p>As long as the numbers are exactly representable (fractions whose denominator is a power of 2), and intermediate results do not require rounding, then floating-point arithmetic is exact. It is easy to predict how many digits are needed for the results of arithmetic operations:</p> <ul> <li>addition and subtraction of two <code>n</code>-digit values with the same     exponent require at most <code>n`` + 1</code> digits, but when the exponents     differ, many more digits may be needed;</li> <li>multiplication of two <code>n</code>-digit values requires exactly 2 <code>n</code>     digits;</li> <li>although integer division produces a quotient and a remainder of no     more than <code>n</code>-digits, floating-point remainder and square root may     require an unbounded number of digits, and the quotient can need     many more digits than can be stored.</li> </ul> <p>Whenever a result requires more than <code>n</code> digits, rounding is needed.</p> <p></p> <p>Next: Rounding Issues, Previous: Exact Floating-Point, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#287-rounding","title":"28.7 Rounding","text":"<p>When floating-point arithmetic produces a result that can\u2019t fit exactly in the significand of the type that\u2019s in use, it has to round the value. The basic arithmetic operations\u2014addition, subtraction, multiplication, division, and square root\u2014always produce a result that is equivalent to the exact, possibly infinite-precision result rounded to storage precision according to the current rounding rule.</p> <p>Rounding sets the <code>FE_INEXACT</code> exception flag (see Exception Flags). This enables programs to determine that rounding has occurred.</p> <p>Rounding consists of adjusting the exponent to bring the significand back to the required base-point alignment, then applying the current rounding rule to squeeze the significand into the fixed available size.</p> <p>The current rule is selected at run time from four options. Here they are:</p> <ul> <li>* round-to-nearest, with ties rounded to an even integer;</li> <li>* round-up, towards <code>+Infinity</code>;</li> <li>* round-down, towards <code>-Infinity</code>;</li> <li>* round-towards-zero.</li> </ul> <p>Under those four rounding rules, a decimal value <code>-1.2345</code> that is to be rounded to a four-digit result would become <code>-1.234</code>, <code>-1.234</code>, <code>-1.235</code>, and <code>-1.234</code>, respectively.</p> <p>The default rounding rule is round-to-nearest, because that has the least bias, and produces the lowest average error. When the true result lies exactly halfway between two representable machine numbers, the result is rounded to the one that ends with an even digit.</p> <p>The round-towards-zero rule was common on many early computer designs, because it is the easiest to implement: it just requires silent truncation of all extra bits.</p> <p>The two other rules, round-up and round-down, are essential for implementing interval arithmetic, whereby each arithmetic operation produces lower and upper bounds that are guaranteed to enclose the exact result.</p> <p>See Rounding Control, for details on getting and setting the current rounding mode.</p> <p></p> <p>Next: Significance Loss, Previous: Rounding, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#288-rounding-issues","title":"28.8 Rounding Issues","text":"<p>The default IEEE 754 rounding mode minimizes errors, and most normal computations should not suffer any serious accumulation of errors from rounding.</p> <p>Of course, you can contrive examples where that is not so. Here is one: iterate a square root, then attempt to recover the original value by repeated squaring.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main (void)\n{\n  double x = 100.0;\n  double y;\n  int n, k;\n  for (n = 10; n &lt;= 100; n += 10)\n    {\n      y = x;\n      for (k = 0; k &lt; n; ++k) y = sqrt (y);\n      for (k = 0; k &lt; n; ++k) y *= y;\n      printf (\"n = %3d; x = %.0f\\ty = %.6f\\n\", n, x, y);\n    }\n  return 0;\n}\n</code></pre> <p>Here is the output:</p> <pre><code>n =  10; x = 100        y = 100.000000\nn =  20; x = 100        y = 100.000000\nn =  30; x = 100        y = 99.999977\nn =  40; x = 100        y = 99.981025\nn =  50; x = 100        y = 90.017127\nn =  60; x = 100        y = 1.000000\nn =  70; x = 100        y = 1.000000\nn =  80; x = 100        y = 1.000000\nn =  90; x = 100        y = 1.000000\nn = 100; x = 100        y = 1.000000\n</code></pre> <p>After 50 iterations, <code>y</code> has barely one correct digit, and soon after, there are no correct digits.</p> <p></p> <p>Next: Fused Multiply-Add, Previous: Rounding Issues, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#289-significance-loss","title":"28.9 Significance Loss","text":"<p>A much more serious source of error in floating-point computation is significance loss from subtraction of nearly equal values. This means that the number of bits in the significand of the result is fewer than the size of the value would permit. If the values being subtracted are close enough, but still not equal, a single subtraction can wipe out all correct digits, possibly contaminating all future computations.</p> <p>Floating-point calculations can sometimes be carefully designed so that significance loss is not possible, such as summing a series where all terms have the same sign. For example, the Taylor series expansions of the trigonometric and hyperbolic sines have terms of identical magnitude, of the general form <code>x``**(2*``n`` + 1) / (2*``n`` + 1)!</code>. However, those in the trigonometric sine series alternate in sign, while those in the hyperbolic sine series are all positive. Here is the output of two small programs that sum <code>k</code> terms of the series for <code>sin (``x``)</code>, and compare the computed sums with known-to-be-accurate library functions:</p> <pre><code>x = 10      k = 51\ns (x)   = -0.544_021_110_889_270\nsin (x) = -0.544_021_110_889_370\n\nx = 20      k = 81\ns (x)   = 0.912_945_250_749_573\nsin (x) = 0.912_945_250_727_628\n\nx = 30      k = 109\ns (x)   = -0.987_813_746_058_855\nsin (x) = -0.988_031_624_092_862\n\nx = 40      k = 137\ns (x)   = 0.617_400_430_980_474\nsin (x) = 0.745_113_160_479_349\n\nx = 50      k = 159\ns (x)   = 57_105.187_673_745_720_532\nsin (x) = -0.262_374_853_703_929\n\n// sinh(x) series summation with positive signs\n// with k terms needed to converge to machine precision\n\nx = 10      k = 47\nt (x)    = 1.101_323_287_470_340e+04\nsinh (x) = 1.101_323_287_470_339e+04\n\nx = 20      k = 69\nt (x)    = 2.425_825_977_048_951e+08\nsinh (x) = 2.425_825_977_048_951e+08\n\nx = 30      k = 87\nt (x)    = 5.343_237_290_762_229e+12\nsinh (x) = 5.343_237_290_762_231e+12\n\nx = 40      k = 105\nt (x)    = 1.176_926_334_185_100e+17\nsinh (x) = 1.176_926_334_185_100e+17\n\nx = 50      k = 121\nt (x)    = 2.592_352_764_293_534e+21\nsinh (x) = 2.592_352_764_293_536e+21\n</code></pre> <p>We have added underscores to the numbers to enhance readability.</p> <p>The <code>sinh (``x``)</code> series with positive terms can be summed to high accuracy. By contrast, the series for <code>sin (``x``)</code> suffers increasing significance loss, so that when <code>x</code> = 30 only two correct digits remain. Soon after, all digits are wrong, and the answers are complete nonsense.</p> <p>An important skill in numerical programming is to recognize when significance loss is likely to contaminate a computation, and revise the algorithm to reduce this problem. Sometimes, the only practical way to do so is to compute in higher intermediate precision, which is why the extended types like <code>long double</code> are important.</p> <p></p> <p>Next: Error Recovery, Previous: Significance Loss, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2810-fused-multiply-add","title":"28.10 Fused Multiply-Add","text":"<p>In 1990, when IBM introduced the POWER architecture, the CPU provided a previously unknown instruction, the fused multiply-add (FMA). It computes the value <code>x * y + z</code> with an exact double-length product, followed by an addition with a single rounding. Numerical computation often needs pairs of multiply and add operations, for which the FMA is well-suited.</p> <p>On the POWER architecture, there are two dedicated registers that hold permanent values of <code>0.0</code> and <code>1.0</code>, and the normal multiply and add instructions are just wrappers around the FMA that compute <code>x * y + 0.0</code> and <code>x * 1.0 + z</code>, respectively.</p> <p>In the early days, it appeared that the main benefit of the FMA was getting two floating-point operations for the price of one, almost doubling the performance of some algorithms. However, numerical analysts have since shown numerous uses of the FMA for significantly enhancing accuracy. We discuss one of the most important ones in the next section.</p> <p>A few other architectures have since included the FMA, and most provide variants for the related operations <code>x * y - z</code> (FMS), <code>-x * y + z</code> (FNMA), and <code>-x * y - z</code> (FNMS).</p> <p>The functions <code>fmaf</code>, <code>fma</code>, and <code>fmal</code> implement fused multiply-add for the <code>float</code>, <code>double</code>, and <code>long double</code> data types. Correct implementation of the FMA in software is difficult, and some systems that appear to provide those functions do not satisfy the single-rounding requirement. That situation should change as more programmers use the FMA operation, and more CPUs provide FMA in hardware.</p> <p>Use the <code>-ffp-contract=fast</code> option to allow generation of FMA instructions, or <code>-ffp-contract=off</code> to disallow it.</p> <p></p> <p>Next: Exact Floating Constants, Previous: Fused Multiply-Add, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2811-error-recovery","title":"28.11 Error Recovery","text":"<p>When two numbers are combined by one of the four basic operations, the result often requires rounding to storage precision. For accurate computation, one would like to be able to recover that rounding error. With historical floating-point designs, it was difficult to do so portably, but now that IEEE 754 arithmetic is almost universal, the job is much easier.</p> <p>For addition with the default round-to-nearest rounding mode, we can determine the error in a sum like this:</p> <pre><code>volatile double err, sum, tmp, x, y;\n\nif (fabs (x) &gt;= fabs (y))\n  {\n    sum = x + y;\n    tmp = sum - x;\n    err = y - tmp;\n  }\nelse /* fabs (x) &lt; fabs (y) */\n  {\n    sum = x + y;\n    tmp = sum - y;\n    err = x - tmp;\n  }\n</code></pre> <p> Now, <code>x + y</code> is exactly represented by <code>sum + err</code>. This basic operation, which has come to be called twosum in the numerical-analysis literature, is the first key to tracking, and accounting for, rounding error.</p> <p>To determine the error in subtraction, just swap the <code>+</code> and <code>-</code> operators.</p> <p>We used the <code>volatile</code> qualifier (see volatile) in the declaration of the variables, which forces the compiler to store and retrieve them from memory, and prevents the compiler from optimizing <code>err = y - ((x + y) - x)</code> into <code>err = 0</code>.</p> <p>For multiplication, we can compute the rounding error without magnitude tests with the FMA operation (see Fused Multiply-Add), like this:</p> <pre><code>volatile double err, prod, x, y;\nprod = x * y;                /* rounded product */\nerr  = fma (x, y, -prod);    /* exact product = prod + err */\n</code></pre> <p>For addition, subtraction, and multiplication, we can represent the exact result with the notional sum of two values. However, the exact result of division, remainder, or square root potentially requires an infinite number of digits, so we can at best approximate it. Nevertheless, we can compute an error term that is close to the true error: it is just that error value, rounded to machine precision.</p> <p>For division, you can approximate <code>x / y</code> with <code>quo + err</code> like this:</p> <pre><code>volatile double err, quo, x, y;\nquo = x / y;\nerr = fma (-quo, y, x) / y;\n</code></pre> <p>For square root, we can approximate <code>sqrt (x)</code> with <code>root + err</code> like this:</p> <pre><code>volatile double err, root, x;\nroot = sqrt (x);\nerr = fma (-root, root, x) / (root + root);\n</code></pre> <p>With the reliable and predictable floating-point design provided by IEEE 754 arithmetic, we now have the tools we need to track errors in the five basic floating-point operations, and we can effectively simulate computing in twice working precision, which is sometimes sufficient to remove almost all traces of arithmetic errors.</p> <p></p> <p>Next: Handling Infinity, Previous: Error Recovery, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2812-exact-floating-point-constants","title":"28.12 Exact Floating-Point Constants","text":"<p>One of the frustrations that numerical programmers have suffered with since the dawn of digital computers is the inability to precisely specify numbers in their programs. On the early decimal machines, that was not an issue: you could write a constant <code>1e-30</code> and be confident of that exact value being used in floating-point operations. However, when the hardware works in a base other than 10, then human-specified numbers have to be converted to that base, and then converted back again at output time. The two base conversions are rarely exact, and unwanted rounding errors are introduced.</p> <p></p> <p>As computers usually represent numbers in a base other than 10, numbers often must be converted to and from different bases, and rounding errors can occur during conversion. This problem is solved in C using hexademical floating-point constants. For example, <code>+0x1.fffffcp-1</code> is the number that is the IEEE 754 32-bit value closest to, but below, <code>1.0</code>. The significand is represented as a hexadecimal fraction, and the power of two is written in decimal following the exponent letter <code>p</code> (the traditional exponent letter <code>e</code> is not possible, because it is a hexadecimal digit).</p> <p>In <code>printf</code> and <code>scanf</code> and related functions, you can use the \u2018<code>%a</code>\u2019 and \u2018<code>%A</code>\u2019 format specifiers for writing and reading hexadecimal floating-point values. \u2018<code>%a</code>\u2019 writes them with lower case letters and \u2018<code>%A</code>\u2019 writes them with upper case letters. For instance, this code reproduces our sample number:</p> <pre><code>printf (\"%a\\n\", 1.0 - pow (2.0, -23));\n    -| 0x1.fffffcp-1\n</code></pre> <p>The <code>strtod</code> family was similarly extended to recognize numbers in that new format.</p> <p>If you want to ensure exact data representation for transfer of floating-point numbers between C programs on different computers, then hexadecimal constants are an optimum choice.</p> <p></p> <p>Next: Handling NaN, Previous: Exact Floating Constants, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2813-handling-infinity","title":"28.13 Handling Infinity","text":"<p>As we noted earlier, the IEEE 754 model of computing is not to stop the program when exceptional conditions occur. It takes note of exceptional values or conditions by setting sticky exception flags, or by producing results with the special values Infinity and QNaN. In this section, we discuss Infinity; see Handling NaN for the other.</p> <p>In GNU C, you can create a value of negative Infinity in software like this:</p> <pre><code>double x;\n\nx = -1.0 / 0.0;\n</code></pre> <p>GNU C supplies the <code>__builtin_inf</code>, <code>__builtin_inff</code>, and <code>__builtin_infl</code> macros, and the GNU C Library provides the <code>INFINITY</code> macro, all of which are compile-time constants for positive infinity.</p> <p>GNU C also provides a standard function to test for an Infinity: <code>isinf (x)</code> returns <code>1</code> if the argument is a signed infinity, and <code>0</code> if not.</p> <p>Infinities can be compared, and all Infinities of the same sign are equal: there is no notion in IEEE 754 arithmetic of different kinds of Infinities, as there are in some areas of mathematics. Positive Infinity is larger than any finite value, and negative Infinity is smaller than any finite value.</p> <p>Infinities propagate in addition, subtraction, multiplication, and square root, but in division, they disappear, because of the rule that <code>finite / Infinity</code> is <code>0.0</code>. Thus, an overflow in an intermediate computation that produces an Infinity is likely to be noticed later in the final results. The programmer can then decide whether the overflow is expected, and acceptable, or whether the code possibly has a bug, or needs to be run in higher precision, or redesigned to avoid the production of the Infinity.</p> <p></p> <p>Next: Signed Zeros, Previous: Handling Infinity, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2814-handling-nan","title":"28.14 Handling NaN","text":"<p>NaNs are not numbers: they represent values from computations that produce undefined results. They have a distinctive property that makes them unlike any other floating-point value: they are unequal to everything, including themselves! Thus, you can write a test for a NaN like this:</p> <pre><code>if (x != x)\n  printf (\"x is a NaN\\n\");\n</code></pre> <p>This test works in GNU C, but some compilers might evaluate that test expression as false without properly checking for the NaN value. A more portable way to test for NaN is to use the <code>isnan</code> function declared in <code>math.h</code>:</p> <pre><code>if (isnan (x))\n  printf (\"x is a NaN\\n\");\n</code></pre> <p>See Floating Point Classes in The GNU C Library Reference Manual.</p> <p>One important use of NaNs is marking of missing data. For example, in statistics, such data must be omitted from computations. Use of any particular finite value for missing data would eventually collide with real data, whereas such data could never be a NaN, so it is an ideal marker. Functions that deal with collections of data that may have holes can be written to test for, and ignore, NaN values.</p> <p>It is easy to generate a NaN in computations: evaluating <code>0.0 / 0.0</code> is the commonest way, but <code>Infinity - Infinity</code>, <code>Infinity / Infinity</code>, and <code>sqrt (-1.0)</code> also work. Functions that receive out-of-bounds arguments can choose to return a stored NaN value, such as with the <code>NAN</code> macro defined in <code>math.h</code>, but that does not set the invalid operand exception flag, and that can fool some programs.</p> <p></p> <p>Like Infinity, NaNs propagate in computations, but they are even stickier, because they never disappear in division. Thus, once a NaN appears in a chain of numerical operations, it is almost certain to pop out into the final results. The programmer has to decide whether that is expected, or whether there is a coding or algorithmic error that needs repair.</p> <p>In general, when function gets a NaN argument, it usually returns a NaN. However, there are some exceptions in the math-library functions that you need to be aware of, because they violate the NaNs-always-propagate rule:</p> <ul> <li><code>pow (x, 0.0)</code> always returns <code>1.0</code>, even if <code>x</code> is 0.0, Infinity,     or a NaN.</li> <li><code>pow (1, y)</code> always returns <code>1</code>, even if <code>y</code> is a NaN.</li> <li><code>hypot (INFINITY, y)</code> and <code>hypot (-INFINITY, y)</code> both always return     <code>INFINITY</code>, even if <code>y</code> is a Nan.</li> <li>If just one of the arguments to <code>fmax (x, y)</code> or <code>fmin (x, y)</code> is a     NaN, it returns the other argument. If both arguments are NaNs, it     returns a NaN, but there is no requirement about where it comes     from: it could be <code>x</code>, or <code>y</code>, or some other quiet NaN.</li> </ul> <p>NaNs are also used for the return values of math-library functions where the result is not representable in real arithmetic, or is mathematically undefined or uncertain, such as <code>sqrt (-1.0)</code> and <code>sin (Infinity)</code>. However, note that a result that is merely too big to represent should always produce an Infinity, such as with <code>exp (1000.0)</code> (too big) and <code>exp (Infinity)</code> (truly infinite).</p> <p></p> <p>Next: Scaling by the Base, Previous: Handling NaN, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2815-signed-zeros","title":"28.15 Signed Zeros","text":"<p>The sign of zero is significant, and important, because it records the creation of a value that is too small to represent, but came from either the negative axis, or from the positive axis. Such fine distinctions are essential for proper handling of branch cuts in complex arithmetic (see Complex Arithmetic).</p> <p>The key point about signed zeros is that in comparisons, their sign does not matter: <code>0.0 == -0.0</code> must always evaluate to <code>1</code> (true). However, they are not the same number, and <code>-0.0</code> in C code stands for a negative zero.</p> <p></p> <p>Next: Rounding Control, Previous: Signed Zeros, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2816-scaling-by-powers-of-the-base","title":"28.16 Scaling by Powers of the Base","text":"<p>We have discussed rounding errors several times in this chapter, but it is important to remember that when results require no more bits than the exponent and significand bits can represent, those results are exact.</p> <p>One particularly useful exact operation is scaling by a power of the base. While one, in principle, could do that with code like this:</p> <pre><code>y = x * pow (2.0, (double)k);   /* Undesirable scaling: avoid! */\n</code></pre> <p>that is not advisable, because it relies on the quality of the math-library power function, and that happens to be one of the most difficult functions in the C math library to make accurate. What is likely to happen on many systems is that the returned value from <code>pow</code> will be close to a power of two, but slightly different, so the subsequent multiplication introduces rounding error.</p> <p>The correct, and fastest, way to do the scaling is either via the traditional C library function, or with its C99 equivalent:</p> <pre><code>y = ldexp (x, k);            /* Traditional pre-C99 style. */\ny = scalbn (x, k);           /* C99 style. */\n</code></pre> <p>Both functions return <code>x * 2**k</code>. See Normalization Functions in The GNU C Library Reference Manual.</p> <p></p> <p>Next: Machine Epsilon, Previous: Scaling by the Base, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2817-rounding-control","title":"28.17 Rounding Control","text":"<p>Here we describe how to specify the rounding mode at run time. System header file <code>fenv.h</code> provides the prototypes for these functions. See Rounding in The GNU C Library Reference Manual.</p> <p>That header file also provides constant names for the four rounding modes: <code>FE_DOWNWARD</code>, <code>FE_TONEAREST</code>, <code>FE_TOWARDZERO</code>, and <code>FE_UPWARD</code>.</p> <p>The function <code>fegetround</code> examines and returns the current rounding mode. On a platform with IEEE 754 floating point, the value will always equal one of those four constants. On other platforms, it may return a negative value. The function <code>fesetround</code> sets the current rounding mode.</p> <p>Changing the rounding mode can be slow, so it is useful to minimize the number of changes. For interval arithmetic, we seem to need three changes for each operation, but we really only need two, because we can write code like this example for interval addition of two reals:</p> <pre><code>{\n  struct interval_double\n    {\n      double hi, lo;\n    } v;\n  extern volatile double x, y;\n  int rule;\n\n  rule = fegetround ();\n\n  if (fesetround (FE_UPWARD) == 0)\n    {\n      v.hi = x + y;\n      v.lo = -(-x - y);\n    }\n  else\n    fatal (\"ERROR: failed to change rounding rule\");\n\n  if (fesetround (rule) != 0)\n    fatal (\"ERROR: failed to restore rounding rule\");\n}\n</code></pre> <p>The <code>volatile</code> qualifier (see volatile) is essential on x86 platforms to prevent an optimizing compiler from producing the same value for both bounds.</p> <p></p> <p>Next: Complex Arithmetic, Previous: Rounding Control, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2818-machine-epsilon","title":"28.18 Machine Epsilon","text":"<p>In any floating-point system, three attributes are particularly important to know: base (the number that the exponent specifies a power of), precision (number of digits in the significand), and range (difference between most positive and most negative values). The allocation of bits between exponent and significand decides the answers to those questions.</p> <p>A measure of the precision is the answer to the question: what is the smallest number that can be added to <code>1.0</code> such that the sum differs from <code>1.0</code>? That number is called the machine epsilon.</p> <p>We could define the needed machine-epsilon constants for <code>float</code>, <code>double</code>, and <code>long double</code> like this:</p> <pre><code>static const float  epsf = 0x1p-23;  /* about 1.192e-07 */\nstatic const double eps  = 0x1p-52;  /* about 2.220e-16 */\nstatic const long double epsl = 0x1p-63;  /* about 1.084e-19 */\n</code></pre> <p>Instead of the hexadecimal constants, we could also have used the Standard C macros, <code>FLT_EPSILON</code>, <code>DBL_EPSILON</code>, and <code>LDBL_EPSILON</code>.</p> <p>It is useful to be able to compute the machine epsilons at run time, and we can easily generalize the operation by replacing the constant <code>1.0</code> with a user-supplied value:</p> <pre><code>double\nmacheps (double x)\n{ /* Return machine epsilon for x,  */\n   /* such that x + macheps (x) &gt; x.  */\n  static const double base = 2.0;\n  double eps;\n\n  if (isnan (x))\n      eps = x;\n  else\n    {\n      eps = (x == 0.0) ? 1.0 : x;\n\n      while ((x + eps / base) != x)\n          eps /= base;          /* Always exact!  */\n    }\n\n  return (eps);\n}\n</code></pre> <p>If we call that function with arguments from <code>0</code> to <code>10</code>, as well as Infinity and NaN, and print the returned values in hexadecimal, we get output like this:</p> <pre><code>macheps (  0) = 0x1.0000000000000p-1074\nmacheps (  1) = 0x1.0000000000000p-52\nmacheps (  2) = 0x1.0000000000000p-51\nmacheps (  3) = 0x1.8000000000000p-52\nmacheps (  4) = 0x1.0000000000000p-50\nmacheps (  5) = 0x1.4000000000000p-51\nmacheps (  6) = 0x1.8000000000000p-51\nmacheps (  7) = 0x1.c000000000000p-51\nmacheps (  8) = 0x1.0000000000000p-49\nmacheps (  9) = 0x1.2000000000000p-50\nmacheps ( 10) = 0x1.4000000000000p-50\nmacheps (Inf) = infinity\nmacheps (NaN) = nan\n</code></pre> <p>Notice that <code>macheps</code> has a special test for a NaN to prevent an infinite loop.</p> <p>Our code made another test for a zero argument to avoid getting a zero return. The returned value in that case is the smallest representable floating-point number, here the subnormal value <code>2**(-1074)</code>, which is about <code>4.941e-324</code>.</p> <p>No special test is needed for an Infinity, because the <code>eps</code>-reduction loop then terminates at the first iteration.</p> <p>Our <code>macheps</code> function here assumes binary floating point; some architectures may differ.</p> <p>The C library includes some related functions that can also be used to determine machine epsilons at run time:</p> <pre><code>#include &lt;math.h&gt;           /* Include for these prototypes. */\n\ndouble      nextafter  (double x, double y);\nfloat       nextafterf (float x, float y);\nlong double nextafterl (long double x, long double y);\n</code></pre> <p>These return the machine number nearest <code>x</code> in the direction of <code>y</code>. For example, <code>nextafter (1.0, 2.0)</code> produces the same result as <code>1.0 + macheps (1.0)</code> and <code>1.0 + DBL_EPSILON</code>. See FP Bit Twiddling in The GNU C Library Reference Manual.</p> <p>It is important to know that the machine epsilon is not symmetric about all numbers. At the boundaries where normalization changes the exponent, the epsilon below <code>x</code> is smaller than that just above <code>x</code> by a factor <code>1 / base</code>. For example, <code>macheps (1.0)</code> returns <code>+0x1p-52</code>, whereas <code>macheps (-1.0)</code> returns <code>+0x1p-53</code>. Some authors distinguish those cases by calling them the positive and negative, or big and small, machine epsilons. You can produce their values like this:</p> <pre><code>eps_neg = 1.0 - nextafter (1.0, -1.0);\neps_pos = nextafter (1.0, +2.0) - 1.0;\n</code></pre> <p>If <code>x</code> is a variable, such that you do not know its value at compile time, then you can substitute literal <code>y</code> values with either <code>-inf()</code> or <code>+inf()</code>, like this:</p> <pre><code>eps_neg = x - nextafter (x, -inf ());\neps_pos = nextafter (x, +inf() - x);\n</code></pre> <p>In such cases, if <code>x</code> is Infinity, then the <code>nextafter</code> functions return <code>y</code> if <code>x</code> equals <code>y</code>. Our two assignments then produce <code>+0x1.fffffffffffffp+1023</code> (that is a hexadecimal floating point constant and its value is around 1.798e+308; see Floating Constants) for <code>eps_neg</code>, and Infinity for <code>eps_pos</code>. Thus, the call <code>nextafter (INFINITY, -INFINITY)</code> can be used to find the largest representable finite number, and with the call <code>nextafter (0.0, 1.0)</code>, the smallest representable number (here, <code>0x1p-1074</code> (about 4.491e-324), a number that we saw before as the output from <code>macheps (0.0)</code>).</p> <p></p> <p>Next: Round-Trip Base Conversion, Previous: Machine Epsilon, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2819-complex-arithmetic","title":"28.19 Complex Arithmetic","text":"<p>We\u2019ve already looked at defining and referring to complex numbers (see Complex Data Types). What is important to discuss here are some issues that are unlikely to be obvious to programmers without extensive experience in both numerical computing, and in complex arithmetic in mathematics.</p> <p>The first important point is that, unlike real arithmetic, in complex arithmetic, the danger of significance loss is pervasive, and affects every one of the basic operations, and almost all of the math-library functions. To understand why, recall the rules for complex multiplication and division:</p> <pre><code>a = u + I*v              /* First operand. */\nb = x + I*y              /* Second operand. */\n\nprod = a * b\n     = (u + I*v) * (x + I*y)\n     = (u * x - v * y) + I*(v * x + u * y)\n\nquo  = a / b\n     = (u + I*v) / (x + I*y)\n     = [(u + I*v) * (x - I*y)] / [(x + I*y) * (x - I*y)]\n     = [(u * x + v * y) + I*(v * x - u * y)] / (x**2 + y**2)\n</code></pre> <p>There are four critical observations about those formulas:</p> <ul> <li>the multiplications on the right-hand side introduce the possibility     of premature underflow or overflow;</li> <li>the products must be accurate to twice working precision;</li> <li>there is always one subtraction on the right-hand sides that is     subject to catastrophic significance loss; and</li> <li>complex multiplication has up to six rounding errors, and complex     division has ten rounding errors.</li> </ul> <p></p> <p>Another point that needs careful study is the fact that many functions in complex arithmetic have branch cuts. You can view a function with a complex argument, <code>f (z)</code>, as <code>f (x + I*y)</code>, and thus, it defines a relation between a point <code>(x, y)</code> on the complex plane with an elevation value on a surface. A branch cut looks like a tear in that surface, so approaching the cut from one side produces a particular value, and from the other side, a quite different value. Great care is needed to handle branch cuts properly, and even small numerical errors can push a result from one side to the other, radically changing the returned value. As we reported earlier, correct handling of the sign of zero is critically important for computing near branch cuts.</p> <p>The best advice that we can give to programmers who need complex arithmetic is to always use the highest precision available, and then to carefully check the results of test calculations to gauge the likely accuracy of the computed results. It is easy to supply test values of real and imaginary parts where all five basic operations in complex arithmetic, and almost all of the complex math functions, lose all significance, and fail to produce even a single correct digit.</p> <p>Even though complex arithmetic makes some programming tasks easier, it may be numerically preferable to rework the algorithm so that it can be carried out in real arithmetic. That is commonly possible in matrix algebra.</p> <p>GNU C can perform code optimization on complex number multiplication and division if certain boundary checks will not be needed. The command-line option <code>-fcx-limited-range</code> tells the compiler that a range reduction step is not needed when performing complex division, and that there is no need to check if a complex multiplication or division results in the value <code>Nan + I*NaN</code>. By default these checks are enabled. You can explicitly enable them with the <code>-fno-cx-limited-range</code> option.</p> <p></p> <p>Next: Further Reading, Previous: Complex Arithmetic, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2820-round-trip-base-conversion","title":"28.20 Round-Trip Base Conversion","text":"<p>Most numeric programs involve converting between base-2 floating-point numbers, as represented by the computer, and base-10 floating-point numbers, as entered and handled by the programmer. What might not be obvious is the number of base-2 bits vs. base-10 digits required for each representation. Consider the following tables showing the number of decimal digits representable in a given number of bits, and vice versa:</p> binary in 24 53 64 113 237 decimal out 9 17 21 36 73 decimal in 7 16 34 70 binary out 25 55 114 234 <p>We can compute the table numbers with these two functions:</p> <pre><code>int\nmatula(int nbits)\n{   /* Return output decimal digits needed for nbits-bits input. */\n    return ((int)ceil((double)nbits / log2(10.0) + 1.0));\n}\n\nint\ngoldberg(int ndec)\n{   /* Return output bits needed for ndec-digits input. */\n    return ((int)ceil((double)ndec / log10(2.0) + 1.0));\n}\n</code></pre> <p>One significant observation from those numbers is that we cannot achieve correct round-trip conversion between the decimal and binary formats in the same storage size! For example, we need 25 bits to represent a 7-digit value from the 32-bit decimal format, but the binary format only has 24 available. Similar observations hold for each of the other conversion pairs.</p> <p>The general input/output base-conversion problem is astonishingly complicated, and solutions were not generally known until the publication of two papers in 1990 that are listed later near the end of this chapter. For the 128-bit formats, the worst case needs more than 11,500 decimal digits of precision to guarantee correct rounding in a binary-to-decimal conversion!</p> <p>For further details see the references for Bennett Goldberg and David Matula.</p> <p></p> <p>Previous: Round-Trip Base Conversion, Up: Floating Point in Depth \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#2821-further-reading","title":"28.21 Further Reading","text":"<p>The subject of floating-point arithmetic is much more complex than many programmers seem to think, and few books on programming languages spend much time in that area. In this chapter, we have tried to expose the reader to some of the key ideas, and to warn of easily overlooked pitfalls that can soon lead to nonsensical results. There are a few good references that we recommend for further reading, and for finding other important material about computer arithmetic:</p> <p>We include URLs for these references when we were given them, when they are morally legitimate to recommend; we have omitted the URLs that are paywalled or that require running nonfree JavaScript code in order to function. We hope you can find morally legitimate sites where you can access these works.</p> <ul> <li>Paul H. Abbott and 15 others, Architecture and software support in     IBM S/390 Parallel Enterprise Servers for IEEE Floating-Point     arithmetic, IBM Journal of Research and Development 43(5/6)     723\u2013760 (1999), This article gives a good description of IBM\u2019s     algorithm for exact decimal-to-binary conversion, complementing     earlier ones by Clinger and others.</li> <li>Nelson H. F. Beebe, The Mathematical-Function Computation Handbook:     Programming Using the MathCW Portable Software Library, Springer     (2017). This book describes portable implementations of a large     superset of the mathematical functions available in many programming     languages, extended to a future 256-bit format (70 decimal digits),     for both binary and decimal floating point. It includes a     substantial portion of the functions described in the famous NIST     Handbook of Mathematical Functions, Cambridge (2018), ISBN     0-521-19225-0. See https://www.math.utah.edu/pub/mathcw/ for     compilers and libraries.</li> <li>William D. Clinger, How to Read Floating Point Numbers Accurately,     ACM SIGPLAN Notices 25(6) 92\u2013101 (June 1990),     https://doi.org/10.1145/93548.93557. See also the papers by Steele     &amp; White.</li> <li>I. Bennett Goldberg, 27 Bits Are Not Enough For 8-Digit Accuracy,     Communications of the ACM 10(2) 105\u2013106 (February 1967),     https://doi.acm.org/10.1145/363067.363112. This paper, and its     companions by David Matula, address the base-conversion problem, and     show that the naive formulas are wrong by one or two digits.</li> <li>David Goldberg, What Every Computer Scientist Should Know About     Floating-Point Arithmetic, ACM Computing Surveys 23(1) 5\u201358     (March 1991), corrigendum 23(3) 413 (September 1991),     https://doi.org/10.1145/103162.103163. This paper has been widely     distributed, and reissued in vendor programming-language     documentation. It is well worth reading, and then rereading from     time to time.</li> <li>Norbert Juffa and Nelson H. F. Beebe, A Bibliography of Publications     on Floating-Point Arithmetic,     https://www.math.utah.edu/pub/tex/bib/fparith.bib. This is the     largest known bibliography of publications about floating-point, and     also integer, arithmetic. It is actively maintained, and in mid     2019, contains more than 6400 references to original research     papers, reports, theses, books, and Web sites on the subject matter.     It can be used to locate the latest research in the field, and the     historical coverage dates back to a 1726 paper on signed-digit     arithmetic, and an 1837 paper by Charles Babbage, the intellectual     father of mechanical computers. The entries for the Abbott, Clinger,     and Steele &amp; White papers cited earlier contain pointers to several     other important related papers on the base-conversion problem.</li> <li>William Kahan, Branch Cuts for Complex Elementary Functions, or Much     Ado About Nothing\u2019s Sign Bit, (1987),     https://people.freebsd.org/~das/kahan86branch.pdf. This Web     document about the fine points of complex arithmetic also appears in     the volume edited by A. Iserles and M. J. D. Powell, The State of     the Art in Numerical Analysis: Proceedings of the Joint IMA/SIAM     Conference on the State of the Art in Numerical Analysis held at the     University of Birmingham, 14\u201318 April 1986, Oxford University Press     (1987), ISBN 0-19-853614-3 (xiv + 719 pages). Its author is the     famous chief architect of the IEEE 754 arithmetic system, and one of     the world\u2019s greatest experts in the field of floating-point     arithmetic. An entire generation of his students at the University     of California, Berkeley, have gone on to careers in academic and     industry, spreading the knowledge of how to do floating-point     arithmetic right.</li> <li>Donald E. Knuth, A Simple Program Whose Proof Isn\u2019t, in Beauty is     our business: a birthday salute to Edsger W. Dijkstra, W. H. J.     Feijen, A. J. M. van Gasteren, D. Gries, and J. Misra (eds.),     Springer (1990), ISBN 1-4612-8792-8, This book chapter supplies a     correctness proof of the decimal to binary, and binary to decimal,     conversions in fixed-point arithmetic in the TeX typesetting system.     The proof evaded its author for a dozen years.</li> <li>David W. Matula, In-and-out conversions, Communications of the ACM     11(1) 57\u201350 (January 1968),     https://doi.org/10.1145/362851.362887.</li> <li>David W. Matula, The Base Conversion Theorem, Proceedings of the     American Mathematical Society 19(3) 716\u2013723 (June 1968). See     also other papers here by this author, and by I. Bennett Goldberg.</li> <li>David W. Matula, A Formalization of Floating-Point Numeric Base     Conversion, IEEE Transactions on Computers C-19(8) 681\u2013692     (August 1970),</li> <li>Jean-Michel Muller and eight others, Handbook of Floating-Point     Arithmetic, Birkh\u00e4user-Boston (2010), ISBN 0-8176-4704-X (xxiii +     572 pages). This is a comprehensive treatise from a French team who     are among the world\u2019s greatest experts in floating-point arithmetic,     and among the most prolific writers of research papers in that     field. They have much to teach, and their book deserves a place on     the shelves of every serious numerical programmer.</li> <li>Jean-Michel Muller and eight others, Handbook of Floating-Point     Arithmetic, Second edition, Birkh\u00e4user-Boston (2018), ISBN     3-319-76525-6 (xxv + 627 pages). This is a new edition of the     preceding entry.</li> <li>Michael Overton, Numerical Computing with IEEE Floating Point     Arithmetic, Including One Theorem, One Rule of Thumb, and One     Hundred and One Exercises, SIAM (2001), ISBN 0-89871-482-6 (xiv +     104 pages), This is a small volume that can be covered in a few     hours.</li> <li>Guy L. Steele Jr. and Jon L. White, How to Print Floating-Point     Numbers Accurately, ACM SIGPLAN Notices 25(6) 112\u2013126 (June     1990), https://doi.org/10.1145/93548.93559. See also the papers by     Clinger.</li> <li>Guy L. Steele Jr. and Jon L. White, Retrospective: How to Print     Floating-Point Numbers Accurately, ACM SIGPLAN Notices 39(4)     372\u2013389 (April 2004), Reprint of 1990 paper, with additional     commentary.</li> <li>Pat H. Sterbenz, Floating Point Computation, Prentice-Hall (1974),     ISBN 0-13-322495-3 (xiv + 316 pages). This often-cited book provides     solid coverage of what floating-point arithmetic was like before     the introduction of IEEE 754 arithmetic.</li> </ul> <p></p> <p>Next: Directing Compilation, Previous: Floating Point in Depth, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#29-compilation","title":"29 Compilation","text":"<p>Early in the manual we explained how to compile a simple C program that consists of a single source file (see Compile Example). However, we handle only short programs that way. A typical C program consists of many source files, each of which is usually a separate compilation module\u2014meaning that it has to be compiled separately. (The source files that are not separate compilation modules are those that are used via <code>#include</code>; see Header Files.)</p> <p>To compile a multi-module program, you compile each of the program\u2019s compilation modules, making an object file for that module. The last step is to link the many object files together into a single executable for the whole program.</p> <p>The full details of how to compile C programs (and other programs) with GCC are documented in xxxx. Here we give only a simple introduction.</p> <p>These commands compile two compilation modules, <code>foo.c</code> and <code>bar.c</code>, running the compiler for each module:</p> <pre><code>gcc -c -O -g foo.c\ngcc -c -O -g bar.c\n</code></pre> <p>In these commands, <code>-g</code> says to generate debugging information, <code>-O</code> says to do some optimization, and <code>-c</code> says to put the compiled code for that module into a corresponding object file and go no further. The object file for <code>foo.c</code> is automatically called <code>foo.o</code>, and so on.</p> <p>If you wish, you can specify the additional compilation options. For instance, <code>-Wformat -Wparenthesis -Wstrict-prototypes</code> request additional warnings.</p> <p></p> <p>After you compile all the program\u2019s modules, you link the object files into a combined executable, like this:</p> <pre><code>gcc -o foo foo.o bar.o\n</code></pre> <p>In this command, <code>-o foo</code> species the file name for the executable file, and the other arguments are the object files to link. Always specify the executable file name in a command that generates one.</p> <p>One reason to divide a large program into multiple compilation modules is to control how each module can access the internals of the others. When a module declares a function or variable <code>extern</code>, other modules can access it. The other functions and variables defined in a module can\u2019t be accessed from outside that module.</p> <p>The other reason for using multiple modules is so that changing one source file does not require recompiling all of them in order to try the modified program. It is sufficient to recompile the source file that you changed, then link them all again. Dividing a large program into many substantial modules in this way typically makes recompilation much faster.</p> <p>Normally we don\u2019t run any of these commands directly. Instead we write a set of make rules for the program, then use the <code>make</code> program to recompile only the source files that need to be recompiled, by following those rules. See The GNU Make Manual in The GNU Make Manual.</p> <p></p> <p>Next: Type Alignment, Previous: Compilation, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#30-directing-compilation","title":"30 Directing Compilation","text":"<p>This chapter describes C constructs that don\u2019t alter the program\u2019s meaning as such, but rather direct the compiler how to treat some aspects of the program.</p> \u2022 Pragmas Controlling compilation of some constructs. \u2022 Static Assertions Compile-time tests for conditions. <p></p> <p>Next: Static Assertions, Up: Directing Compilation \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#301-pragmas","title":"30.1 Pragmas","text":"<p>A pragma is an annotation in a program that gives direction to the compiler.</p> \u2022 Pragma Basics Pragma syntax and usage. \u2022 Severity Pragmas Settings for compile-time pragma output. \u2022 Optimization Pragmas Controlling optimizations. <p></p> <p>Next: Severity Pragmas, Up: Pragmas \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#3011-pragma-basics","title":"30.1.1 Pragma Basics","text":"<p>C defines two syntactical forms for pragmas, the line form and the token form. You can write any pragma in either form, with the same meaning.</p> <p>The line form is a line in the source code, like this:</p> <pre><code>#pragma line\n</code></pre> <p>The line pragma has no effect on the parsing of the lines around it. This form has the drawback that it can\u2019t be generated by a macro expansion.</p> <p>The token form is a series of tokens; it can appear anywhere in the program between the other tokens.</p> <pre><code>_Pragma (stringconstant)\n</code></pre> <p>The pragma has no effect on the syntax of the tokens that surround it; thus, here\u2019s a pragma in the middle of an <code>if</code> statement:</p> <pre><code>if _Pragma (\"hello\") (x &gt; 1)\n</code></pre> <p>However, that\u2019s an unclear thing to do; for the sake of understandability, it is better to put a pragma on a line by itself and not embedded in the middle of another construct.</p> <p>Both forms of pragma have a textual argument. In a line pragma, the text is the rest of the line. The textual argument to <code>_Pragma</code> uses the same syntax as a C string constant: surround the text with two \u2018<code>\"</code>\u2019 characters, and add a backslash before each \u2018<code>\"</code>\u2019 or \u2018<code>\\</code>\u2019 character in it.</p> <p>With either syntax, the textual argument specifies what to do. It begins with one or several words that specify the operation. If the compiler does not recognize them, it ignores the pragma.</p> <p>Here are the pragma operations supported in GNU C.</p> <p><code>#pragma GCC dependency \"``file``\" [``message``]</code> <code>_Pragma (\"GCC dependency \\\"``file``\\\" [``message``]\")</code> Declares that the current source file depends on <code>file</code>, so GNU C compares the file times and gives a warning if <code>file</code> is newer than the current source file.</p> <p>This directive searches for <code>file</code> the way <code>#include</code> searches for a non-system header file.</p> <p>If <code>message</code> is given, the warning message includes that text.</p> <p>Examples:</p> <pre><code>#pragma GCC dependency \"parse.y\"\n_pragma (\"GCC dependency \\\"/usr/include/time.h\\\" \\\nrerun fixincludes\")\n</code></pre> <p><code>#pragma GCC poison ``identifiers</code> <code>_Pragma (\"GCC poison ``identifiers``\")</code> Poisons the identifiers listed in <code>identifiers</code>.</p> <p>This is useful to make sure all mention of <code>identifiers</code> has been deleted from the program and that no reference to them creeps back in. If any of those identifiers appears anywhere in the source after the directive, it causes a compilation error. For example,</p> <pre><code>#pragma GCC poison printf sprintf fprintf\nsprintf(some_string, \"hello\");\n</code></pre> <p>generates an error.</p> <p>If a poisoned identifier appears as part of the expansion of a macro that was defined before the identifier was poisoned, it will not cause an error. Thus, system headers that define macros that use the identifier will not cause errors.</p> <p>For example,</p> <pre><code>#define strrchr rindex\n_Pragma (\"GCC poison rindex\")\nstrrchr(some_string, 'h');\n</code></pre> <p>does not cause a compilation error.</p> <p><code>#pragma GCC system_header</code> <code>_Pragma (\"GCC system_header\")</code> Specify treating the rest of the current source file as if it came from a system header file. See System Headers in Using the GNU Compiler Collection.</p> <p><code>#pragma GCC warning ``message</code> <code>_Pragma (\"GCC warning ``message``\")</code> Equivalent to <code>#warning</code>. Its advantage is that the <code>_Pragma</code> form can be included in a macro definition.</p> <p><code>#pragma GCC error ``message</code> <code>_Pragma (\"GCC error ``message``\")</code> Equivalent to <code>#error</code>. Its advantage is that the <code>_Pragma</code> form can be included in a macro definition.</p> <p><code>#pragma GCC message ``message</code> <code>_Pragma (\"GCC message ``message``\")</code> Similar to \u2018<code>GCC warning</code>\u2019 and \u2018<code>GCC error</code>\u2019, this simply prints an informational message, and could be used to include additional warning or error text without triggering more warnings or errors. (Note that unlike \u2018<code>warning</code>\u2019 and \u2018<code>error</code>\u2019, \u2018<code>message</code>\u2019 does not include \u2018<code>GCC</code>\u2019 as part of the pragma.)</p> <p></p> <p>Next: Optimization Pragmas, Previous: Pragma Basics, Up: Pragmas \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#3012-severity-pragmas","title":"30.1.2 Severity Pragmas","text":"<p>These pragmas control the severity of classes of diagnostics. You can specify the class of diagnostic with the GCC option that causes those diagnostics to be generated.</p> <p><code>#pragma GCC diagnostic error ``option</code> <code>_Pragma (\"GCC diagnostic error ``option``\")</code> For code following this pragma, treat diagnostics of the variety specified by <code>option</code> as errors. For example:</p> <pre><code>_Pragma (\"GCC diagnostic error -Wformat\")\n</code></pre> <p>specifies to treat diagnostics enabled by the <code>-Wformat</code> option as errors rather than warnings.</p> <p><code>#pragma GCC diagnostic warning ``option</code> <code>_Pragma (\"GCC diagnostic warning ``option``\")</code> For code following this pragma, treat diagnostics of the variety specified by <code>option</code> as warnings. This overrides the <code>-Werror</code> option which says to treat warnings as errors.</p> <p><code>#pragma GCC diagnostic ignore ``option</code> <code>_Pragma (\"GCC diagnostic ignore ``option``\")</code> For code following this pragma, refrain from reporting any diagnostics of the variety specified by <code>option</code>.</p> <p><code>#pragma GCC diagnostic push</code> <code>_Pragma (\"GCC diagnostic push\")</code> <code>#pragma GCC diagnostic pop</code> <code>_Pragma (\"GCC diagnostic pop\")</code> These pragmas maintain a stack of states for severity settings. \u2018<code>GCC diagnostic push</code>\u2019 saves the current settings on the stack, and \u2018<code>GCC diagnostic pop</code>\u2019 pops the last stack item and restores the current settings from that.</p> <p>\u2018<code>GCC diagnostic pop</code>\u2019 when the severity setting stack is empty restores the settings to what they were at the start of compilation.</p> <p>Here is an example:</p> <pre><code>_Pragma (\"GCC diagnostic error -Wformat\")\n\n/* -Wformat messages treated as errors.  */\n\n_Pragma (\"GCC diagnostic push\")\n_Pragma (\"GCC diagnostic warning -Wformat\")\n\n/* -Wformat messages treated as warnings.  */\n\n_Pragma (\"GCC diagnostic push\")\n_Pragma (\"GCC diagnostic ignored -Wformat\")\n\n/* -Wformat messages suppressed.  */\n\n_Pragma (\"GCC diagnostic pop\")\n\n/* -Wformat messages treated as warnings again.  */\n\n_Pragma (\"GCC diagnostic pop\")\n\n/* -Wformat messages treated as errors again.  */\n\n/* This is an excess \u2018pop\u2019 that matches no \u2018push\u2019.  */\n_Pragma (\"GCC diagnostic pop\")\n\n/* -Wformat messages treated once again\n   as specified by the GCC command-line options.  */\n</code></pre> <p></p> <p>Previous: Severity Pragmas, Up: Pragmas \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#3013-optimization-pragmas","title":"30.1.3 Optimization Pragmas","text":"<p>These pragmas enable a particular optimization for specific function definitions. The settings take effect at the end of a function definition, so the clean place to use these pragmas is between function definitions.</p> <p><code>#pragma GCC optimize ``optimization</code> <code>_Pragma (\"GCC optimize ``optimization``\")</code> These pragmas enable the optimization <code>optimization</code> for the following functions. For example,</p> <pre><code>_Pragma (\"GCC optimize -fforward-propagate\")\n</code></pre> <p>says to apply the \u2018<code>forward-propagate</code>\u2019 optimization to all following function definitions. Specifying optimizations for individual functions, rather than for the entire program, is rare but can be useful for getting around a bug in the compiler.</p> <p>If <code>optimization</code> does not correspond to a defined optimization option, the pragma is erroneous. To turn off an optimization, use the corresponding \u2018<code>-fno-</code>\u2019 option, such as \u2018<code>-fno-forward-propagate</code>\u2019.</p> <p><code>#pragma GCC target ``optimizations</code> <code>_Pragma (\"GCC target ``optimizations``\")</code> The pragma \u2018<code>GCC target</code>\u2019 is similar to \u2018<code>GCC optimize</code>\u2019 but is used for platform-specific optimizations. Thus,</p> <pre><code>_Pragma (\"GCC target popcnt\")\n</code></pre> <p>activates the optimization \u2018<code>popcnt</code>\u2019 for all following function definitions. This optimization is supported on a few common targets but not on others.</p> <p><code>#pragma GCC push_options</code> <code>_Pragma (\"GCC push_options\")</code> The \u2018<code>push_options</code>\u2019 pragma saves on a stack the current settings specified with the \u2018<code>target</code>\u2019 and \u2018<code>optimize</code>\u2019 pragmas.</p> <p><code>#pragma GCC pop_options</code> <code>_Pragma (\"GCC pop_options\")</code> The \u2018<code>pop_options</code>\u2019 pragma pops saved settings from that stack.</p> <p>Here\u2019s an example of using this stack.</p> <pre><code>_Pragma (\"GCC push_options\")\n_Pragma (\"GCC optimize forward-propagate\")\n\n/* Functions to compile\n   with the forward-propagate optimization. */\n\n_Pragma (\"GCC pop_options\")\n/* Ends enablement of forward-propagate. */\n</code></pre> <p><code>#pragma GCC reset_options</code> <code>_Pragma (\"GCC reset_options\")</code> Clears all pragma-defined \u2018<code>target</code>\u2019 and \u2018<code>optimize</code>\u2019 optimization settings.</p> <p></p> <p>Previous: Pragmas, Up: Directing Compilation \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#302-static-assertions","title":"30.2 Static Assertions","text":"<p>You can add compiler-time tests for necessary conditions into your code using <code>_Static_assert</code>. This can be useful, for example, to check that the compilation target platform supports the type sizes that the code expects. For example,</p> <pre><code>_Static_assert ((sizeof (long int) &gt;= 8),\n    \"long int needs to be at least 8 bytes\");\n</code></pre> <p>reports a compile-time error if compiled on a system with long integers smaller than 8 bytes, with \u2018<code>long int needs to be at least 8 bytes</code>\u2019 as the error message.</p> <p>Since calls <code>_Static_assert</code> are processed at compile time, the expression must be computable at compile time and the error message must be a literal string. The expression can refer to the sizes of variables, but can\u2019t refer to their values. For example, the following static assertion is invalid for two reasons:</p> <pre><code>char *error_message\n  = \"long int needs to be at least 8 bytes\";\nint size_of_long_int = sizeof (long int);\n\n_Static_assert (size_of_long_int == 8, error_message);\n</code></pre> <p>The expression <code>size_of_long_int == 8</code> isn\u2019t computable at compile time, and the error message isn\u2019t a literal string.</p> <p>You can, though, use preprocessor definition values with <code>_Static_assert</code>:</p> <pre><code>#define LONG_INT_ERROR_MESSAGE \"long int needs to be \\\nat least 8 bytes\"\n\n_Static_assert ((sizeof (long int) == 8),\n  LONG_INT_ERROR_MESSAGE);\n</code></pre> <p>Static assertions are permitted wherever a statement or declaration is permitted, including at top level in the file, and also inside the definition of a type.</p> <pre><code>union y\n{\n  int i;\n  int *ptr;\n  _Static_assert (sizeof (int *) == sizeof (int),\n          \"Pointer and int not same size\");\n};\n</code></pre> <p></p> <p>Next: Aliasing, Previous: Directing Compilation, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#appendix-a-type-alignment","title":"Appendix A Type Alignment","text":"<p>Code for device drivers and other communication with low-level hardware sometimes needs to be concerned with the alignment of data objects in memory.</p> <p>Each data type has a required alignment, always a power of 2, that says at which memory addresses an object of that type can validly start. A valid address for the type must be a multiple of its alignment. If a type\u2019s alignment is 1, that means it can validly start at any address. If a type\u2019s alignment is 2, that means it can only start at an even address. If a type\u2019s alignment is 4, that means it can only start at an address that is a multiple of 4.</p> <p>The alignment of a type (except <code>char</code>) can vary depending on the kind of computer in use. To refer to the alignment of a type in a C program, use <code>_Alignof</code>, whose syntax parallels that of <code>sizeof</code>. Like <code>sizeof</code>, <code>_Alignof</code> is a compile-time operation, and it doesn\u2019t compute the value of the expression used as its argument.</p> <p>Nominally, each integer and floating-point type has an alignment equal to the largest power of 2 that divides its size. Thus, <code>int</code> with size 4 has a nominal alignment of 4, and <code>long long int</code> with size 8 has a nominal alignment of 8.</p> <p>However, each kind of computer generally has a maximum alignment, and no type needs more alignment than that. If the computer\u2019s maximum alignment is 4 (which is common), then no type\u2019s alignment is more than 4.</p> <p>The size of any type is always a multiple of its alignment; that way, in an array whose elements have that type, all the elements are properly aligned if the first one is.</p> <p>These rules apply to all real computers today, but some embedded controllers have odd exceptions. We don\u2019t have references to cite for them.</p> <p>Ordinary C code guarantees that every object of a given type is in fact aligned as that type requires.</p> <p>If the operand of <code>_Alignof</code> is a structure field, the value is the alignment it requires. It may have a greater alignment by coincidence, due to the other fields, but <code>_Alignof</code> is not concerned about that. See Structures.</p> <p>Older versions of GNU C used the keyword <code>__alignof__</code> for this, but now that the feature has been standardized, it is better to use the standard keyword <code>_Alignof</code>.</p> <p> </p> <p>You can explicitly specify an alignment requirement for a particular variable or structure field by adding <code>_Alignas (``alignment``)</code> to the declaration, where <code>alignment</code> is a power of 2 or a type name. For instance:</p> <pre><code>char _Alignas (8) x;\n</code></pre> <p>or</p> <pre><code>char _Alignas (double) x;\n</code></pre> <p>specifies that <code>x</code> must start on an address that is a multiple of 8. However, if <code>alignment</code> exceeds the maximum alignment for the machine, that maximum is how much alignment <code>x</code> will get.</p> <p>The older GNU C syntax for this feature looked like <code>__attribute__ ((__aligned__ (``alignment``)))</code> to the declaration, and was added after the variable. For instance:</p> <pre><code>char x __attribute__ ((__aligned__ 8));\n</code></pre> <p>See Attributes.</p> <p></p> <p>Next: Digraphs, Previous: Type Alignment, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#appendix-b-aliasing","title":"Appendix B Aliasing","text":"<p>We have already presented examples of casting a <code>void *</code> pointer to another pointer type, and casting another pointer type to <code>void *</code>.</p> <p>One common kind of pointer cast is guaranteed safe: casting the value returned by <code>malloc</code> and related functions (see Dynamic Memory Allocation). It is safe because these functions do not save the pointer anywhere else; the only way the program will access the newly allocated memory is via the pointer just returned.</p> <p>In fact, C allows casting any pointer type to any other pointer type. Using this to access the same place in memory using two different data types is called aliasing.</p> <p>Aliasing is necessary in some programs that do sophisticated memory management, such as GNU Emacs, but most C programs don\u2019t need to do aliasing. When it isn\u2019t needed, stay away from it! To do aliasing correctly requires following the rules stated below. Otherwise, the aliasing may result in malfunctions when the program runs.</p> <p>The rest of this appendix explains the pitfalls and rules of aliasing.</p> \u2022 Aliasing Alignment Memory alignment considerations for casting between pointer types. \u2022 Aliasing Length Type size considerations for casting between pointer types. \u2022 Aliasing Type Rules Even when type alignment and size matches, aliasing can still have surprising results. <pre><code></code></pre> <p></p> <p>Next: Aliasing Length, Up: Aliasing \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#b1-aliasing-and-alignment","title":"B.1 Aliasing and Alignment","text":"<p>In order for a type-converted pointer to be valid, it must have the alignment that the new pointer type requires. For instance, on most computers, <code>int</code> has alignment 4; the address of an <code>int</code> must be a multiple of 4. However, <code>char</code> has alignment 1, so the address of a <code>char</code> is usually not a multiple of 4. Taking the address of such a <code>char</code> and casting it to <code>int *</code> probably results in an invalid pointer. Trying to dereference it may cause a <code>SIGBUS</code> signal, depending on the platform in use (see Signals).</p> <pre><code>foo ()\n{\n  char i[4];\n  int *p = (int *) &amp;i[1]; /* Misaligned pointer! */\n  return *p;              /* Crash! */\n}\n</code></pre> <p>This requirement is never a problem when casting the return value of <code>malloc</code> because that function always returns a pointer with as much alignment as any type can require.</p> <p></p> <p>Next: Aliasing Type Rules, Previous: Aliasing Alignment, Up: Aliasing \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#b2-aliasing-and-length","title":"B.2 Aliasing and Length","text":"<p>When converting a pointer to a different pointer type, make sure the object it really points to is at least as long as the target of the converted pointer. For instance, suppose <code>p</code> has type <code>int *</code> and it\u2019s cast as follows:</p> <pre><code>int *p;\n\nstruct\n  {\n    double d, e, f;\n  } foo;\n\nstruct foo *q = (struct foo *)p;\n\nq-&gt;f = 5.14159;\n</code></pre> <p>the value <code>q-&gt;f</code> will run past the end of the <code>int</code> that <code>p</code> points to. If <code>p</code> was initialized to the start of an array of type <code>int[6]</code>, the object is long enough for three <code>double</code>s. But if <code>p</code> points to something shorter, <code>q-&gt;f</code> will run on beyond the end of that, overlaying some other data. Storing that will garble that other data. Or it could extend past the end of memory space and cause a <code>SIGSEGV</code> signal (see Signals).</p> <p></p> <p>Previous: Aliasing Length, Up: Aliasing \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#b3-type-rules-for-aliasing","title":"B.3 Type Rules for Aliasing","text":"<p>C code that converts a pointer to a different pointer type can use the pointers to access the same memory locations with two different data types. If the same address is accessed with different types in a single control thread, optimization can make the code do surprising things (in effect, make it malfunction).</p> <p>Here\u2019s a concrete example where aliasing that can change the code\u2019s behavior when it is optimized. We assume that <code>float</code> is 4 bytes long, like <code>int</code>, and so is every pointer. Thus, the structures <code>struct a</code> and <code>struct b</code> are both 8 bytes.</p> <pre><code>#include &lt;stdio.h&gt;\nstruct a { int size; char *data; };\nstruct b { float size; char *data; };\n\nvoid sub (struct a *p, struct b *q)\n{\n\u00a0 int x;\n\u00a0 p-&gt;size = 0;\n\u00a0 q-&gt;size = 1;\n\u00a0 x = p-&gt;size;\n\u00a0 printf(\"x\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0=%d\\n\", x);\n\u00a0 printf(\"p-&gt;size =%d\\n\", (int)p-&gt;size);\n\u00a0 printf(\"q-&gt;size =%d\\n\", (int)q-&gt;size);\n}\n\nint main(void)\n{\n\u00a0 struct a foo;\n\u00a0 struct a *p = &amp;foo;\n\u00a0 struct b *q = (struct b *) &amp;foo;\n\n\u00a0 sub (p, q);\n}\n</code></pre> <p>This code works as intended when compiled without optimization. All the operations are carried out sequentially as written. The code sets <code>x</code> to <code>p-&gt;size</code>, but what it actually gets is the bits of the floating point number 1, as type <code>int</code>.</p> <p>However, when optimizing, the compiler is allowed to assume (mistakenly, here) that <code>q</code> does not point to the same storage as <code>p</code>, because their data types are not allowed to alias.</p> <p>From this assumption, the compiler can deduce (falsely, here) that the assignment into <code>q-&gt;size</code> has no effect on the value of <code>p-&gt;size</code>, which must therefore still be 0. Thus, <code>x</code> will be set to 0.</p> <p>GNU C, following the C standard, defines this optimization as legitimate. Code that misbehaves when optimized following these rules is, by definition, incorrect C code.</p> <p>The rules for storage aliasing in C are based on the two data types: the type of the object, and the type it is accessed through. The rules permit accessing part of a storage object of type <code>t</code> using only these types:</p> <ul> <li><code>t</code>.</li> <li>A type compatible with <code>t</code>. See Compatible     Types.</li> <li>A signed or unsigned version of one of the above.</li> <li>A qualified version of one of the above. See Type     Qualifiers.</li> <li>An array, structure (see Structures), or union type     (<code>Unions</code>) that contains one of the above, either directly as a     field or through multiple levels of fields. If <code>t</code> is <code>double</code>, this     would include     <code>struct s { union { double d[2]; int i[4]; } u; int i; };</code> because     there\u2019s a <code>double</code> inside it somewhere.</li> <li>A character type.</li> </ul> <p>What do these rules say about the example in this subsection?</p> <p>For <code>foo.size</code> (equivalently, <code>a-&gt;size</code>), <code>t</code> is <code>int</code>. The type <code>float</code> is not allowed as an aliasing type by those rules, so <code>b-&gt;size</code> is not supposed to alias with elements of <code>j</code>. Based on that assumption, GNU C makes a permitted optimization that was not, in this case, consistent with what the programmer intended the program to do.</p> <p>Whether GCC actually performs type-based aliasing analysis depends on the details of the code. GCC has other ways to determine (in some cases) whether objects alias, and if it gets a reliable answer that way, it won\u2019t fall back on type-based heuristics.</p> <p>The importance of knowing the type-based aliasing rules is not so as to ensure that the optimization is done where it would be safe, but so as to ensure it is not done in a way that would break the program. You can turn off type-based aliasing analysis by giving GCC the option <code>-fno-strict-aliasing</code>.</p> <p></p> <p>Next: Attributes, Previous: Aliasing, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#appendix-c-digraphs","title":"Appendix C Digraphs","text":"<p>C accepts aliases for certain characters. Apparently in the 1990s some computer systems had trouble inputting these characters, or trouble displaying them. These digraphs almost never appear in C programs nowadays, but we mention them for completeness.</p> <p>\u2018<code>&lt;:</code>\u2019 An alias for \u2018<code>[</code>\u2019.</p> <p>\u2018<code>:&gt;</code>\u2019 An alias for \u2018<code>]</code>\u2019.</p> <p>\u2018<code>&lt;%</code>\u2019 An alias for \u2018<code>{</code>\u2019.</p> <p>\u2018<code>%&gt;</code>\u2019 An alias for \u2018<code>}</code>\u2019.</p> <p>\u2018<code>%:</code>\u2019 An alias for \u2018<code>#</code>\u2019, used for preprocessing directives (see Directives) and macros (see Macros).</p> <p></p> <p>Next: Signals, Previous: Digraphs, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#appendix-d-attributes-in-declarations","title":"Appendix D Attributes in Declarations","text":"<p>You can specify certain additional requirements in a declaration, to get fine-grained control over code generation, and helpful informational messages during compilation. We use a few attributes in code examples throughout this manual, including</p> <p><code>aligned</code> The <code>aligned</code> attribute specifies a minimum alignment for a variable or structure field, measured in bytes:</p> <pre><code>int foo __attribute__ ((aligned (8))) = 0;\n</code></pre> <p>This directs GNU C to allocate <code>foo</code> at an address that is a multiple of 8 bytes. However, you can\u2019t force an alignment bigger than the computer\u2019s maximum meaningful alignment.</p> <p><code>packed</code> The <code>packed</code> attribute specifies to compact the fields of a structure by not leaving gaps between fields. For example,</p> <pre><code>struct __attribute__ ((packed)) bar\n{\n  char a;\n  int b;\n};\n</code></pre> <p>allocates the integer field <code>b</code> at byte 1 in the structure, immediately after the character field <code>a</code>. The packed structure is just 5 bytes long (assuming <code>int</code> is 4 bytes) and its alignment is 1, that of <code>char</code>.</p> <p><code>deprecated</code> Applicable to both variables and functions, the <code>deprecated</code> attribute tells the compiler to issue a warning if the variable or function is ever used in the source file.</p> <pre><code>int old_foo __attribute__ ((deprecated));\n\nint old_quux () __attribute__ ((deprecated));\n</code></pre> <p><code>__noinline__</code> The <code>__noinline__</code> attribute, in a function\u2019s declaration or definition, specifies never to inline calls to that function. All calls to that function, in a compilation unit where it has this attribute, will be compiled to invoke the separately compiled function. See Inline Function Definitions.</p> <p><code>__noclone__</code> The <code>__noclone__</code> attribute, in a function\u2019s declaration or definition, specifies never to clone that function. Thus, there will be only one compiled version of the function. See Label Value Caveats, for more information about cloning.</p> <p><code>always_inline</code> The <code>always_inline</code> attribute, in a function\u2019s declaration or definition, specifies to inline all calls to that function (unless something about the function makes inlining impossible). This applies to all calls to that function in a compilation unit where it has this attribute. See Inline Function Definitions.</p> <p><code>gnu_inline</code> The <code>gnu_inline</code> attribute, in a function\u2019s declaration or definition, specifies to handle the <code>inline</code> keyword the way GNU C originally implemented it, many years before ISO C said anything about inlining. See Inline Function Definitions.</p> <p>For full documentation of attributes, see the GCC manual. See System Headers in Using the GNU Compiler Collection.</p> <p></p> <p>Next: GNU Free Documentation License, Previous: Attributes, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#appendix-e-signals","title":"Appendix E Signals","text":"<p>Some program operations bring about an error condition called a signal. These signals terminate the program, by default.</p> <p>There are various different kinds of signals, each with a name. We have seen several such error conditions through this manual:</p> <p><code>SIGSEGV</code> This signal is generated when a program tries to read or write outside the memory that is allocated for it, or to write memory that can only be read. The name is an abbreviation for \u201csegmentation violation\u201d.</p> <p><code>SIGFPE</code> This signal indicates a fatal arithmetic error. The name is an abbreviation for \u201cfloating-point exception\u201d, but covers all types of arithmetic errors, including division by zero and overflow.</p> <p><code>SIGBUS</code> This signal is generated when an invalid pointer is dereferenced, typically the result of dereferencing an uninitialized pointer. It is similar to <code>SIGSEGV</code>, except that <code>SIGSEGV</code> indicates invalid access to valid memory, while <code>SIGBUS</code> indicates an attempt to access an invalid address.</p> <p>These kinds of signal allow the program to specify a function as a signal handler. When a signal has a handler, it doesn\u2019t terminate the program; instead it calls the handler.</p> <p>There are many other kinds of signal; here we list only those that come from run-time errors in C operations. The rest have to do with the functioning of the operating system. The GNU C Library Reference Manual gives more explanation about signals (see The GNU C Library in The GNU C Library Reference Manual).</p> <p></p> <p>Next: GNU General Public License, Previous: Signals, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#appendix-f-gnu-free-documentation-license","title":"Appendix F GNU Free Documentation License","text":"<p>Version 1.3, 3 November 2008</p> <pre><code>Copyright \u00a9 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.\nhttp://fsf.org/\n\nEveryone is permitted to copy and distribute verbatim copies\nof this license document, but changing it is not allowed.\n</code></pre> <ol> <li> <p>PREAMBLE</p> <p>The purpose of this License is to make a manual, textbook, or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others.</p> <p>This License is a kind of \u201ccopyleft\u201d, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software.</p> <p>We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.</p> </li> <li> <p>APPLICABILITY AND DEFINITIONS</p> <p>This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The \u201cDocument\u201d, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as \u201cyou\u201d. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law.</p> <p>A \u201cModified Version\u201d of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language.</p> <p>A \u201cSecondary Section\u201d is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document\u2019s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them.</p> <p>The \u201cInvariant Sections\u201d are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none.</p> <p>The \u201cCover Texts\u201d are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.</p> <p>A \u201cTransparent\u201d copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not \u201cTransparent\u201d is called \u201cOpaque\u201d.</p> <p>Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only.</p> <p>The \u201cTitle Page\u201d means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, \u201cTitle Page\u201d means the text near the most prominent appearance of the work\u2019s title, preceding the beginning of the body of the text.</p> <p>The \u201cpublisher\u201d means any person or entity that distributes copies of the Document to the public.</p> <p>A section \u201cEntitled XYZ\u201d means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as \u201cAcknowledgements\u201d, \u201cDedications\u201d, \u201cEndorsements\u201d, or \u201cHistory\u201d.) To \u201cPreserve the Title\u201d of such a section when you modify the Document means that it remains a section \u201cEntitled XYZ\u201d according to this definition.</p> <p>The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.</p> </li> <li> <p>VERBATIM COPYING</p> <p>You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3.</p> <p>You may also lend copies, under the same conditions stated above, and you may publicly display copies.</p> </li> <li> <p>COPYING IN QUANTITY</p> <p>If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document\u2019s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects.</p> <p>If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages.</p> <p>If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.</p> <p>It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.</p> </li> <li> <p>MODIFICATIONS</p> <p>You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:</p> <ol> <li>Use in the Title Page (and on the covers, if any) a title     distinct from that of the Document, and from those of previous     versions (which should, if there were any, be listed in the     History section of the Document). You may use the same title as     a previous version if the original publisher of that version     gives permission.</li> <li>List on the Title Page, as authors, one or more persons or     entities responsible for authorship of the modifications in the     Modified Version, together with at least five of the principal     authors of the Document (all of its principal authors, if it has     fewer than five), unless they release you from this requirement.</li> <li>State on the Title page the name of the publisher of the     Modified Version, as the publisher.</li> <li>Preserve all the copyright notices of the Document.</li> <li>Add an appropriate copyright notice for your modifications     adjacent to the other copyright notices.</li> <li>Include, immediately after the copyright notices, a license     notice giving the public permission to use the Modified Version     under the terms of this License, in the form shown in the     Addendum below.</li> <li>Preserve in that license notice the full lists of Invariant     Sections and required Cover Texts given in the Document\u2019s     license notice.</li> <li>Include an unaltered copy of this License.</li> <li>Preserve the section Entitled \u201cHistory\u201d, Preserve its Title, and     add to it an item stating at least the title, year, new authors,     and publisher of the Modified Version as given on the Title     Page. If there is no section Entitled \u201cHistory\u201d in the Document,     create one stating the title, year, authors, and publisher of     the Document as given on its Title Page, then add an item     describing the Modified Version as stated in the previous     sentence.</li> <li>Preserve the network location, if any, given in the Document for     public access to a Transparent copy of the Document, and     likewise the network locations given in the Document for     previous versions it was based on. These may be placed in the     \u201cHistory\u201d section. You may omit a network location for a work     that was published at least four years before the Document     itself, or if the original publisher of the version it refers to     gives permission.</li> <li>For any section Entitled \u201cAcknowledgements\u201d or \u201cDedications\u201d,     Preserve the Title of the section, and preserve in the section     all the substance and tone of each of the contributor     acknowledgements and/or dedications given therein.</li> <li>Preserve all the Invariant Sections of the Document, unaltered     in their text and in their titles. Section numbers or the     equivalent are not considered part of the section titles.</li> <li>Delete any section Entitled \u201cEndorsements\u201d. Such a section may     not be included in the Modified Version.</li> <li>Do not retitle any existing section to be Entitled     \u201cEndorsements\u201d or to conflict in title with any Invariant     Section.</li> <li>Preserve any Warranty Disclaimers.</li> </ol> <p>If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version\u2019s license notice. These titles must be distinct from any other section titles.</p> <p>You may add a section Entitled \u201cEndorsements\u201d, provided it contains nothing but endorsements of your Modified Version by various parties\u2014for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.</p> <p>You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one.</p> <p>The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.</p> </li> <li> <p>COMBINING DOCUMENTS</p> <p>You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers.</p> <p>The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.</p> <p>In the combination, you must combine any sections Entitled \u201cHistory\u201d in the various original documents, forming one section Entitled \u201cHistory\u201d; likewise combine any sections Entitled \u201cAcknowledgements\u201d, and any sections Entitled \u201cDedications\u201d. You must delete all sections Entitled \u201cEndorsements.\u201d</p> </li> <li> <p>COLLECTIONS OF DOCUMENTS</p> <p>You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.</p> <p>You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.</p> </li> <li> <p>AGGREGATION WITH INDEPENDENT WORKS</p> <p>A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an \u201caggregate\u201d if the copyright resulting from the compilation is not used to limit the legal rights of the compilation\u2019s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document.</p> <p>If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document\u2019s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.</p> </li> <li> <p>TRANSLATION</p> <p>Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail.</p> <p>If a section in the Document is Entitled \u201cAcknowledgements\u201d, \u201cDedications\u201d, or \u201cHistory\u201d, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.</p> </li> <li> <p>TERMINATION</p> <p>You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License.</p> <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p> <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p> <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.</p> </li> <li> <p>FUTURE REVISIONS OF THIS LICENSE</p> <p>The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See http://www.gnu.org/copyleft/.</p> <p>Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License \u201cor any later version\u201d applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy\u2019s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.</p> </li> <li> <p>RELICENSING</p> <p>\u201cMassive Multiauthor Collaboration Site\u201d (or \u201cMMC Site\u201d) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A \u201cMassive Multiauthor Collaboration\u201d (or \u201cMMC\u201d) contained in the site means any set of copyrightable works thus published on the MMC site.</p> <p>\u201cCC-BY-SA\u201d means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization.</p> <p>\u201cIncorporate\u201d means to publish or republish a Document, in whole or in part, as part of another Document.</p> <p>An MMC is \u201celigible for relicensing\u201d if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008.</p> <p>The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.</p> </li> </ol> <p></p>"},{"location":"Electronics/GNUC/gnuc/#addendum-how-to-use-this-license-for-your-documents","title":"ADDENDUM: How to use this License for your documents","text":"<p>To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:</p> <pre><code>  Copyright (C)  year  your name.\n  Permission is granted to copy, distribute and/or modify this document\n  under the terms of the GNU Free Documentation License, Version 1.3\n  or any later version published by the Free Software Foundation;\n  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover\n  Texts.  A copy of the license is included in the section entitled ``GNU\n  Free Documentation License''.\n</code></pre> <p>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the \u201cwith\u2026Texts.\u201d line with this:</p> <pre><code>    with the Invariant Sections being list their titles, with\n    the Front-Cover Texts being list, and with the Back-Cover Texts\n    being list.\n</code></pre> <p>If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.</p> <p>If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.</p> <p></p> <p>Next: Symbol Index, Previous: GNU Free Documentation License, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#appendix-g-gnu-general-public-license","title":"Appendix G GNU General Public License","text":"<p>Version 3, 29 June 2007</p> <pre><code>Copyright \u00a9 2007 Free Software Foundation, Inc. https://fsf.org/\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n</code></pre> <p></p>"},{"location":"Electronics/GNUC/gnuc/#preamble","title":"Preamble","text":"<p>The GNU General Public License is a free, copyleft license for software and other kinds of works.</p> <p>The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program\u2014to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too.</p> <p>When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.</p> <p>To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.</p> <p>For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.</p> <p>Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.</p> <p>For the developers\u2019 and authors\u2019 protection, the GPL clearly explains that there is no warranty for this free software. For both users\u2019 and authors\u2019 sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.</p> <p>Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users\u2019 freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.</p> <p>Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free.</p> <p>The precise terms and conditions for copying, distribution and modification follow.</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#terms-and-conditions","title":"TERMS AND CONDITIONS","text":"<ol> <li> <p>Definitions.</p> <p>\u201cThis License\u201d refers to version 3 of the GNU General Public License.</p> <p>\u201cCopyright\u201d also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.</p> <p>\u201cThe Program\u201d refers to any copyrightable work licensed under this License. Each licensee is addressed as \u201cyou\u201d. \u201cLicensees\u201d and \u201crecipients\u201d may be individuals or organizations.</p> <p>To \u201cmodify\u201d a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \u201cmodified version\u201d of the earlier work or a work \u201cbased on\u201d the earlier work.</p> <p>A \u201ccovered work\u201d means either the unmodified Program or a work based on the Program.</p> <p>To \u201cpropagate\u201d a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.</p> <p>To \u201cconvey\u201d a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.</p> <p>An interactive user interface displays \u201cAppropriate Legal Notices\u201d to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.</p> </li> <li> <p>Source Code.</p> <p>The \u201csource code\u201d for a work means the preferred form of the work for making modifications to it. \u201cObject code\u201d means any non-source form of a work.</p> <p>A \u201cStandard Interface\u201d means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.</p> <p>The \u201cSystem Libraries\u201d of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \u201cMajor Component\u201d, in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.</p> <p>The \u201cCorresponding Source\u201d for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work\u2019s System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.</p> <p>The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.</p> <p>The Corresponding Source for a work in source code form is that same work.</p> </li> <li> <p>Basic Permissions.</p> <p>All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.</p> <p>You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.</p> <p>Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.</p> </li> <li> <p>Protecting Users\u2019 Legal Rights From Anti-Circumvention Law.</p> <p>No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.</p> <p>When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work\u2019s users, your or third parties\u2019 legal rights to forbid circumvention of technological measures.</p> </li> <li> <p>Conveying Verbatim Copies.</p> <p>You may convey verbatim copies of the Program\u2019s source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.</p> <p>You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.</p> </li> <li> <p>Conveying Modified Source Versions.</p> <p>You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:</p> <ol> <li>The work must carry prominent notices stating that you modified     it, and giving a relevant date.</li> <li>The work must carry prominent notices stating that it is     released under this License and any conditions added under     section 7. This requirement modifies the requirement in section     4 to \u201ckeep intact all notices\u201d.</li> <li>You must license the entire work, as a whole, under this License     to anyone who comes into possession of a copy. This License will     therefore apply, along with any applicable section 7 additional     terms, to the whole of the work, and all its parts, regardless     of how they are packaged. This License gives no permission to     license the work in any other way, but it does not invalidate     such permission if you have separately received it.</li> <li>If the work has interactive user interfaces, each must display     Appropriate Legal Notices; however, if the Program has     interactive interfaces that do not display Appropriate Legal     Notices, your work need not make them do so.</li> </ol> <p>A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \u201caggregate\u201d if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation\u2019s users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.</p> </li> <li> <p>Conveying Non-Source Forms.</p> <p>You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:</p> <ol> <li>Convey the object code in, or embodied in, a physical product     (including a physical distribution medium), accompanied by the     Corresponding Source fixed on a durable physical medium     customarily used for software interchange.</li> <li>Convey the object code in, or embodied in, a physical product     (including a physical distribution medium), accompanied by a     written offer, valid for at least three years and valid for as     long as you offer spare parts or customer support for that     product model, to give anyone who possesses the object code     either (1) a copy of the Corresponding Source for all the     software in the product that is covered by this License, on a     durable physical medium customarily used for software     interchange, for a price no more than your reasonable cost of     physically performing this conveying of source, or (2) access to     copy the Corresponding Source from a network server at no     charge.</li> <li>Convey individual copies of the object code with a copy of the     written offer to provide the Corresponding Source. This     alternative is allowed only occasionally and noncommercially,     and only if you received the object code with such an offer, in     accord with subsection 6b.</li> <li>Convey the object code by offering access from a designated     place (gratis or for a charge), and offer equivalent access to     the Corresponding Source in the same way through the same place     at no further charge. You need not require recipients to copy     the Corresponding Source along with the object code. If the     place to copy the object code is a network server, the     Corresponding Source may be on a different server (operated by     you or a third party) that supports equivalent copying     facilities, provided you maintain clear directions next to the     object code saying where to find the Corresponding Source.     Regardless of what server hosts the Corresponding Source, you     remain obligated to ensure that it is available for as long as     needed to satisfy these requirements.</li> <li>Convey the object code using peer-to-peer transmission, provided     you inform other peers where the object code and Corresponding     Source of the work are being offered to the general public at no     charge under subsection 6d.</li> </ol> <p>A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.</p> <p>A \u201cUser Product\u201d is either (1) a \u201cconsumer product\u201d, which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \u201cnormally used\u201d refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.</p> <p>\u201cInstallation Information\u201d for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.</p> <p>If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).</p> <p>The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.</p> <p>Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.</p> </li> <li> <p>Additional Terms.</p> <p>\u201cAdditional permissions\u201d are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.</p> <p>When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.</p> <p>Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:</p> <ol> <li>Disclaiming warranty or limiting liability differently from the     terms of sections 15 and 16 of this License; or</li> <li>Requiring preservation of specified reasonable legal notices or     author attributions in that material or in the Appropriate Legal     Notices displayed by works containing it; or</li> <li>Prohibiting misrepresentation of the origin of that material, or     requiring that modified versions of such material be marked in     reasonable ways as different from the original version; or</li> <li>Limiting the use for publicity purposes of names of licensors or     authors of the material; or</li> <li>Declining to grant rights under trademark law for use of some     trade names, trademarks, or service marks; or</li> <li>Requiring indemnification of licensors and authors of that     material by anyone who conveys the material (or modified     versions of it) with contractual assumptions of liability to the     recipient, for any liability that these contractual assumptions     directly impose on those licensors and authors.</li> </ol> <p>All other non-permissive additional terms are considered \u201cfurther restrictions\u201d within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.</p> <p>If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.</p> <p>Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.</p> </li> <li> <p>Termination.</p> <p>You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).</p> <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p> <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p> <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.</p> </li> <li> <p>Acceptance Not Required for Having Copies.</p> <p>You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.</p> </li> <li> <p>Automatic Licensing of Downstream Recipients.</p> <p>Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.</p> <p>An \u201centity transaction\u201d is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party\u2019s predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.</p> <p>You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.</p> </li> <li> <p>Patents.</p> <p>A \u201ccontributor\u201d is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor\u2019s \u201ccontributor version\u201d.</p> <p>A contributor\u2019s \u201cessential patent claims\u201d are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \u201ccontrol\u201d includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.</p> <p>Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor\u2019s essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.</p> <p>In the following three paragraphs, a \u201cpatent license\u201d is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \u201cgrant\u201d such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.</p> <p>If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \u201cKnowingly relying\u201d means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient\u2019s use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.</p> <p>If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.</p> <p>A patent license is \u201cdiscriminatory\u201d if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.</p> <p>Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.</p> </li> <li> <p>No Surrender of Others\u2019 Freedom.</p> <p>If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.</p> </li> <li> <p>Use with the GNU Affero General Public License.</p> <p>Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.</p> </li> <li> <p>Revised Versions of this License.</p> <p>The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \u201cor any later version\u201d applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.</p> <p>If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy\u2019s public statement of acceptance of a version permanently authorizes you to choose that version for the Program.</p> <p>Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.</p> </li> <li> <p>Disclaimer of Warranty.</p> <p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201cAS IS\u201d WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p> </li> <li> <p>Limitation of Liability.</p> <p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p> </li> <li> <p>Interpretation of Sections 15 and 16.</p> <p>If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.</p> </li> </ol> <p></p>"},{"location":"Electronics/GNUC/gnuc/#end-of-terms-and-conditions","title":"END OF TERMS AND CONDITIONS","text":""},{"location":"Electronics/GNUC/gnuc/#how-to-apply-these-terms-to-your-new-programs","title":"How to Apply These Terms to Your New Programs","text":"<p>If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.</p> <p>To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \u201ccopyright\u201d line and a pointer to where the full notice is found.</p> <pre><code>one line to give the program's name and a brief idea of what it does.\nCopyright (C) year name of author\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or (at\nyour option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see https://www.gnu.org/licenses/.\n</code></pre> <p>Also add information on how to contact you by electronic and paper mail.</p> <p>If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode:</p> <pre><code>program Copyright (C) year name of author\nThis program comes with ABSOLUTELY NO WARRANTY; for details type \u2018show w\u2019.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions; type \u2018show c\u2019 for details.\n</code></pre> <p>The hypothetical commands \u2018<code>show w</code>\u2019 and \u2018<code>show c</code>\u2019 should show the appropriate parts of the General Public License. Of course, your program\u2019s commands might be different; for a GUI interface, you would use an \u201cabout box\u201d.</p> <p>You should also get your employer (if you work as a programmer) or school, if any, to sign a \u201ccopyright disclaimer\u201d for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see https://www.gnu.org/licenses/.</p> <p>The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read https://www.gnu.org/licenses/why-not-lgpl.html.</p> <p></p> <p>Next: Concept Index, Previous: GNU General Public License, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#index-of-symbols-and-keywords","title":"Index of Symbols and Keywords","text":"Jump to: \u00a0 # _ A B C D E F G I L M R S T U V W Index Entry Section # <code>#define</code>: Object-like Macros <code>#elif</code>: elif <code>#else</code>: else <code>#endif</code>: ifdef <code>#error</code>: Diagnostics <code>#if</code>: Conditional Syntax <code>#ifdef</code>: ifdef <code>#ifndef</code>: ifdef <code>#include</code>: include Syntax <code>#line</code>: Line Control <code>#undef</code>: Undefining and Redefining Macros <code>#warning</code>: Diagnostics _ <code>_Alignas</code>: Type Alignment <code>_Alignof</code>: Type Alignment <code>_Complex</code>: Complex Data Types <code>_Static_assert</code>: Static Assertions <code>__aligned__</code>: Type Alignment <code>__alignof__</code>: Type Alignment <code>__attribute__</code>: Attributes <code>__auto_type</code>: Auto Type <code>__complex__</code>: Complex Data Types <code>__label__</code>: Local Labels A <code>auto</code>: auto and register B <code>bool</code>: Boolean Type <code>break</code>: break Statement C <code>case</code>: switch Statement <code>char</code>: Basic Integers <code>CHAR_MAX</code>: Maximum and Minimum Values <code>const</code>: const <code>continue</code>: continue Statement D <code>DBL_DECIMAL_DIG</code>: Floating Type Specs <code>DBL_HAS_SUBNORM</code>: Floating Type Specs <code>DBL_MAX</code>: Floating Type Specs <code>DBL_MIN</code>: Floating Type Specs <code>DBL_TRUE_MIN</code>: Floating Type Specs <code>default</code>: switch Statement <code>do</code>: do-while Statement <code>double</code>: Floating-Point Data Types E <code>else</code>: if-else Statement <code>extern</code>: Extern Declarations F <code>float</code>: Floating-Point Data Types <code>FLT_DECIMAL_DIG</code>: Floating Type Specs <code>FLT_HAS_SUBNORM</code>: Floating Type Specs <code>FLT_MAX</code>: Floating Type Specs <code>FLT_MIN</code>: Floating Type Specs <code>FLT_TRUE_MIN</code>: Floating Type Specs <code>for</code>: for Statement G <code>goto</code>: goto Statement I <code>if</code>: if Statement <code>inline</code>: Inline Function Definitions <code>int</code>: Basic Integers <code>INT_MAX</code>: Maximum and Minimum Values L <code>LDBL_DECIMAL_DIG</code>: Floating Type Specs <code>LDBL_HAS_SUBNORM</code>: Floating Type Specs <code>LDBL_MAX</code>: Floating Type Specs <code>LDBL_MIN</code>: Floating Type Specs <code>LDBL_TRUE_MIN</code>: Floating Type Specs <code>LLONG_MAX</code>: Maximum and Minimum Values <code>long double</code>: Floating-Point Data Types <code>long int</code>: Basic Integers <code>long long int</code>: Basic Integers <code>LONG_MAX</code>: Maximum and Minimum Values M <code>main</code>: The main Function R <code>register</code>: auto and register <code>restrict</code>: restrict Pointers <code>return</code>: return Statement S <code>SCHAR_MAX</code>: Maximum and Minimum Values <code>short int</code>: Basic Integers <code>SHRT_MAX</code>: Maximum and Minimum Values <code>signed</code>: Signed and Unsigned Types <code>sizeof</code>: Type Size <code>static</code>: Static Local Variables <code>static</code>: Static Functions <code>struct</code>: Structures <code>switch</code>: switch Statement T <code>typedef</code>: Defining Typedef Names <code>typeof</code>: Auto Type U <code>UCHAR_MAX</code>: Maximum and Minimum Values <code>UINT_MAX</code>: Maximum and Minimum Values <code>ULLONG_MAX</code>: Maximum and Minimum Values <code>ULONG_MAX</code>: Maximum and Minimum Values <code>union</code>: Unions <code>unsigned</code>: Signed and Unsigned Types <code>USHRT_MAX</code>: Maximum and Minimum Values V <code>void</code>: The Void Type <code>volatile</code>: volatile W <code>while</code>: while Statement Jump to: \u00a0 # _ A B C D E F G I L M R S T U V W <p>Previous: Symbol Index, Up: Top \u00a0 [Contents][Index]</p> <p></p>"},{"location":"Electronics/GNUC/gnuc/#concept-index","title":"Concept Index","text":"Jump to: \u00a0 # ? \\ _ A B C D E F G H I K L M N O P Q R S T U V W Z Index Entry Section # <code>#</code> operator: Stringification <code>##</code> operator: Concatenation ? ?: side effect: Conditional Branches \\ \u2018\\a\u2019: Character Constants \u2018\\b\u2019: Character Constants \u2018\\e\u2019: Character Constants \u2018\\f\u2019: Character Constants \u2018\\n\u2019: Character Constants \u2018\\r\u2019: Character Constants \u2018\\t\u2019: Character Constants \u2018\\v\u2019: Character Constants _ \u2018_\u2019 in variables in macros: Macros and Auto Type <code>_Complex</code> keyword: Complex Data Types _Complex_I: Imaginary Constants <code>__attribute__((packed))</code>: Packed Structures <code>__complex__</code> keyword: Complex Data Types A accessing array elements: Accessing Array Elements addition operator: Basic Arithmetic address of a label: Labels as Values address-of operator: Address of Data aliasing (of storage): Aliasing alignment of type: Type Alignment allocating memory dynamically: Dynamic Memory Allocation allocation file-scope variables: Allocating File-Scope argument promotions: Argument Promotions arguments: Macro Arguments arguments in macro definitions: Macro Arguments arithmetic operators: Arithmetic arithmetic, pointer: Pointer Arithmetic array: Arrays array as parameters: Arrays as Parameters array elements, accessing: Accessing Array Elements array example: Array Example array fields, flexible: Flexible Array Fields array of length zero: Zero Length array of variable length: Arrays of Variable Length array parameters, variable-length: Variable-Length Array Parameters array types, incomplete: Incomplete Array Types array values, constructing: Constructing Array Values array, declaring: Declaring an Array array, declaring: Declaring Arrays and Pointers array, layout in memory: Multidimensional Arrays array, multidimensional: Multidimensional Arrays arrays and pointers: Pointers and Arrays assigning function pointers: Assigning Function Pointers assigning structures: Structure Assignment assignment expressions: Assignment Expressions assignment in subexpressions: Assignment in Subexpressions assignment type conversions: Assignment Type Conversions assignment, modifying: Modifying Assignment assignment, simple: Simple Assignment associativity and ordering: Associativity and Ordering attributes: Attributes <code>auto</code> declarations: auto and register B backspace: Character Constants base conversion (floating point): Round-Trip Base Conversion bell character: Character Constants binary integer constants: Integer Constants binary operator grammar: Binary Operator Grammar bit fields: Bit Fields bitwise operators: Bitwise Operations block: Blocks block scope: Scope boolean type: Boolean Type branch cuts: Complex Arithmetic branches of conditional expression: Conditional Branches <code>break</code> statement: break Statement bytes: Storage C call-by-value: Function Call Semantics calling function pointers: Calling Function Pointers calling functions: Function Calls carriage return in source: Whitespace case labels in initializers: Designated Inits case of letters in identifiers: Identifiers case ranges: Case Ranges cast: Explicit Type Conversion cast to a union: Cast to Union character constants: Character Constants character set: Characters <code>CHAR_BIT</code>: Integer Representations cloning: Label Value Caveats combining variable declarations: Combining Variable Declarations comma operator: Comma Operator command-line parameters: Command-line Parameters commenting out code: Deleted Code comments: Comments common type: Common Type comparison, pointer: Pointer Comparison comparisons: Numeric Comparisons compatible types: Compatible Types compilation module: Compilation compiler options for integer overflow: Signed Overflow compiling: Compile Example complete example program: Complete Program complex arithmetic in floating-point calculations: Complex Arithmetic complex conjugation: Complex Data Types complex constants: Imaginary Constants complex numbers: Complex Data Types compound statement: Blocks computed gotos: Labels as Values computed includes: Computed Includes concatenation: Concatenation conditional expression: Conditional Expression conditional group: ifdef conditionals: Conditionals conjunction operator: Logical Operators conjunction, bitwise: Bitwise Operations const fields: const Fields <code>const</code> variables and fields: const constant data types, integer: Integer Const Type constants: Constants constants, character: Character Constants constants, floating-point: Floating Constants constants, imaginary: Imaginary Constants constants, integer: Integer Constants constants, string: String Constants constants, wide character: Wide Character Constants constants, wide string: Wide String Constants constructing array values: Constructing Array Values constructors, structure: Structure Constructors continuation of lines: Line Continuation <code>continue</code> statement: continue Statement controlling macro: Once-Only Headers conversion between pointers and integers: Pointer-Integer Conversion conversions, type: Type Conversions counting vowels and punctuation: switch Example crash: Stack D declararing functions: Function Declarations declaration of variables: Variable Declarations declarations inside expressions: Statement Exprs declarations, combining: Combining Variable Declarations declarations, <code>extern</code>: Extern Declarations declaring an array: Declaring an Array declaring arrays and pointers: Declaring Arrays and Pointers declaring function pointers: Declaring Function Pointers decrement operator: Increment/Decrement decrementing pointers: Pointer Increment/Decrement <code>defined</code>: defined defining functions: Function Definitions dereferencing pointers: Pointer Dereference designated initializers: Designated Inits diagnostic: Diagnostics digraphs: Digraphs directive line: Directives directive name: Directives directives: Directives disjunction operator: Logical Operators disjunction, bitwise: Bitwise Operations division by zero: Division and Remainder division operator: Basic Arithmetic <code>do</code>\u2013<code>while</code> statement: do-while Statement downward funargs: Nested Functions drawbacks of pointer arithmetic: Pointer Arithmetic Drawbacks Duff\u2019s device: Duffs Device dynamic memory allocation: Dynamic Memory Allocation E elements of arrays: Arrays empty macro arguments: Macro Arguments enumeration types: Enumeration Types enumerator: Enumeration Types environment variables: Environment Variables equal operator: Numeric Comparisons error recovery (floating point): Error Recovery escape (ASCII character): Character Constants escape sequence: Character Constants exact floating-point arithmetic: Exact Floating-Point exact specification of floating-point constants: Exact Floating Constants example program, complete: Complete Program exception flags (floating point): Exception Flags executable file: Compile Example execution control expressions: Execution Control Expressions exit status: Values from main <code>EXIT_FAILURE</code>: Values from main <code>EXIT_SUCCESS</code>: Values from main expansion of arguments: Argument Prescan explicit type conversion: Explicit Type Conversion expression statement: Expression Statement expression, conditional: Conditional Expression expressions containing statements: Statement Exprs expressions, execution control: Execution Control Expressions <code>extern</code> declarations: Extern Declarations extern inline function: Inline Function Definitions F failure: Values from main Fibonacci function, iterative: Iterative Fibonacci Fibonacci function, recursive: Recursive Fibonacci field offset: Field Offset fields in structures: Structures file-scope variables: File-Scope Variables file-scope variables, allocating: Allocating File-Scope first-class object: Limitations of C Arrays flexible array fields: Flexible Array Fields floating arithmetic exception flags: Exception Flags floating overflow: Exception Flags floating point example: Float Example floating underflow: Special Float Values floating underflow: Exception Flags floating-point arithmetic invalid optimizations: Invalid Optimizations floating-point arithmetic with complex numbers: Complex Arithmetic floating-point arithmetic, exact: Exact Floating-Point floating-point constants: Floating Constants floating-point constants, exact specification of: Exact Floating Constants floating-point error recovery: Error Recovery floating-point fused multiply-add: Fused Multiply-Add floating-point infinity: Handling Infinity floating-point machine epsilon: Machine Epsilon floating-point NaN: Handling NaN floating-point representations: Floating Representations floating-point round-trip base conversion: Round-Trip Base Conversion floating-point rounding control: Rounding Control floating-point rounding issues: Rounding Issues floating-point scaling by powers of the base: Scaling by the Base floating-point signed zeros: Signed Zeros floating-point significance loss: Significance Loss floating-point types: Floating-Point Data Types floating-point values, special: Special Float Values <code>for</code> statement: for Statement formfeed: Character Constants formfeed in source: Whitespace forward declaration: Static Functions forward function declarations: Forward Function Declarations full expression: Sequence Points function body: Function Body function call semantics: Function Call Semantics function calls: Function Calls function declarations: Function Declarations function declarations, forward: Forward Function Declarations function definitions: Function Definitions function definitions, inline: Inline Function Definitions function definitions, old-style: Old-Style Function Definitions function header: Function Header function parameter lists, variable length: Variable Number of Arguments function parameter variables: Function Parameter Variables function pointers: Function Pointers function pointers, assigning: Assigning Function Pointers function pointers, calling: Calling Function Pointers function pointers, declaring: Declaring Function Pointers function prototype: Function Declarations function prototype scope: Scope function scope: Scope function-like macros: Function-like Macros functions: Functions functions that accept variable-length arrays: Variable-Length Array Parameters functions with array parameters: Arrays as Parameters functions, nested: Nested Functions functions, static: Static Functions fused multiply-add in floating-point computations: Fused Multiply-Add G global variables: File-Scope Variables <code>goto</code> statement: goto Statement goto with computed label: Labels as Values grammar, binary operator: Binary Operator Grammar greater-or-equal operator: Numeric Comparisons greater-than operator: Numeric Comparisons guard macro: Once-Only Headers H handler (for signal): Signals header file: Header Files hexadecimal floating-point constants: Exact Floating Constants I identifiers: Identifiers identifiers: Preprocessing Tokens IEEE 754-2008 Standard: Floating Representations <code>if</code> statement: if Statement <code>if</code>\u2026<code>else</code> statement: if-else Statement imaginary constants: Imaginary Constants including just once: Once-Only Headers incomplete array types: Incomplete Array Types incomplete types: Incomplete Types increment operator: Increment/Decrement incrementing pointers: Pointer Increment/Decrement infinity in floating-point arithmetic: Handling Infinity initializers: Initializers initializers with labeled elements: Designated Inits inline function definitions: Inline Function Definitions inline functions, omission of: Inline Function Definitions integer arithmetic: Integer Arithmetic integer constant data types: Integer Const Type integer constants: Integer Constants integer overflow: Integer Overflow integer overflow, compiler options: Signed Overflow integer ranges: Maximum and Minimum Values integer representations: Integer Representations integer types: Integer Types internal block: Blocks <code>intptr_t</code>: Low-Level Pointer Arithmetic invalid optimizations in floating-point arithmetic: Invalid Optimizations iteration: Loop Statements iterative Fibonacci function: Iterative Fibonacci K K&amp;R-style function definitions: Old-Style Function Definitions keyword: Identifiers L label: goto Statement labeled elements in initializers: Designated Inits labels as values: Labels as Values layout of structures: Structure Layout left-associative: Binary Operator Grammar length-zero arrays: Zero Length less-or-equal operator: Numeric Comparisons less-than operator: Numeric Comparisons lexical syntax: Lexical Syntax limitations of C arrays: Limitations of C Arrays line continuation: Line Continuation line control: Line Control linefeed in source: Whitespace link: Compilation linking object files: Compilation local labels: Local Labels local variables: Local Variables local variables in macros: Macros and Auto Type logical operators: Logical Operators loop statements: Loop Statements low level pointer arithmetic: Low-Level Pointer Arithmetic lvalues: Lvalues M machine epsilon (floating point): Machine Epsilon macro argument expansion: Argument Prescan macro arguments and directives: Directives Within Macro Arguments macros: Macros macros in include: Computed Includes macros with arguments: Macro Arguments macros with variable arguments: Variadic Macros macros, local labels: Local Labels macros, local variables in: Macros and Auto Type macros, types of arguments: Auto Type <code>main</code> function: The main Function make rules: Compilation manifest constants: Object-like Macros maximum integer values: Maximum and Minimum Values memory allocation, dynamic: Dynamic Memory Allocation memory organization: Storage minimum integer values: Maximum and Minimum Values modifying assignment: Modifying Assignment modulus: Division and Remainder multidimensional arrays: Multidimensional Arrays multiplication operator: Basic Arithmetic N NaN in floating-point arithmetic: Handling NaN NaNs-always-propagate rule: Handling NaN negation operator: Basic Arithmetic negation operator, logical: Logical Operators negation, bitwise: Bitwise Operations nested block: Blocks nested functions: Nested Functions newline: Character Constants newline in source: Whitespace not a number: Handling NaN not-equal operator: Numeric Comparisons null directive: Null Directive null pointers: Null Pointers null statement: Null Statement numbers, preprocessing: Preprocessing Tokens numeric comparisons: Numeric Comparisons O object file: Compilation object-like macro: Object-like Macros offset of structure fields: Field Offset old-style function definitions: Old-Style Function Definitions omitting types in declarations: Omitting Types operand execution ordering: Reordering of Operands operand ordering: Ordering of Operands operand promotions: Operand Promotions operator precedence: Binary Operator Grammar operator, addition: Basic Arithmetic operator, comma: Comma Operator operator, decrement: Increment/Decrement operator, division: Basic Arithmetic operator, equal: Numeric Comparisons operator, greater-or-equal: Numeric Comparisons operator, greater-than: Numeric Comparisons operator, increment: Increment/Decrement operator, less-or-equal: Numeric Comparisons operator, less-than: Numeric Comparisons operator, multiplication: Basic Arithmetic operator, negation: Basic Arithmetic operator, not-equal: Numeric Comparisons operator, postdecrement: Postincrement/Postdecrement operator, postincrement: Postincrement/Postdecrement operator, remainder: Division and Remainder operator, subtraction: Basic Arithmetic operators: Operators/Punctuation operators, arithmetic: Arithmetic operators, assignment: Assignment Expressions operators, bitwise: Bitwise Operations operators, comparison: Numeric Comparisons operators, logical: Logical Operators operators, shift: Shift Operations operators, shift: Shift Operations optimization and ordering: Optimization and Ordering order of execution: Order of Execution ordering and optimization: Optimization and Ordering ordering and postincrement: Postincrement and Ordering ordering of operands: Reordering of Operands ordering of operands: Ordering of Operands overflow, compiler options: Signed Overflow overflow, floating: Exception Flags overflow, integer: Integer Overflow overlaying structures: Overlaying Structures P packed structures: Packed Structures parameter forward declaration: Variable-Length Array Parameters parameter list: Function Parameter Variables parameter variables in functions: Function Parameter Variables parameters lists, variable length: Variable Number of Arguments parameters, command-line: Command-line Parameters parentheses in macro bodies: Operator Precedence Problems pitfalls of macros: Macro Pitfalls pointer arithmetic: Pointer Arithmetic pointer arithmetic, drawbacks: Pointer Arithmetic Drawbacks pointer arithmetic, low-level: Low-Level Pointer Arithmetic pointer comparison: Pointer Comparison pointer dereferencing: Pointer Dereference pointer increment and decrement: Pointer Increment/Decrement pointer type conversion: Aliasing pointer-integer conversion: Pointer-Integer Conversion pointers: Pointers pointers and arrays: Pointers and Arrays pointers to functions: Function Pointers pointers, declaring: Declaring Arrays and Pointers pointers, null: Null Pointers pointers, <code>restrict</code>-qualified: restrict Pointers pointers, void: Void Pointers postdecrement expression: Postincrement/Postdecrement postincrement and ordering: Postincrement and Ordering postincrement expression: Postincrement/Postdecrement precedence, operator: Binary Operator Grammar predecrement expression: Increment/Decrement predefined macros: Predefined Macros preincrement expression: Increment/Decrement preprocessing: Preprocessing preprocessing directives: Directives preprocessing numbers: Preprocessing Tokens preprocessing tokens: Preprocessing Tokens prescan of macro arguments: Argument Prescan primitive types: Primitive Types <code>printf</code>: Complete Explanation problems with macros: Macro Pitfalls promotion of arguments: Argument Promotions prototype of a function: Function Declarations punctuation: Operators/Punctuation Q QNaN: Special Float Values quote directories: Search Path R ranges in case statements: Case Ranges ranges of integer types: Maximum and Minimum Values recursion: Function Body recursion, drawbacks of: Stack recursive Fibonacci function: Recursive Fibonacci redefining macros: Undefining and Redefining Macros referencing structure fields: Referencing Fields <code>register</code> declarations: auto and register remainder operator: Division and Remainder reordering of operands: Reordering of Operands repeated inclusion: Once-Only Headers reporting errors: Diagnostics reporting warnings: Diagnostics representation of floating-point numbers: Floating Representations representation of integers: Integer Representations reserved words: Identifiers <code>restrict</code> pointers: restrict Pointers return (ASCII character): Character Constants <code>return</code> statement: return Statement returning values from <code>main</code>: Values from main round-trip base conversion: Round-Trip Base Conversion rounding: Rounding rounding control (floating point): Rounding Control rounding issues (floating point): Rounding Issues S scaling floating point by powers of the base: Scaling by the Base scope: Scope segmentation fault: Stack self-reference: Self-Referential Macros semantics of function calls: Function Call Semantics semicolons (after macro calls): Swallowing the Semicolon sequence points: Sequence Points shift count: Shift Operations shift operators: Shift Operations side effect in ?:: Conditional Branches side effects (in macro arguments): Duplication of Side Effects <code>SIGBUS</code>: Signals <code>SIGFPE</code>: Signals signal: Signals signed types: Signed and Unsigned Types signed zeros in floating-point arithmetic: Signed Zeros significance loss (floating point): Significance Loss <code>SIGSEGV</code>: Signals simple assignment: Simple Assignment size of type: Type Size SNaN: Special Float Values space character in source: Whitespace special floating-point values: Special Float Values stack: Stack stack frame: Stack stack frame: Stack stack overflow: Stack standard output: Complete Explanation statement, <code>break</code>: break Statement statement, <code>continue</code>: continue Statement statement, <code>do</code>\u2013<code>while</code>: do-while Statement statement, expression: Expression Statement statement, <code>for</code>: for Statement statement, <code>goto</code>: goto Statement statement, <code>if</code>: if Statement statement, <code>if</code>\u2026<code>else</code>: if-else Statement statement, null: Null Statement statement, <code>return</code>: return Statement statement, <code>switch</code>: switch Statement statement, <code>while</code>: while Statement statements: Statements statements inside expressions: Statement Exprs statements, loop: Loop Statements static assertions: Static Assertions static function, declaration: Static Functions static functions: Static Functions static local variables: Static Local Variables sticky exception flags (floating point): Exception Flags storage organization: Storage string: Strings string constants: String Constants stringification: Stringification structure assignment: Structure Assignment structure constructors: Structure Constructors structure field offset: Field Offset structure fields, constant: const Fields structure fields, referencing: Referencing Fields structure layout: Structure Layout structures: Structures structures, overlaying: Overlaying Structures structures, unnamed: Unnamed Types as Fields subexpressions, assignment in: Assignment in Subexpressions subnormal numbers: Special Float Values subtraction operator: Basic Arithmetic success: Values from main <code>switch</code> statement: switch Statement symbolic constants: Object-like Macros system header files: Header Files T tab (ASCII character): Character Constants tab character in source: Whitespace tentative definition: Allocating File-Scope thunks: Nested Functions token: Lexical Syntax token concatenation: Concatenation token pasting: Concatenation truncation: Integer Conversion truth value: Numeric Comparisons two\u2019s-complement representation: Integer Representations twosum: Error Recovery type alignment: Type Alignment type conversion, pointer: Aliasing type conversions: Type Conversions type designator: Type Designators type size: Type Size type tags: Type Tags type, boolean: Boolean Type type, void: The Void Type typedef names: Defining Typedef Names types of integer constants: Integer Const Type types, compatible: Compatible Types types, complex: Complex Data Types types, enumeration: Enumeration Types types, floating-point: Floating-Point Data Types types, incomplete: Incomplete Types types, integer: Integer Types types, primitive: Primitive Types types, signed: Signed and Unsigned Types types, unsigned: Signed and Unsigned Types U <code>uintptr_t</code>: Pointer-Integer Conversion undefining macros: Undefining and Redefining Macros underflow, floating: Special Float Values underflow, floating: Exception Flags underscores in variables in macros: Macros and Auto Type Unicode: Characters Unicode character codes: Unicode Character Codes union, casting to a: Cast to Union unions: Unions unions, unnamed: Unnamed Types as Fields universal character names: Unicode Character Codes unnamed structures: Unnamed Types as Fields unnamed unions: Unnamed Types as Fields unsafe macros: Duplication of Side Effects unsigned types: Signed and Unsigned Types UTF-8 String Constants: UTF-8 String Constants V variable declarations: Variable Declarations variable declarations, combining: Combining Variable Declarations variable number of arguments: Variadic Macros variable-length array parameters: Variable-Length Array Parameters variable-length arrays: Arrays of Variable Length variable-length parameter lists: Variable Number of Arguments variables: Variables variables, <code>const</code>: const variables, file-scope: File-Scope Variables variables, global: File-Scope Variables variables, local: Local Variables variables, local, in macros: Macros and Auto Type variables, static local: Static Local Variables variables, <code>volatile</code>: volatile variadic function: Variable Number of Arguments variadic macros: Variadic Macros <code>va_copy</code>: Variable Number of Arguments <code>va_end</code>: Variable Number of Arguments <code>va_list</code>: Variable Number of Arguments <code>va_start</code>: Variable Number of Arguments vertical tab: Character Constants vertical tab in source: Whitespace void pointers: Void Pointers void type: The Void Type <code>volatile</code> variables and fields: volatile W <code>while</code> statement: while Statement whitespace characters in source files: Whitespace wide character constants: Wide Character Constants wide string constants: Wide String Constants wrapper <code>#ifndef</code>: Once-Only Headers Z zero, division by: Division and Remainder zero-length arrays: Zero Length zero-origin indexing: Array Example Jump to: \u00a0 # ? \\ _ A B C D E F G H I K L M N O P Q R S T U V W Z"},{"location":"Electronics/GNUC/gnuc/#footnotes","title":"Footnotes","text":""},{"location":"Electronics/GNUC/gnuc/#1","title":"(1)","text":"<p>On some obscure systems, GNU C uses UTF-EBCDIC instead of UTF-8, but that is not worth describing in this manual.</p>"},{"location":"Electronics/GNUC/gnuc/#2","title":"(2)","text":"<p>Personal note from Richard Stallman: I wrote GCC without remembering anything about the C precedence order beyond what\u2019s stated here. I studied the full precedence table to write the parser, and promptly forgot it again. If you need to look up the full precedence order to understand some C code, add enough parentheses so nobody else needs to do that.</p>"},{"location":"Electronics/GNUC/gnuc/#3","title":"(3)","text":"<p>Personal note from Richard Stallman: Eating with hackers at a fish restaurant, I ordered Arctic Char. When my meal arrived, I noted that the chef had not signed it. So I complained, \u201cThis char is unsigned\u2014I wanted a signed char!\u201d Or rather, I would have said this if I had thought of it fast enough.</p>"},{"location":"Electronics/GNUC/gnuc/#4","title":"(4)","text":"<p>For compatibility with older versions of GNU C, the keyword <code>__complex__</code> is also allowed. Going forward, however, use the new <code>_Complex</code> keyword as defined in ISO C11.</p>"},{"location":"Electronics/GNUC/gnuc/#5","title":"(5)","text":"<p>The analogous feature in Fortran is called an assigned goto, but that name seems inappropriate in C, since you can do more with label addresses than store them in special label variables.</p>"},{"location":"Electronics/GNUC/gnuc/#6","title":"(6)","text":"<p>Due to compiler optimizations, allocation and deallocation don\u2019t necessarily really happen at those times.</p>"},{"location":"Electronics/GNUC/gnuc/#7","title":"(7)","text":"<p>This is a GNU C extension.</p>"},{"location":"Electronics/GNUC/gnuc/#8","title":"(8)","text":"<p>On an embedded controller where <code>char</code> or <code>short</code> is the same width as <code>int</code>, <code>unsigned char</code> or <code>unsigned short</code> promotes to <code>unsigned int</code>, but that never occurs in GNU C on real computers.</p>"},{"location":"Electronics/GNUC/gnuc/#9","title":"(9)","text":"<p>GNU C extension.</p>"},{"location":"Electronics/GNUC/gnuc/#10","title":"(10)","text":"<p>GNU C extension.</p>"},{"location":"Electronics/GNUC/gnuc/#11","title":"(11)","text":"<p>In theory, any of these types could have some other size, bit it\u2019s not worth even a minute to cater to that possibility. It never happens on GNU/Linux.</p>"},{"location":"Electronics/LIBRARY/canbus/","title":"An\u00e1lisis T\u00e9cnico Avanzado del Protocolo CAN","text":""},{"location":"Electronics/LIBRARY/canbus/#especificaciones-fisicas-del-protocolo-can","title":"Especificaciones F\u00edsicas del Protocolo CAN","text":""},{"location":"Electronics/LIBRARY/canbus/#caracteristicas-electricas","title":"Caracter\u00edsticas El\u00e9ctricas","text":"<ul> <li>Nivel de Se\u00f1al: Diferencial de voltaje entre CAN_H y CAN_L</li> <li>Estado dominante (l\u00f3gico 0): CAN_H \u2248 3.5V, CAN_L \u2248 1.5V</li> <li>Estado recesivo (l\u00f3gico 1): CAN_H \u2248 2.5V, CAN_L \u2248 2.5V</li> <li>Rango de Voltaje: T\u00edpicamente 0-5V</li> <li>Impedancia Caracter\u00edstica: 120 \u03a9 (resistencia de terminaci\u00f3n)</li> </ul>"},{"location":"Electronics/LIBRARY/canbus/#niveles-de-velocidad-de-transmision","title":"Niveles de Velocidad de Transmisi\u00f3n","text":"Velocidad Distancia M\u00e1xima Descripci\u00f3n 1 Mbps Hasta 40 metros Alta velocidad, corta distancia 500 Kbps Hasta 100 metros Configuraci\u00f3n est\u00e1ndar en automoci\u00f3n 250 Kbps Hasta 250 metros Aplicaciones industriales medianas 125 Kbps Hasta 500 metros Redes de largo alcance 10 Kbps Hasta 1000 metros Redes de muy baja velocidad"},{"location":"Electronics/LIBRARY/canbus/#estructura-detallada-del-protocolo-can","title":"Estructura Detallada del Protocolo CAN","text":""},{"location":"Electronics/LIBRARY/canbus/#formato-de-trama-can-iso-11898-1","title":"Formato de Trama CAN (ISO 11898-1)","text":""},{"location":"Electronics/LIBRARY/canbus/#trama-de-datos-data-frame","title":"Trama de Datos (Data Frame)","text":"<ol> <li>Inicio (SOF - Start of Frame)</li> <li>Bit dominante que indica el inicio de transmisi\u00f3n</li> <li> <p>Sincronizaci\u00f3n de todos los nodos</p> </li> <li> <p>Identificador</p> </li> <li>CAN 2.0A (11 bits)</li> <li>CAN 2.0B (29 bits extendidos)</li> <li>Define prioridad del mensaje</li> <li> <p>M\u00e9todo de identificaci\u00f3n \u00fanica</p> </li> <li> <p>Bits de Control</p> </li> <li>IDE (Identifier Extension): Indica formato est\u00e1ndar o extendido</li> <li>RTR (Remote Transmission Request): Diferencia entre trama de datos y remota</li> <li> <p>DLC (Data Length Code): Longitud de datos (0-8 bytes)</p> </li> <li> <p>Campo de Datos</p> </li> <li>M\u00e1ximo 8 bytes de informaci\u00f3n</li> <li> <p>Transmisi\u00f3n bit a bit, comenzando por el bit m\u00e1s significativo</p> </li> <li> <p>CRC (Cyclic Redundancy Check)</p> </li> <li>Polinomio generador: x^15 + x^14 + x^10 + x^8 + x^7 + x^4 + x^3 + 1</li> <li>15 bits de verificaci\u00f3n de error</li> <li> <p>Detecci\u00f3n de hasta 5 bits de error consecutivos</p> </li> <li> <p>Campo de Reconocimiento (ACK)</p> </li> <li>Bit de ACK dominante confirma recepci\u00f3n correcta</li> <li> <p>Transmitido por cualquier nodo receptor</p> </li> <li> <p>Delimitadores y Fin de Trama</p> </li> <li>Bits recesivos que marcan fin de transmisi\u00f3n</li> </ol>"},{"location":"Electronics/LIBRARY/canbus/#mecanismo-de-arbitraje","title":"Mecanismo de Arbitraje","text":""},{"location":"Electronics/LIBRARY/canbus/#principio-de-resolucion-de-conflictos","title":"Principio de Resoluci\u00f3n de Conflictos","text":"<ul> <li>Implementa resoluci\u00f3n bit a bit</li> <li>Nodos monitorizan el bus durante la transmisi\u00f3n</li> <li>Si un nodo escribe un bit dominante mientras otro escribe recesivo, prevalece el bit dominante</li> <li>El identificador m\u00e1s bajo (m\u00e1s bits dominantes) gana el arbitraje</li> </ul>"},{"location":"Electronics/LIBRARY/canbus/#control-de-errores","title":"Control de Errores","text":""},{"location":"Electronics/LIBRARY/canbus/#tipos-de-errores","title":"Tipos de Errores","text":"<ol> <li>Error de Bit</li> <li> <p>Detecci\u00f3n de inconsistencia entre bit transmitido y observado</p> </li> <li> <p>Error de Stuffing</p> </li> <li>Verifica la inserci\u00f3n correcta de bits de relleno</li> <li> <p>M\u00e1ximo 5 bits consecutivos id\u00e9nticos</p> </li> <li> <p>Error de CRC</p> </li> <li> <p>Fallo en la verificaci\u00f3n del checksum</p> </li> <li> <p>Error de Form</p> </li> <li> <p>Violaci\u00f3n de formato de trama esperado</p> </li> <li> <p>Error de Acknowledge</p> </li> <li>Ausencia de confirmaci\u00f3n de recepci\u00f3n</li> </ol>"},{"location":"Electronics/LIBRARY/canbus/#maquina-de-estados-de-error","title":"M\u00e1quina de Estados de Error","text":"<ul> <li>Error Activo: Transmite tramas de error</li> <li>Error Pasivo: Espera recuperaci\u00f3n del bus</li> <li>Bus Off: Desconexi\u00f3n temporal del bus tras m\u00faltiples errores</li> </ul>"},{"location":"Electronics/LIBRARY/canbus/#mecanismos-de-sincronizacion","title":"Mecanismos de Sincronizaci\u00f3n","text":""},{"location":"Electronics/LIBRARY/canbus/#bit-timing","title":"Bit Timing","text":"<ul> <li>Segmentaci\u00f3n del Bit:</li> <li>Sampling Point</li> <li>Synchronization Segment</li> <li>Propagation Time Compensation</li> </ul>"},{"location":"Electronics/LIBRARY/canbus/#tecnicas-de-sincronizacion","title":"T\u00e9cnicas de Sincronizaci\u00f3n","text":"<ul> <li>Hard Synchronization</li> <li>Resynchronization</li> <li>Bit Stuffing</li> </ul>"},{"location":"Electronics/LIBRARY/canbus/#implementacion-en-microcontroladores","title":"Implementaci\u00f3n en Microcontroladores","text":""},{"location":"Electronics/LIBRARY/canbus/#modulos-can-tipicos","title":"M\u00f3dulos CAN T\u00edpicos","text":"<ul> <li>Registro de m\u00e1scara de filtrado</li> <li>B\u00fafer de transmisi\u00f3n y recepci\u00f3n</li> <li>Controlador de interrupciones</li> <li>Generador de velocidad de baudios</li> </ul>"},{"location":"Electronics/LIBRARY/canbus/#ejemplo-de-pseudocodigo-de-transmision","title":"Ejemplo de Pseudoc\u00f3digo de Transmisi\u00f3n","text":"<pre><code>void can_transmit(uint32_t id, uint8_t* data, uint8_t length) {\n    // Configurar identificador\n    CAN_TxMsg.id = id;\n    CAN_TxMsg.length = length;\n\n    // Copiar datos\n    for(uint8_t i = 0; i &lt; length; i++) {\n        CAN_TxMsg.data[i] = data[i];\n    }\n\n    // Iniciar transmisi\u00f3n\n    CAN_SendMessage(&amp;CAN_TxMsg);\n}\n</code></pre>"},{"location":"Electronics/LIBRARY/canbus/#consideraciones-avanzadas","title":"Consideraciones Avanzadas","text":""},{"location":"Electronics/LIBRARY/canbus/#problemas-de-rendimiento","title":"Problemas de Rendimiento","text":"<ul> <li>Latencia variable</li> <li>Overhead de arbitraje</li> <li>Limitaciones de ancho de banda</li> </ul>"},{"location":"Electronics/LIBRARY/canbus/#extensiones-modernas","title":"Extensiones Modernas","text":"<ul> <li>CAN FD (Flexible Data-Rate)</li> <li>CAN XL</li> <li>Mejoras en velocidad y longitud de datos</li> </ul>"},{"location":"Electronics/SYSTEMS/ECU/ecu/","title":"TeR_ECU","text":"<p> La ECU (Electronics Control Unit) es la centralita principal del TeR su trabajo  es leer leer todos los sensores conectados a ella a traves del bus CAN y decidir como debe moverse el powertrain en funci\u00f3n de estos.</p>"},{"location":"Electronics/SYSTEMS/ECU/ecu/#decisiones-de-diseno","title":"Decisiones de dise\u00f1o","text":"<p>Se ha utilizado un micro STM32F405 dado su soporte para 2 CAN 2.0 y  su potencia de computo elevada pudiendo llegar a los 180Mhz  para correr algoritmos de control como el torque vectoring.</p> <p>La ECU es una placa multiproposito ya que implementa puertos de entrada y salida que  pueden ser utilizados para funciones auxiliares como el control de servos o la lectura  de ciertos sensores.</p> <p>Implementa:</p> <ul> <li>STM32F405VGTx Microcontroller (Cortex\u2122-M4 Core@168mHz with FPU)</li> <li>USB For Diagnosis Operation</li> <li>2x CAN 2.0 For its communication with the Powertrain CAN and main sensors CAN</li> <li>NEO M9N GPS modules from u-blox, for determining cars position (Posibility to drive an active Antenna)</li> <li>9DOF IMU consisting in Accelerometer, Gyroscope and Magnetometer for accurate posting and torque algorithms</li> <li>4 Digital Inputs (0V-24V Range)</li> <li>4 PWM Outputs(3.3V), for servo control, including actuators</li> <li>4 Analog Inputs (0V-3.3V) Possibility of configurable Input divider</li> <li>4 Digital Outputs(0V-24V) High side mosfet drivers</li> <li>2 WS2812 RGB Led Channels using integrated SPI for FS-Spain LightShow Acceleration</li> </ul>"},{"location":"Electronics/SYSTEMS/ECU/ecu/#_1","title":"Ecu","text":""},{"location":"Electronics/SYSTEMS/PEDAL/pedal/","title":"Pedal","text":""},{"location":"Electronics/SYSTEMS/PEDAL/pedal/#ter_pedal-hardware-engineering-report","title":"TeR_PEDAL : Hardware Engineering Report","text":"<p>La placa PEDAL del vehiculo TeR, es la encargada de recopilar todos los inputs que el piloto introduce al coche, Acelerador (APPS),  Freno Delantero (BPPS) y Volante (STEER). Los datos obtenidos ser\u00e1n utilizados por la ECU para gestionar el par comandado al powertrain.</p>"},{"location":"Electronics/SYSTEMS/PEDAL/pedal/#requerimientos","title":"Requerimientos","text":"<p>La normativa de FSG tiene una secci\u00f3n (T11.8) que exije los siguientes requerimientos:</p> <p></p>"},{"location":"Electronics/SYSTEMS/PEDAL/pedal/#decisiones","title":"Decisiones","text":""},{"location":"Electronics/SYSTEMS/PEDAL/pedal/#sensores","title":"Sensores","text":"<p>Por simplicidad y flexibilidad utilizaremos sensores anal\u00f3gicos para la medici\u00f3n de los pedales, steering y freno, cualquier Potenciometro   sirve, pero usamos concretamente los VariOhm de Eurosensors</p> Fisicamente Electricamente <p>Para el Freno utilizamos un transductor de Presi\u00f3n-Voltaje que nos permite conocer mediante su funci\u00f3n de transferencia la presi\u00f3n en la linea.</p>"},{"location":"Electronics/SYSTEMS/PEDAL/pedal/#mcu","title":"MCU","text":"<p>Se ha utilizado un stm32F103C8T6 de 48 pines por su facilidad de obtenci\u00f3n, versatilidad, disponibilidad de un buen periferico ADC SAR y soporte CAN.   su uso en la mayor\u00eda de placas de baja potencia de procesamiento permite estandarizar y familiarizar todos los dise\u00f1os donde no se requiere mucha potencia de computo.</p> Specification Description Core ARM Cortex-M3 Operating Frequency 72 MHz Flash Memory 64 KB RAM 20 KB GPIO 37 Timers 3 x 16-bit, 1 x 32-bit, 2 x watchdog Communication Interfaces 2 x I2C, 3 x USART, 2 x SPI, 1 x USB ADC 2 x 12-bit, 10-channel DAC None PWM Channels 15 Operating Voltage 2.0 - 3.6 V Package LQFP48 Temperature Range -40 to +85 \u00b0C Power Consumption (Sleep) 2 \u00b5A Debug Interface SWD, JTAG <p>Estos micros se programan muy facilmente mediante el uso de un debugger ST-link y el stm32CUBE-IDE utilizando las librer\u00edas HAL</p>"},{"location":"Electronics/SYSTEMS/PEDAL/pedal/#filtrado","title":"Filtrado","text":"<p>Para filtrar las se\u00f1ales recibidas por los sensores se utilizan unos filtros paso bajo RC , pasivos sencillos con frecuencia de corte ~100hz lo cual permite eliminar cualquier se\u00f1al que  no provenga del piloto (Sus inputs son mucho m\u00e1s lentos, Fourier...), convendr\u00eda actualizar a filtros activos utilizando opamps para no afectar las impedancias de entrada.</p>"},{"location":"Electronics/SYSTEMS/PEDAL/pedal/#comprobacion-de-requisitos","title":"Comprobaci\u00f3n de requisitos","text":""}]}